<?php
/**
 * DefaultAPI
 * PHP version 8.1
 *
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Discord HTTP API (Preview)
 *
 * Preview of the Discord v10 HTTP API specification. See https://discord.com/developers/docs for more details.
 *
 * The version of the OpenAPI document: 10
 * @generated Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.2.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Tinyoverflow\DiscordPHP;

use InvalidArgumentException;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\Promise\PromiseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * DefaultAPI Class Doc Comment
 *
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DefaultAPI
{
    /**
     * @var ClientInterface
     */
    protected ClientInterface $client;

    /**
     * @var Configuration
     */
    protected Configuration $config;

    /**
     * @var HeaderSelector
     */
    protected HeaderSelector $headerSelector;

    /**
     * @var int Host index
     */
    protected int $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'addGroupDmUser' => [
            'application/json',
        ],
        'addGuildMember' => [
            'application/json',
        ],
        'addGuildMemberRole' => [
            'application/json',
        ],
        'addMyMessageReaction' => [
            'application/json',
        ],
        'addThreadMember' => [
            'application/json',
        ],
        'banUserFromGuild' => [
            'application/json',
        ],
        'bulkDeleteMessages' => [
            'application/json',
        ],
        'bulkSetApplicationCommands' => [
            'application/json',
        ],
        'bulkSetGuildApplicationCommands' => [
            'application/json',
        ],
        'bulkUpdateGuildChannels' => [
            'application/json',
        ],
        'bulkUpdateGuildRoles' => [
            'application/json',
        ],
        'createApplicationCommand' => [
            'application/json',
        ],
        'createAutoModerationRule' => [
            'application/json',
        ],
        'createChannelInvite' => [
            'application/json',
        ],
        'createDm' => [
            'application/json',
        ],
        'createGuild' => [
            'application/json',
        ],
        'createGuildApplicationCommand' => [
            'application/json',
        ],
        'createGuildChannel' => [
            'application/json',
        ],
        'createGuildEmoji' => [
            'application/json',
        ],
        'createGuildFromTemplate' => [
            'application/json',
        ],
        'createGuildRole' => [
            'application/json',
        ],
        'createGuildScheduledEvent' => [
            'application/json',
        ],
        'createGuildSticker' => [
            'multipart/form-data',
        ],
        'createGuildTemplate' => [
            'application/json',
        ],
        'createInteractionResponse' => [
            'application/json',
            'application/x-www-form-urlencoded',
            'multipart/form-data',
        ],
        'createMessage' => [
            'application/json',
            'application/x-www-form-urlencoded',
            'multipart/form-data',
        ],
        'createStageInstance' => [
            'application/json',
        ],
        'createThread' => [
            'application/json',
            'application/x-www-form-urlencoded',
            'multipart/form-data',
        ],
        'createThreadFromMessage' => [
            'application/json',
        ],
        'createWebhook' => [
            'application/json',
        ],
        'crosspostMessage' => [
            'application/json',
        ],
        'deleteAllMessageReactions' => [
            'application/json',
        ],
        'deleteAllMessageReactionsByEmoji' => [
            'application/json',
        ],
        'deleteApplicationCommand' => [
            'application/json',
        ],
        'deleteAutoModerationRule' => [
            'application/json',
        ],
        'deleteChannel' => [
            'application/json',
        ],
        'deleteChannelPermissionOverwrite' => [
            'application/json',
        ],
        'deleteGroupDmUser' => [
            'application/json',
        ],
        'deleteGuild' => [
            'application/json',
        ],
        'deleteGuildApplicationCommand' => [
            'application/json',
        ],
        'deleteGuildEmoji' => [
            'application/json',
        ],
        'deleteGuildIntegration' => [
            'application/json',
        ],
        'deleteGuildMember' => [
            'application/json',
        ],
        'deleteGuildMemberRole' => [
            'application/json',
        ],
        'deleteGuildRole' => [
            'application/json',
        ],
        'deleteGuildScheduledEvent' => [
            'application/json',
        ],
        'deleteGuildSticker' => [
            'application/json',
        ],
        'deleteGuildTemplate' => [
            'application/json',
        ],
        'deleteMessage' => [
            'application/json',
        ],
        'deleteMyMessageReaction' => [
            'application/json',
        ],
        'deleteOriginalWebhookMessage' => [
            'application/json',
        ],
        'deleteStageInstance' => [
            'application/json',
        ],
        'deleteThreadMember' => [
            'application/json',
        ],
        'deleteUserMessageReaction' => [
            'application/json',
        ],
        'deleteWebhook' => [
            'application/json',
        ],
        'deleteWebhookByToken' => [
            'application/json',
        ],
        'deleteWebhookMessage' => [
            'application/json',
        ],
        'executeGithubCompatibleWebhook' => [
            'application/json',
        ],
        'executeSlackCompatibleWebhook' => [
            'application/json',
            'application/x-www-form-urlencoded',
            'multipart/form-data',
        ],
        'executeWebhook' => [
            'application/json',
            'application/x-www-form-urlencoded',
            'multipart/form-data',
        ],
        'followChannel' => [
            'application/json',
        ],
        'getActiveGuildThreads' => [
            'application/json',
        ],
        'getApplication' => [
            'application/json',
        ],
        'getApplicationCommand' => [
            'application/json',
        ],
        'getApplicationRoleConnectionsMetadata' => [
            'application/json',
        ],
        'getApplicationUserRoleConnection' => [
            'application/json',
        ],
        'getAutoModerationRule' => [
            'application/json',
        ],
        'getBotGateway' => [
            'application/json',
        ],
        'getChannel' => [
            'application/json',
        ],
        'getGateway' => [
            'application/json',
        ],
        'getGuild' => [
            'application/json',
        ],
        'getGuildApplicationCommand' => [
            'application/json',
        ],
        'getGuildApplicationCommandPermissions' => [
            'application/json',
        ],
        'getGuildBan' => [
            'application/json',
        ],
        'getGuildEmoji' => [
            'application/json',
        ],
        'getGuildMember' => [
            'application/json',
        ],
        'getGuildNewMemberWelcome' => [
            'application/json',
        ],
        'getGuildPreview' => [
            'application/json',
        ],
        'getGuildScheduledEvent' => [
            'application/json',
        ],
        'getGuildSticker' => [
            'application/json',
        ],
        'getGuildTemplate' => [
            'application/json',
        ],
        'getGuildVanityUrl' => [
            'application/json',
        ],
        'getGuildWebhooks' => [
            'application/json',
        ],
        'getGuildWelcomeScreen' => [
            'application/json',
        ],
        'getGuildWidget' => [
            'application/json',
        ],
        'getGuildWidgetPng' => [
            'application/json',
        ],
        'getGuildWidgetSettings' => [
            'application/json',
        ],
        'getGuildsOnboarding' => [
            'application/json',
        ],
        'getMessage' => [
            'application/json',
        ],
        'getMyApplication' => [
            'application/json',
        ],
        'getMyGuildMember' => [
            'application/json',
        ],
        'getMyOauth2Application' => [
            'application/json',
        ],
        'getMyOauth2Authorization' => [
            'application/json',
        ],
        'getMyUser' => [
            'application/json',
        ],
        'getOriginalWebhookMessage' => [
            'application/json',
        ],
        'getStageInstance' => [
            'application/json',
        ],
        'getSticker' => [
            'application/json',
        ],
        'getThreadMember' => [
            'application/json',
        ],
        'getUser' => [
            'application/json',
        ],
        'getWebhook' => [
            'application/json',
        ],
        'getWebhookByToken' => [
            'application/json',
        ],
        'getWebhookMessage' => [
            'application/json',
        ],
        'inviteResolve' => [
            'application/json',
        ],
        'inviteRevoke' => [
            'application/json',
        ],
        'joinThread' => [
            'application/json',
        ],
        'leaveGuild' => [
            'application/json',
        ],
        'leaveThread' => [
            'application/json',
        ],
        'listApplicationCommands' => [
            'application/json',
        ],
        'listAutoModerationRules' => [
            'application/json',
        ],
        'listChannelInvites' => [
            'application/json',
        ],
        'listChannelWebhooks' => [
            'application/json',
        ],
        'listGuildApplicationCommandPermissions' => [
            'application/json',
        ],
        'listGuildApplicationCommands' => [
            'application/json',
        ],
        'listGuildAuditLogEntries' => [
            'application/json',
        ],
        'listGuildBans' => [
            'application/json',
        ],
        'listGuildChannels' => [
            'application/json',
        ],
        'listGuildEmojis' => [
            'application/json',
        ],
        'listGuildIntegrations' => [
            'application/json',
        ],
        'listGuildInvites' => [
            'application/json',
        ],
        'listGuildMembers' => [
            'application/json',
        ],
        'listGuildRoles' => [
            'application/json',
        ],
        'listGuildScheduledEventUsers' => [
            'application/json',
        ],
        'listGuildScheduledEvents' => [
            'application/json',
        ],
        'listGuildStickers' => [
            'application/json',
        ],
        'listGuildTemplates' => [
            'application/json',
        ],
        'listGuildVoiceRegions' => [
            'application/json',
        ],
        'listMessageReactionsByEmoji' => [
            'application/json',
        ],
        'listMessages' => [
            'application/json',
        ],
        'listMyConnections' => [
            'application/json',
        ],
        'listMyGuilds' => [
            'application/json',
        ],
        'listMyPrivateArchivedThreads' => [
            'application/json',
        ],
        'listPinnedMessages' => [
            'application/json',
        ],
        'listPrivateArchivedThreads' => [
            'application/json',
        ],
        'listPublicArchivedThreads' => [
            'application/json',
        ],
        'listStickerPacks' => [
            'application/json',
        ],
        'listThreadMembers' => [
            'application/json',
        ],
        'listVoiceRegions' => [
            'application/json',
        ],
        'pinMessage' => [
            'application/json',
        ],
        'previewPruneGuild' => [
            'application/json',
        ],
        'pruneGuild' => [
            'application/json',
        ],
        'putGuildsOnboarding' => [
            'application/json',
        ],
        'searchGuildMembers' => [
            'application/json',
        ],
        'setChannelPermissionOverwrite' => [
            'application/json',
        ],
        'setGuildApplicationCommandPermissions' => [
            'application/json',
        ],
        'setGuildMfaLevel' => [
            'application/json',
        ],
        'syncGuildTemplate' => [
            'application/json',
        ],
        'triggerTypingIndicator' => [
            'application/json',
        ],
        'unbanUserFromGuild' => [
            'application/json',
        ],
        'unpinMessage' => [
            'application/json',
        ],
        'updateApplication' => [
            'application/json',
        ],
        'updateApplicationCommand' => [
            'application/json',
        ],
        'updateApplicationRoleConnectionsMetadata' => [
            'application/json',
        ],
        'updateApplicationUserRoleConnection' => [
            'application/json',
        ],
        'updateAutoModerationRule' => [
            'application/json',
        ],
        'updateChannel' => [
            'application/json',
        ],
        'updateGuild' => [
            'application/json',
        ],
        'updateGuildApplicationCommand' => [
            'application/json',
        ],
        'updateGuildEmoji' => [
            'application/json',
        ],
        'updateGuildMember' => [
            'application/json',
        ],
        'updateGuildRole' => [
            'application/json',
        ],
        'updateGuildScheduledEvent' => [
            'application/json',
        ],
        'updateGuildSticker' => [
            'application/json',
        ],
        'updateGuildTemplate' => [
            'application/json',
        ],
        'updateGuildWelcomeScreen' => [
            'application/json',
        ],
        'updateGuildWidgetSettings' => [
            'application/json',
        ],
        'updateMessage' => [
            'application/json',
            'application/x-www-form-urlencoded',
            'multipart/form-data',
        ],
        'updateMyApplication' => [
            'application/json',
        ],
        'updateMyGuildMember' => [
            'application/json',
        ],
        'updateMyUser' => [
            'application/json',
        ],
        'updateOriginalWebhookMessage' => [
            'application/json',
            'application/x-www-form-urlencoded',
            'multipart/form-data',
        ],
        'updateSelfVoiceState' => [
            'application/json',
        ],
        'updateStageInstance' => [
            'application/json',
        ],
        'updateVoiceState' => [
            'application/json',
        ],
        'updateWebhook' => [
            'application/json',
        ],
        'updateWebhookByToken' => [
            'application/json',
        ],
        'updateWebhookMessage' => [
            'application/json',
            'application/x-www-form-urlencoded',
            'multipart/form-data',
        ],
    ];

    /**
     * @param ClientInterface|null $client
     * @param Configuration|null   $config
     * @param HeaderSelector|null  $selector
     * @param int                  $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex(int $hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex(): int
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig(): Configuration
    {
        return $this->config;
    }

    /**
     * Operation addGroupDmUser
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $user_id user_id (required)
     * @param  \OpenAPI\Client\Model\AddGroupDmUserRequest $add_group_dm_user_request add_group_dm_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addGroupDmUser'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\CreateDm200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function addGroupDmUser(
        string $channel_id,
        string $user_id,
        \OpenAPI\Client\Model\AddGroupDmUserRequest $add_group_dm_user_request,
        string $contentType = self::contentTypes['addGroupDmUser'][0]
    ): \OpenAPI\Client\Model\CreateDm200Response
    {
        list($response) = $this->addGroupDmUserWithHttpInfo($channel_id, $user_id, $add_group_dm_user_request, $contentType);
        return $response;
    }

    /**
     * Operation addGroupDmUserWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $user_id (required)
     * @param  \OpenAPI\Client\Model\AddGroupDmUserRequest $add_group_dm_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addGroupDmUser'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CreateDm200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function addGroupDmUserWithHttpInfo(
        string $channel_id,
        string $user_id,
        \OpenAPI\Client\Model\AddGroupDmUserRequest $add_group_dm_user_request,
        string $contentType = self::contentTypes['addGroupDmUser'][0]
    ): array
    {
        $request = $this->addGroupDmUserRequest($channel_id, $user_id, $add_group_dm_user_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\CreateDm200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CreateDm200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CreateDm200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\CreateDm200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CreateDm200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation addGroupDmUserAsync
     *
     * @param  string $channel_id (required)
     * @param  string $user_id (required)
     * @param  \OpenAPI\Client\Model\AddGroupDmUserRequest $add_group_dm_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addGroupDmUser'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function addGroupDmUserAsync(
        string $channel_id,
        string $user_id,
        \OpenAPI\Client\Model\AddGroupDmUserRequest $add_group_dm_user_request,
        string $contentType = self::contentTypes['addGroupDmUser'][0]
    ): PromiseInterface
    {
        return $this->addGroupDmUserAsyncWithHttpInfo($channel_id, $user_id, $add_group_dm_user_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addGroupDmUserAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $user_id (required)
     * @param  \OpenAPI\Client\Model\AddGroupDmUserRequest $add_group_dm_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addGroupDmUser'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function addGroupDmUserAsyncWithHttpInfo(
        $channel_id,
        $user_id,
        $add_group_dm_user_request,
        string $contentType = self::contentTypes['addGroupDmUser'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\CreateDm200Response';
        $request = $this->addGroupDmUserRequest($channel_id, $user_id, $add_group_dm_user_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addGroupDmUser'
     *
     * @param  string $channel_id (required)
     * @param  string $user_id (required)
     * @param  \OpenAPI\Client\Model\AddGroupDmUserRequest $add_group_dm_user_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addGroupDmUser'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addGroupDmUserRequest(
        $channel_id,
        $user_id,
        $add_group_dm_user_request,
        string $contentType = self::contentTypes['addGroupDmUser'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling addGroupDmUser'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.addGroupDmUser, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $user_id when calling addGroupDmUser'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $user_id)) {
            throw new InvalidArgumentException("invalid value for \"user_id\" when calling DefaultAPI.addGroupDmUser, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'add_group_dm_user_request' is set
        if ($add_group_dm_user_request === null || (is_array($add_group_dm_user_request) && count($add_group_dm_user_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $add_group_dm_user_request when calling addGroupDmUser'
            );
        }


        $resourcePath = '/channels/{channel_id}/recipients/{user_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($add_group_dm_user_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($add_group_dm_user_request));
            } else {
                $httpBody = $add_group_dm_user_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addGuildMember
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $user_id user_id (required)
     * @param  \OpenAPI\Client\Model\AddGuildMemberRequest $add_guild_member_request add_guild_member_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addGuildMember'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildMemberResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function addGuildMember(
        string $guild_id,
        string $user_id,
        \OpenAPI\Client\Model\AddGuildMemberRequest $add_guild_member_request,
        string $contentType = self::contentTypes['addGuildMember'][0]
    ): \OpenAPI\Client\Model\GuildMemberResponse
    {
        list($response) = $this->addGuildMemberWithHttpInfo($guild_id, $user_id, $add_guild_member_request, $contentType);
        return $response;
    }

    /**
     * Operation addGuildMemberWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  \OpenAPI\Client\Model\AddGuildMemberRequest $add_guild_member_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addGuildMember'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildMemberResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function addGuildMemberWithHttpInfo(
        string $guild_id,
        string $user_id,
        \OpenAPI\Client\Model\AddGuildMemberRequest $add_guild_member_request,
        string $contentType = self::contentTypes['addGuildMember'][0]
    ): array
    {
        $request = $this->addGuildMemberRequest($guild_id, $user_id, $add_guild_member_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\GuildMemberResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildMemberResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildMemberResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildMemberResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildMemberResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation addGuildMemberAsync
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  \OpenAPI\Client\Model\AddGuildMemberRequest $add_guild_member_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addGuildMember'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function addGuildMemberAsync(
        string $guild_id,
        string $user_id,
        \OpenAPI\Client\Model\AddGuildMemberRequest $add_guild_member_request,
        string $contentType = self::contentTypes['addGuildMember'][0]
    ): PromiseInterface
    {
        return $this->addGuildMemberAsyncWithHttpInfo($guild_id, $user_id, $add_guild_member_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addGuildMemberAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  \OpenAPI\Client\Model\AddGuildMemberRequest $add_guild_member_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addGuildMember'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function addGuildMemberAsyncWithHttpInfo(
        $guild_id,
        $user_id,
        $add_guild_member_request,
        string $contentType = self::contentTypes['addGuildMember'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildMemberResponse';
        $request = $this->addGuildMemberRequest($guild_id, $user_id, $add_guild_member_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addGuildMember'
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  \OpenAPI\Client\Model\AddGuildMemberRequest $add_guild_member_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addGuildMember'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addGuildMemberRequest(
        $guild_id,
        $user_id,
        $add_guild_member_request,
        string $contentType = self::contentTypes['addGuildMember'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling addGuildMember'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.addGuildMember, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $user_id when calling addGuildMember'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $user_id)) {
            throw new InvalidArgumentException("invalid value for \"user_id\" when calling DefaultAPI.addGuildMember, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'add_guild_member_request' is set
        if ($add_guild_member_request === null || (is_array($add_guild_member_request) && count($add_guild_member_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $add_guild_member_request when calling addGuildMember'
            );
        }


        $resourcePath = '/guilds/{guild_id}/members/{user_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($add_guild_member_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($add_guild_member_request));
            } else {
                $httpBody = $add_guild_member_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addGuildMemberRole
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $user_id user_id (required)
     * @param  string $role_id role_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addGuildMemberRole'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function addGuildMemberRole(
        string $guild_id,
        string $user_id,
        string $role_id,
        string $contentType = self::contentTypes['addGuildMemberRole'][0]
    ): void
    {
        $this->addGuildMemberRoleWithHttpInfo($guild_id, $user_id, $role_id, $contentType);
    }

    /**
     * Operation addGuildMemberRoleWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  string $role_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addGuildMemberRole'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function addGuildMemberRoleWithHttpInfo(
        string $guild_id,
        string $user_id,
        string $role_id,
        string $contentType = self::contentTypes['addGuildMemberRole'][0]
    ): array
    {
        $request = $this->addGuildMemberRoleRequest($guild_id, $user_id, $role_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation addGuildMemberRoleAsync
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  string $role_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addGuildMemberRole'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function addGuildMemberRoleAsync(
        string $guild_id,
        string $user_id,
        string $role_id,
        string $contentType = self::contentTypes['addGuildMemberRole'][0]
    ): PromiseInterface
    {
        return $this->addGuildMemberRoleAsyncWithHttpInfo($guild_id, $user_id, $role_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addGuildMemberRoleAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  string $role_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addGuildMemberRole'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function addGuildMemberRoleAsyncWithHttpInfo(
        $guild_id,
        $user_id,
        $role_id,
        string $contentType = self::contentTypes['addGuildMemberRole'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->addGuildMemberRoleRequest($guild_id, $user_id, $role_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addGuildMemberRole'
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  string $role_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addGuildMemberRole'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addGuildMemberRoleRequest(
        $guild_id,
        $user_id,
        $role_id,
        string $contentType = self::contentTypes['addGuildMemberRole'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling addGuildMemberRole'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.addGuildMemberRole, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $user_id when calling addGuildMemberRole'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $user_id)) {
            throw new InvalidArgumentException("invalid value for \"user_id\" when calling DefaultAPI.addGuildMemberRole, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'role_id' is set
        if ($role_id === null || (is_array($role_id) && count($role_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $role_id when calling addGuildMemberRole'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $role_id)) {
            throw new InvalidArgumentException("invalid value for \"role_id\" when calling DefaultAPI.addGuildMemberRole, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/members/{user_id}/roles/{role_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }
        // path params
        if ($role_id !== null) {
            $resourcePath = str_replace(
                '{' . 'role_id' . '}',
                ObjectSerializer::toPathValue($role_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addMyMessageReaction
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $message_id message_id (required)
     * @param  string $emoji_name emoji_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addMyMessageReaction'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function addMyMessageReaction(
        string $channel_id,
        string $message_id,
        string $emoji_name,
        string $contentType = self::contentTypes['addMyMessageReaction'][0]
    ): void
    {
        $this->addMyMessageReactionWithHttpInfo($channel_id, $message_id, $emoji_name, $contentType);
    }

    /**
     * Operation addMyMessageReactionWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $emoji_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addMyMessageReaction'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function addMyMessageReactionWithHttpInfo(
        string $channel_id,
        string $message_id,
        string $emoji_name,
        string $contentType = self::contentTypes['addMyMessageReaction'][0]
    ): array
    {
        $request = $this->addMyMessageReactionRequest($channel_id, $message_id, $emoji_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation addMyMessageReactionAsync
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $emoji_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addMyMessageReaction'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function addMyMessageReactionAsync(
        string $channel_id,
        string $message_id,
        string $emoji_name,
        string $contentType = self::contentTypes['addMyMessageReaction'][0]
    ): PromiseInterface
    {
        return $this->addMyMessageReactionAsyncWithHttpInfo($channel_id, $message_id, $emoji_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addMyMessageReactionAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $emoji_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addMyMessageReaction'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function addMyMessageReactionAsyncWithHttpInfo(
        $channel_id,
        $message_id,
        $emoji_name,
        string $contentType = self::contentTypes['addMyMessageReaction'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->addMyMessageReactionRequest($channel_id, $message_id, $emoji_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addMyMessageReaction'
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $emoji_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addMyMessageReaction'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addMyMessageReactionRequest(
        $channel_id,
        $message_id,
        $emoji_name,
        string $contentType = self::contentTypes['addMyMessageReaction'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling addMyMessageReaction'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.addMyMessageReaction, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $message_id when calling addMyMessageReaction'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $message_id)) {
            throw new InvalidArgumentException("invalid value for \"message_id\" when calling DefaultAPI.addMyMessageReaction, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'emoji_name' is set
        if ($emoji_name === null || (is_array($emoji_name) && count($emoji_name) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $emoji_name when calling addMyMessageReaction'
            );
        }
        if (strlen($emoji_name) > 152133) {
            throw new InvalidArgumentException('invalid length for "$emoji_name" when calling DefaultAPI.addMyMessageReaction, must be smaller than or equal to 152133.');
        }
        

        $resourcePath = '/channels/{channel_id}/messages/{message_id}/reactions/{emoji_name}/@me';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'message_id' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }
        // path params
        if ($emoji_name !== null) {
            $resourcePath = str_replace(
                '{' . 'emoji_name' . '}',
                ObjectSerializer::toPathValue($emoji_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addThreadMember
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $user_id user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addThreadMember'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function addThreadMember(
        string $channel_id,
        string $user_id,
        string $contentType = self::contentTypes['addThreadMember'][0]
    ): void
    {
        $this->addThreadMemberWithHttpInfo($channel_id, $user_id, $contentType);
    }

    /**
     * Operation addThreadMemberWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addThreadMember'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function addThreadMemberWithHttpInfo(
        string $channel_id,
        string $user_id,
        string $contentType = self::contentTypes['addThreadMember'][0]
    ): array
    {
        $request = $this->addThreadMemberRequest($channel_id, $user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation addThreadMemberAsync
     *
     * @param  string $channel_id (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addThreadMember'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function addThreadMemberAsync(
        string $channel_id,
        string $user_id,
        string $contentType = self::contentTypes['addThreadMember'][0]
    ): PromiseInterface
    {
        return $this->addThreadMemberAsyncWithHttpInfo($channel_id, $user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addThreadMemberAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addThreadMember'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function addThreadMemberAsyncWithHttpInfo(
        $channel_id,
        $user_id,
        string $contentType = self::contentTypes['addThreadMember'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->addThreadMemberRequest($channel_id, $user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addThreadMember'
     *
     * @param  string $channel_id (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addThreadMember'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addThreadMemberRequest(
        $channel_id,
        $user_id,
        string $contentType = self::contentTypes['addThreadMember'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling addThreadMember'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.addThreadMember, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $user_id when calling addThreadMember'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $user_id)) {
            throw new InvalidArgumentException("invalid value for \"user_id\" when calling DefaultAPI.addThreadMember, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/channels/{channel_id}/thread-members/{user_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation banUserFromGuild
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $user_id user_id (required)
     * @param  \OpenAPI\Client\Model\BanUserFromGuildRequest $ban_user_from_guild_request ban_user_from_guild_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['banUserFromGuild'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function banUserFromGuild(
        string $guild_id,
        string $user_id,
        \OpenAPI\Client\Model\BanUserFromGuildRequest $ban_user_from_guild_request,
        string $contentType = self::contentTypes['banUserFromGuild'][0]
    ): void
    {
        $this->banUserFromGuildWithHttpInfo($guild_id, $user_id, $ban_user_from_guild_request, $contentType);
    }

    /**
     * Operation banUserFromGuildWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  \OpenAPI\Client\Model\BanUserFromGuildRequest $ban_user_from_guild_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['banUserFromGuild'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function banUserFromGuildWithHttpInfo(
        string $guild_id,
        string $user_id,
        \OpenAPI\Client\Model\BanUserFromGuildRequest $ban_user_from_guild_request,
        string $contentType = self::contentTypes['banUserFromGuild'][0]
    ): array
    {
        $request = $this->banUserFromGuildRequest($guild_id, $user_id, $ban_user_from_guild_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation banUserFromGuildAsync
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  \OpenAPI\Client\Model\BanUserFromGuildRequest $ban_user_from_guild_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['banUserFromGuild'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function banUserFromGuildAsync(
        string $guild_id,
        string $user_id,
        \OpenAPI\Client\Model\BanUserFromGuildRequest $ban_user_from_guild_request,
        string $contentType = self::contentTypes['banUserFromGuild'][0]
    ): PromiseInterface
    {
        return $this->banUserFromGuildAsyncWithHttpInfo($guild_id, $user_id, $ban_user_from_guild_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation banUserFromGuildAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  \OpenAPI\Client\Model\BanUserFromGuildRequest $ban_user_from_guild_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['banUserFromGuild'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function banUserFromGuildAsyncWithHttpInfo(
        $guild_id,
        $user_id,
        $ban_user_from_guild_request,
        string $contentType = self::contentTypes['banUserFromGuild'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->banUserFromGuildRequest($guild_id, $user_id, $ban_user_from_guild_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'banUserFromGuild'
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  \OpenAPI\Client\Model\BanUserFromGuildRequest $ban_user_from_guild_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['banUserFromGuild'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function banUserFromGuildRequest(
        $guild_id,
        $user_id,
        $ban_user_from_guild_request,
        string $contentType = self::contentTypes['banUserFromGuild'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling banUserFromGuild'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.banUserFromGuild, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $user_id when calling banUserFromGuild'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $user_id)) {
            throw new InvalidArgumentException("invalid value for \"user_id\" when calling DefaultAPI.banUserFromGuild, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'ban_user_from_guild_request' is set
        if ($ban_user_from_guild_request === null || (is_array($ban_user_from_guild_request) && count($ban_user_from_guild_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $ban_user_from_guild_request when calling banUserFromGuild'
            );
        }


        $resourcePath = '/guilds/{guild_id}/bans/{user_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($ban_user_from_guild_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($ban_user_from_guild_request));
            } else {
                $httpBody = $ban_user_from_guild_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation bulkDeleteMessages
     *
     * @param  string $channel_id channel_id (required)
     * @param  \OpenAPI\Client\Model\BulkDeleteMessagesRequest $bulk_delete_messages_request bulk_delete_messages_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkDeleteMessages'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function bulkDeleteMessages(
        string $channel_id,
        \OpenAPI\Client\Model\BulkDeleteMessagesRequest $bulk_delete_messages_request,
        string $contentType = self::contentTypes['bulkDeleteMessages'][0]
    ): void
    {
        $this->bulkDeleteMessagesWithHttpInfo($channel_id, $bulk_delete_messages_request, $contentType);
    }

    /**
     * Operation bulkDeleteMessagesWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\BulkDeleteMessagesRequest $bulk_delete_messages_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkDeleteMessages'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function bulkDeleteMessagesWithHttpInfo(
        string $channel_id,
        \OpenAPI\Client\Model\BulkDeleteMessagesRequest $bulk_delete_messages_request,
        string $contentType = self::contentTypes['bulkDeleteMessages'][0]
    ): array
    {
        $request = $this->bulkDeleteMessagesRequest($channel_id, $bulk_delete_messages_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation bulkDeleteMessagesAsync
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\BulkDeleteMessagesRequest $bulk_delete_messages_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkDeleteMessages'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function bulkDeleteMessagesAsync(
        string $channel_id,
        \OpenAPI\Client\Model\BulkDeleteMessagesRequest $bulk_delete_messages_request,
        string $contentType = self::contentTypes['bulkDeleteMessages'][0]
    ): PromiseInterface
    {
        return $this->bulkDeleteMessagesAsyncWithHttpInfo($channel_id, $bulk_delete_messages_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bulkDeleteMessagesAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\BulkDeleteMessagesRequest $bulk_delete_messages_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkDeleteMessages'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function bulkDeleteMessagesAsyncWithHttpInfo(
        $channel_id,
        $bulk_delete_messages_request,
        string $contentType = self::contentTypes['bulkDeleteMessages'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->bulkDeleteMessagesRequest($channel_id, $bulk_delete_messages_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bulkDeleteMessages'
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\BulkDeleteMessagesRequest $bulk_delete_messages_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkDeleteMessages'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function bulkDeleteMessagesRequest(
        $channel_id,
        $bulk_delete_messages_request,
        string $contentType = self::contentTypes['bulkDeleteMessages'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling bulkDeleteMessages'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.bulkDeleteMessages, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'bulk_delete_messages_request' is set
        if ($bulk_delete_messages_request === null || (is_array($bulk_delete_messages_request) && count($bulk_delete_messages_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $bulk_delete_messages_request when calling bulkDeleteMessages'
            );
        }


        $resourcePath = '/channels/{channel_id}/messages/bulk-delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($bulk_delete_messages_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($bulk_delete_messages_request));
            } else {
                $httpBody = $bulk_delete_messages_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation bulkSetApplicationCommands
     *
     * @param  string $application_id application_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandUpdateRequest[] $application_command_update_request application_command_update_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkSetApplicationCommands'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApplicationCommandResponse[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function bulkSetApplicationCommands(
        string $application_id,
        array $application_command_update_request,
        string $contentType = self::contentTypes['bulkSetApplicationCommands'][0]
    ): array
    {
        list($response) = $this->bulkSetApplicationCommandsWithHttpInfo($application_id, $application_command_update_request, $contentType);
        return $response;
    }

    /**
     * Operation bulkSetApplicationCommandsWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandUpdateRequest[] $application_command_update_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkSetApplicationCommands'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApplicationCommandResponse[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function bulkSetApplicationCommandsWithHttpInfo(
        string $application_id,
        array $application_command_update_request,
        string $contentType = self::contentTypes['bulkSetApplicationCommands'][0]
    ): array
    {
        $request = $this->bulkSetApplicationCommandsRequest($application_id, $application_command_update_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ApplicationCommandResponse[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ApplicationCommandResponse[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApplicationCommandResponse[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ApplicationCommandResponse[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApplicationCommandResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation bulkSetApplicationCommandsAsync
     *
     * @param  string $application_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandUpdateRequest[] $application_command_update_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkSetApplicationCommands'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function bulkSetApplicationCommandsAsync(
        string $application_id,
        array $application_command_update_request,
        string $contentType = self::contentTypes['bulkSetApplicationCommands'][0]
    ): PromiseInterface
    {
        return $this->bulkSetApplicationCommandsAsyncWithHttpInfo($application_id, $application_command_update_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bulkSetApplicationCommandsAsyncWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandUpdateRequest[] $application_command_update_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkSetApplicationCommands'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function bulkSetApplicationCommandsAsyncWithHttpInfo(
        $application_id,
        $application_command_update_request,
        string $contentType = self::contentTypes['bulkSetApplicationCommands'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ApplicationCommandResponse[]';
        $request = $this->bulkSetApplicationCommandsRequest($application_id, $application_command_update_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bulkSetApplicationCommands'
     *
     * @param  string $application_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandUpdateRequest[] $application_command_update_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkSetApplicationCommands'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function bulkSetApplicationCommandsRequest(
        $application_id,
        $application_command_update_request,
        string $contentType = self::contentTypes['bulkSetApplicationCommands'][0]
    ): Request
    {

        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_id when calling bulkSetApplicationCommands'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $application_id)) {
            throw new InvalidArgumentException("invalid value for \"application_id\" when calling DefaultAPI.bulkSetApplicationCommands, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'application_command_update_request' is set
        if ($application_command_update_request === null || (is_array($application_command_update_request) && count($application_command_update_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_command_update_request when calling bulkSetApplicationCommands'
            );
        }


        $resourcePath = '/applications/{application_id}/commands';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'application_id' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($application_command_update_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($application_command_update_request));
            } else {
                $httpBody = $application_command_update_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation bulkSetGuildApplicationCommands
     *
     * @param  string $application_id application_id (required)
     * @param  string $guild_id guild_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandUpdateRequest[] $application_command_update_request application_command_update_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkSetGuildApplicationCommands'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApplicationCommandResponse[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function bulkSetGuildApplicationCommands(
        string $application_id,
        string $guild_id,
        array $application_command_update_request,
        string $contentType = self::contentTypes['bulkSetGuildApplicationCommands'][0]
    ): array
    {
        list($response) = $this->bulkSetGuildApplicationCommandsWithHttpInfo($application_id, $guild_id, $application_command_update_request, $contentType);
        return $response;
    }

    /**
     * Operation bulkSetGuildApplicationCommandsWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandUpdateRequest[] $application_command_update_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkSetGuildApplicationCommands'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApplicationCommandResponse[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function bulkSetGuildApplicationCommandsWithHttpInfo(
        string $application_id,
        string $guild_id,
        array $application_command_update_request,
        string $contentType = self::contentTypes['bulkSetGuildApplicationCommands'][0]
    ): array
    {
        $request = $this->bulkSetGuildApplicationCommandsRequest($application_id, $guild_id, $application_command_update_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ApplicationCommandResponse[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ApplicationCommandResponse[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApplicationCommandResponse[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ApplicationCommandResponse[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApplicationCommandResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation bulkSetGuildApplicationCommandsAsync
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandUpdateRequest[] $application_command_update_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkSetGuildApplicationCommands'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function bulkSetGuildApplicationCommandsAsync(
        string $application_id,
        string $guild_id,
        array $application_command_update_request,
        string $contentType = self::contentTypes['bulkSetGuildApplicationCommands'][0]
    ): PromiseInterface
    {
        return $this->bulkSetGuildApplicationCommandsAsyncWithHttpInfo($application_id, $guild_id, $application_command_update_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bulkSetGuildApplicationCommandsAsyncWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandUpdateRequest[] $application_command_update_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkSetGuildApplicationCommands'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function bulkSetGuildApplicationCommandsAsyncWithHttpInfo(
        $application_id,
        $guild_id,
        $application_command_update_request,
        string $contentType = self::contentTypes['bulkSetGuildApplicationCommands'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ApplicationCommandResponse[]';
        $request = $this->bulkSetGuildApplicationCommandsRequest($application_id, $guild_id, $application_command_update_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bulkSetGuildApplicationCommands'
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandUpdateRequest[] $application_command_update_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkSetGuildApplicationCommands'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function bulkSetGuildApplicationCommandsRequest(
        $application_id,
        $guild_id,
        $application_command_update_request,
        string $contentType = self::contentTypes['bulkSetGuildApplicationCommands'][0]
    ): Request
    {

        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_id when calling bulkSetGuildApplicationCommands'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $application_id)) {
            throw new InvalidArgumentException("invalid value for \"application_id\" when calling DefaultAPI.bulkSetGuildApplicationCommands, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling bulkSetGuildApplicationCommands'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.bulkSetGuildApplicationCommands, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'application_command_update_request' is set
        if ($application_command_update_request === null || (is_array($application_command_update_request) && count($application_command_update_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_command_update_request when calling bulkSetGuildApplicationCommands'
            );
        }


        $resourcePath = '/applications/{application_id}/guilds/{guild_id}/commands';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'application_id' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($application_command_update_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($application_command_update_request));
            } else {
                $httpBody = $application_command_update_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation bulkUpdateGuildChannels
     *
     * @param  string $guild_id guild_id (required)
     * @param  \OpenAPI\Client\Model\BulkUpdateGuildChannelsRequestInner[] $bulk_update_guild_channels_request_inner bulk_update_guild_channels_request_inner (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkUpdateGuildChannels'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function bulkUpdateGuildChannels(
        string $guild_id,
        array $bulk_update_guild_channels_request_inner,
        string $contentType = self::contentTypes['bulkUpdateGuildChannels'][0]
    ): void
    {
        $this->bulkUpdateGuildChannelsWithHttpInfo($guild_id, $bulk_update_guild_channels_request_inner, $contentType);
    }

    /**
     * Operation bulkUpdateGuildChannelsWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\BulkUpdateGuildChannelsRequestInner[] $bulk_update_guild_channels_request_inner (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkUpdateGuildChannels'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function bulkUpdateGuildChannelsWithHttpInfo(
        string $guild_id,
        array $bulk_update_guild_channels_request_inner,
        string $contentType = self::contentTypes['bulkUpdateGuildChannels'][0]
    ): array
    {
        $request = $this->bulkUpdateGuildChannelsRequest($guild_id, $bulk_update_guild_channels_request_inner, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation bulkUpdateGuildChannelsAsync
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\BulkUpdateGuildChannelsRequestInner[] $bulk_update_guild_channels_request_inner (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkUpdateGuildChannels'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function bulkUpdateGuildChannelsAsync(
        string $guild_id,
        array $bulk_update_guild_channels_request_inner,
        string $contentType = self::contentTypes['bulkUpdateGuildChannels'][0]
    ): PromiseInterface
    {
        return $this->bulkUpdateGuildChannelsAsyncWithHttpInfo($guild_id, $bulk_update_guild_channels_request_inner, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bulkUpdateGuildChannelsAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\BulkUpdateGuildChannelsRequestInner[] $bulk_update_guild_channels_request_inner (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkUpdateGuildChannels'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function bulkUpdateGuildChannelsAsyncWithHttpInfo(
        $guild_id,
        $bulk_update_guild_channels_request_inner,
        string $contentType = self::contentTypes['bulkUpdateGuildChannels'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->bulkUpdateGuildChannelsRequest($guild_id, $bulk_update_guild_channels_request_inner, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bulkUpdateGuildChannels'
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\BulkUpdateGuildChannelsRequestInner[] $bulk_update_guild_channels_request_inner (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkUpdateGuildChannels'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function bulkUpdateGuildChannelsRequest(
        $guild_id,
        $bulk_update_guild_channels_request_inner,
        string $contentType = self::contentTypes['bulkUpdateGuildChannels'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling bulkUpdateGuildChannels'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.bulkUpdateGuildChannels, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'bulk_update_guild_channels_request_inner' is set
        if ($bulk_update_guild_channels_request_inner === null || (is_array($bulk_update_guild_channels_request_inner) && count($bulk_update_guild_channels_request_inner) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $bulk_update_guild_channels_request_inner when calling bulkUpdateGuildChannels'
            );
        }


        $resourcePath = '/guilds/{guild_id}/channels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($bulk_update_guild_channels_request_inner)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($bulk_update_guild_channels_request_inner));
            } else {
                $httpBody = $bulk_update_guild_channels_request_inner;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation bulkUpdateGuildRoles
     *
     * @param  string $guild_id guild_id (required)
     * @param  \OpenAPI\Client\Model\BulkUpdateGuildRolesRequestInner[] $bulk_update_guild_roles_request_inner bulk_update_guild_roles_request_inner (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkUpdateGuildRoles'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildRoleResponse[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function bulkUpdateGuildRoles(
        string $guild_id,
        array $bulk_update_guild_roles_request_inner,
        string $contentType = self::contentTypes['bulkUpdateGuildRoles'][0]
    ): array
    {
        list($response) = $this->bulkUpdateGuildRolesWithHttpInfo($guild_id, $bulk_update_guild_roles_request_inner, $contentType);
        return $response;
    }

    /**
     * Operation bulkUpdateGuildRolesWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\BulkUpdateGuildRolesRequestInner[] $bulk_update_guild_roles_request_inner (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkUpdateGuildRoles'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildRoleResponse[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function bulkUpdateGuildRolesWithHttpInfo(
        string $guild_id,
        array $bulk_update_guild_roles_request_inner,
        string $contentType = self::contentTypes['bulkUpdateGuildRoles'][0]
    ): array
    {
        $request = $this->bulkUpdateGuildRolesRequest($guild_id, $bulk_update_guild_roles_request_inner, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildRoleResponse[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildRoleResponse[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildRoleResponse[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildRoleResponse[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildRoleResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation bulkUpdateGuildRolesAsync
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\BulkUpdateGuildRolesRequestInner[] $bulk_update_guild_roles_request_inner (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkUpdateGuildRoles'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function bulkUpdateGuildRolesAsync(
        string $guild_id,
        array $bulk_update_guild_roles_request_inner,
        string $contentType = self::contentTypes['bulkUpdateGuildRoles'][0]
    ): PromiseInterface
    {
        return $this->bulkUpdateGuildRolesAsyncWithHttpInfo($guild_id, $bulk_update_guild_roles_request_inner, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bulkUpdateGuildRolesAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\BulkUpdateGuildRolesRequestInner[] $bulk_update_guild_roles_request_inner (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkUpdateGuildRoles'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function bulkUpdateGuildRolesAsyncWithHttpInfo(
        $guild_id,
        $bulk_update_guild_roles_request_inner,
        string $contentType = self::contentTypes['bulkUpdateGuildRoles'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildRoleResponse[]';
        $request = $this->bulkUpdateGuildRolesRequest($guild_id, $bulk_update_guild_roles_request_inner, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bulkUpdateGuildRoles'
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\BulkUpdateGuildRolesRequestInner[] $bulk_update_guild_roles_request_inner (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkUpdateGuildRoles'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function bulkUpdateGuildRolesRequest(
        $guild_id,
        $bulk_update_guild_roles_request_inner,
        string $contentType = self::contentTypes['bulkUpdateGuildRoles'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling bulkUpdateGuildRoles'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.bulkUpdateGuildRoles, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'bulk_update_guild_roles_request_inner' is set
        if ($bulk_update_guild_roles_request_inner === null || (is_array($bulk_update_guild_roles_request_inner) && count($bulk_update_guild_roles_request_inner) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $bulk_update_guild_roles_request_inner when calling bulkUpdateGuildRoles'
            );
        }


        $resourcePath = '/guilds/{guild_id}/roles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($bulk_update_guild_roles_request_inner)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($bulk_update_guild_roles_request_inner));
            } else {
                $httpBody = $bulk_update_guild_roles_request_inner;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createApplicationCommand
     *
     * @param  string $application_id application_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandCreateRequest $application_command_create_request application_command_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createApplicationCommand'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApplicationCommandResponse|\OpenAPI\Client\Model\ApplicationCommandResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function createApplicationCommand(
        string $application_id,
        \OpenAPI\Client\Model\ApplicationCommandCreateRequest $application_command_create_request,
        string $contentType = self::contentTypes['createApplicationCommand'][0]
    ): \OpenAPI\Client\Model\ApplicationCommandResponse
    {
        list($response) = $this->createApplicationCommandWithHttpInfo($application_id, $application_command_create_request, $contentType);
        return $response;
    }

    /**
     * Operation createApplicationCommandWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandCreateRequest $application_command_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createApplicationCommand'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApplicationCommandResponse|\OpenAPI\Client\Model\ApplicationCommandResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createApplicationCommandWithHttpInfo(
        string $application_id,
        \OpenAPI\Client\Model\ApplicationCommandCreateRequest $application_command_create_request,
        string $contentType = self::contentTypes['createApplicationCommand'][0]
    ): array
    {
        $request = $this->createApplicationCommandRequest($application_id, $application_command_create_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ApplicationCommandResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ApplicationCommandResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApplicationCommandResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 201:
                    if ('\OpenAPI\Client\Model\ApplicationCommandResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ApplicationCommandResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApplicationCommandResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ApplicationCommandResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApplicationCommandResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApplicationCommandResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation createApplicationCommandAsync
     *
     * @param  string $application_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandCreateRequest $application_command_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createApplicationCommand'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createApplicationCommandAsync(
        string $application_id,
        \OpenAPI\Client\Model\ApplicationCommandCreateRequest $application_command_create_request,
        string $contentType = self::contentTypes['createApplicationCommand'][0]
    ): PromiseInterface
    {
        return $this->createApplicationCommandAsyncWithHttpInfo($application_id, $application_command_create_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createApplicationCommandAsyncWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandCreateRequest $application_command_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createApplicationCommand'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createApplicationCommandAsyncWithHttpInfo(
        $application_id,
        $application_command_create_request,
        string $contentType = self::contentTypes['createApplicationCommand'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ApplicationCommandResponse';
        $request = $this->createApplicationCommandRequest($application_id, $application_command_create_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createApplicationCommand'
     *
     * @param  string $application_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandCreateRequest $application_command_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createApplicationCommand'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createApplicationCommandRequest(
        $application_id,
        $application_command_create_request,
        string $contentType = self::contentTypes['createApplicationCommand'][0]
    ): Request
    {

        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_id when calling createApplicationCommand'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $application_id)) {
            throw new InvalidArgumentException("invalid value for \"application_id\" when calling DefaultAPI.createApplicationCommand, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'application_command_create_request' is set
        if ($application_command_create_request === null || (is_array($application_command_create_request) && count($application_command_create_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_command_create_request when calling createApplicationCommand'
            );
        }


        $resourcePath = '/applications/{application_id}/commands';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'application_id' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($application_command_create_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($application_command_create_request));
            } else {
                $httpBody = $application_command_create_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAutoModerationRule
     *
     * @param  string $guild_id guild_id (required)
     * @param  \OpenAPI\Client\Model\CreateAutoModerationRuleRequest $create_auto_moderation_rule_request create_auto_moderation_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAutoModerationRule'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetAutoModerationRule200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function createAutoModerationRule(
        string $guild_id,
        \OpenAPI\Client\Model\CreateAutoModerationRuleRequest $create_auto_moderation_rule_request,
        string $contentType = self::contentTypes['createAutoModerationRule'][0]
    ): \OpenAPI\Client\Model\GetAutoModerationRule200Response
    {
        list($response) = $this->createAutoModerationRuleWithHttpInfo($guild_id, $create_auto_moderation_rule_request, $contentType);
        return $response;
    }

    /**
     * Operation createAutoModerationRuleWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\CreateAutoModerationRuleRequest $create_auto_moderation_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAutoModerationRule'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetAutoModerationRule200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAutoModerationRuleWithHttpInfo(
        string $guild_id,
        \OpenAPI\Client\Model\CreateAutoModerationRuleRequest $create_auto_moderation_rule_request,
        string $contentType = self::contentTypes['createAutoModerationRule'][0]
    ): array
    {
        $request = $this->createAutoModerationRuleRequest($guild_id, $create_auto_moderation_rule_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetAutoModerationRule200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetAutoModerationRule200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetAutoModerationRule200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GetAutoModerationRule200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetAutoModerationRule200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation createAutoModerationRuleAsync
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\CreateAutoModerationRuleRequest $create_auto_moderation_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAutoModerationRule'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createAutoModerationRuleAsync(
        string $guild_id,
        \OpenAPI\Client\Model\CreateAutoModerationRuleRequest $create_auto_moderation_rule_request,
        string $contentType = self::contentTypes['createAutoModerationRule'][0]
    ): PromiseInterface
    {
        return $this->createAutoModerationRuleAsyncWithHttpInfo($guild_id, $create_auto_moderation_rule_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAutoModerationRuleAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\CreateAutoModerationRuleRequest $create_auto_moderation_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAutoModerationRule'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createAutoModerationRuleAsyncWithHttpInfo(
        $guild_id,
        $create_auto_moderation_rule_request,
        string $contentType = self::contentTypes['createAutoModerationRule'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GetAutoModerationRule200Response';
        $request = $this->createAutoModerationRuleRequest($guild_id, $create_auto_moderation_rule_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAutoModerationRule'
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\CreateAutoModerationRuleRequest $create_auto_moderation_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAutoModerationRule'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAutoModerationRuleRequest(
        $guild_id,
        $create_auto_moderation_rule_request,
        string $contentType = self::contentTypes['createAutoModerationRule'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling createAutoModerationRule'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.createAutoModerationRule, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'create_auto_moderation_rule_request' is set
        if ($create_auto_moderation_rule_request === null || (is_array($create_auto_moderation_rule_request) && count($create_auto_moderation_rule_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $create_auto_moderation_rule_request when calling createAutoModerationRule'
            );
        }


        $resourcePath = '/guilds/{guild_id}/auto-moderation/rules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_auto_moderation_rule_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_auto_moderation_rule_request));
            } else {
                $httpBody = $create_auto_moderation_rule_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createChannelInvite
     *
     * @param  string $channel_id channel_id (required)
     * @param  \OpenAPI\Client\Model\CreateChannelInviteRequest $create_channel_invite_request create_channel_invite_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createChannelInvite'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListChannelInvites200ResponseInner|\OpenAPI\Client\Model\ErrorResponse
     */
    public function createChannelInvite(
        string $channel_id,
        \OpenAPI\Client\Model\CreateChannelInviteRequest $create_channel_invite_request,
        string $contentType = self::contentTypes['createChannelInvite'][0]
    ): \OpenAPI\Client\Model\ListChannelInvites200ResponseInner
    {
        list($response) = $this->createChannelInviteWithHttpInfo($channel_id, $create_channel_invite_request, $contentType);
        return $response;
    }

    /**
     * Operation createChannelInviteWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\CreateChannelInviteRequest $create_channel_invite_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createChannelInvite'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListChannelInvites200ResponseInner|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createChannelInviteWithHttpInfo(
        string $channel_id,
        \OpenAPI\Client\Model\CreateChannelInviteRequest $create_channel_invite_request,
        string $contentType = self::contentTypes['createChannelInvite'][0]
    ): array
    {
        $request = $this->createChannelInviteRequest($channel_id, $create_channel_invite_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListChannelInvites200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListChannelInvites200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListChannelInvites200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ListChannelInvites200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListChannelInvites200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation createChannelInviteAsync
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\CreateChannelInviteRequest $create_channel_invite_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createChannelInvite'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createChannelInviteAsync(
        string $channel_id,
        \OpenAPI\Client\Model\CreateChannelInviteRequest $create_channel_invite_request,
        string $contentType = self::contentTypes['createChannelInvite'][0]
    ): PromiseInterface
    {
        return $this->createChannelInviteAsyncWithHttpInfo($channel_id, $create_channel_invite_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createChannelInviteAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\CreateChannelInviteRequest $create_channel_invite_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createChannelInvite'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createChannelInviteAsyncWithHttpInfo(
        $channel_id,
        $create_channel_invite_request,
        string $contentType = self::contentTypes['createChannelInvite'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ListChannelInvites200ResponseInner';
        $request = $this->createChannelInviteRequest($channel_id, $create_channel_invite_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createChannelInvite'
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\CreateChannelInviteRequest $create_channel_invite_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createChannelInvite'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createChannelInviteRequest(
        $channel_id,
        $create_channel_invite_request,
        string $contentType = self::contentTypes['createChannelInvite'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling createChannelInvite'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.createChannelInvite, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'create_channel_invite_request' is set
        if ($create_channel_invite_request === null || (is_array($create_channel_invite_request) && count($create_channel_invite_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $create_channel_invite_request when calling createChannelInvite'
            );
        }


        $resourcePath = '/channels/{channel_id}/invites';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_channel_invite_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_channel_invite_request));
            } else {
                $httpBody = $create_channel_invite_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDm
     *
     * @param  \OpenAPI\Client\Model\CreatePrivateChannelRequest $create_private_channel_request create_private_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDm'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\CreateDm200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function createDm(
        \OpenAPI\Client\Model\CreatePrivateChannelRequest $create_private_channel_request,
        string $contentType = self::contentTypes['createDm'][0]
    ): \OpenAPI\Client\Model\CreateDm200Response
    {
        list($response) = $this->createDmWithHttpInfo($create_private_channel_request, $contentType);
        return $response;
    }

    /**
     * Operation createDmWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CreatePrivateChannelRequest $create_private_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDm'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CreateDm200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDmWithHttpInfo(
        \OpenAPI\Client\Model\CreatePrivateChannelRequest $create_private_channel_request,
        string $contentType = self::contentTypes['createDm'][0]
    ): array
    {
        $request = $this->createDmRequest($create_private_channel_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CreateDm200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CreateDm200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CreateDm200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\CreateDm200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CreateDm200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation createDmAsync
     *
     * @param  \OpenAPI\Client\Model\CreatePrivateChannelRequest $create_private_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDm'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createDmAsync(
        \OpenAPI\Client\Model\CreatePrivateChannelRequest $create_private_channel_request,
        string $contentType = self::contentTypes['createDm'][0]
    ): PromiseInterface
    {
        return $this->createDmAsyncWithHttpInfo($create_private_channel_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDmAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CreatePrivateChannelRequest $create_private_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDm'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createDmAsyncWithHttpInfo(
        $create_private_channel_request,
        string $contentType = self::contentTypes['createDm'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\CreateDm200Response';
        $request = $this->createDmRequest($create_private_channel_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDm'
     *
     * @param  \OpenAPI\Client\Model\CreatePrivateChannelRequest $create_private_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDm'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDmRequest(
        $create_private_channel_request,
        string $contentType = self::contentTypes['createDm'][0]
    ): Request
    {

        // verify the required parameter 'create_private_channel_request' is set
        if ($create_private_channel_request === null || (is_array($create_private_channel_request) && count($create_private_channel_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $create_private_channel_request when calling createDm'
            );
        }


        $resourcePath = '/users/@me/channels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_private_channel_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_private_channel_request));
            } else {
                $httpBody = $create_private_channel_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createGuild
     *
     * @param  \OpenAPI\Client\Model\GuildCreateRequest $guild_create_request guild_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuild'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function createGuild(
        \OpenAPI\Client\Model\GuildCreateRequest $guild_create_request,
        string $contentType = self::contentTypes['createGuild'][0]
    ): \OpenAPI\Client\Model\GuildResponse
    {
        list($response) = $this->createGuildWithHttpInfo($guild_create_request, $contentType);
        return $response;
    }

    /**
     * Operation createGuildWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\GuildCreateRequest $guild_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuild'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createGuildWithHttpInfo(
        \OpenAPI\Client\Model\GuildCreateRequest $guild_create_request,
        string $contentType = self::contentTypes['createGuild'][0]
    ): array
    {
        $request = $this->createGuildRequest($guild_create_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\GuildResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation createGuildAsync
     *
     * @param  \OpenAPI\Client\Model\GuildCreateRequest $guild_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuild'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createGuildAsync(
        \OpenAPI\Client\Model\GuildCreateRequest $guild_create_request,
        string $contentType = self::contentTypes['createGuild'][0]
    ): PromiseInterface
    {
        return $this->createGuildAsyncWithHttpInfo($guild_create_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createGuildAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\GuildCreateRequest $guild_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuild'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createGuildAsyncWithHttpInfo(
        $guild_create_request,
        string $contentType = self::contentTypes['createGuild'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildResponse';
        $request = $this->createGuildRequest($guild_create_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createGuild'
     *
     * @param  \OpenAPI\Client\Model\GuildCreateRequest $guild_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuild'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createGuildRequest(
        $guild_create_request,
        string $contentType = self::contentTypes['createGuild'][0]
    ): Request
    {

        // verify the required parameter 'guild_create_request' is set
        if ($guild_create_request === null || (is_array($guild_create_request) && count($guild_create_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_create_request when calling createGuild'
            );
        }


        $resourcePath = '/guilds';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($guild_create_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($guild_create_request));
            } else {
                $httpBody = $guild_create_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createGuildApplicationCommand
     *
     * @param  string $application_id application_id (required)
     * @param  string $guild_id guild_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandCreateRequest $application_command_create_request application_command_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildApplicationCommand'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApplicationCommandResponse|\OpenAPI\Client\Model\ApplicationCommandResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function createGuildApplicationCommand(
        string $application_id,
        string $guild_id,
        \OpenAPI\Client\Model\ApplicationCommandCreateRequest $application_command_create_request,
        string $contentType = self::contentTypes['createGuildApplicationCommand'][0]
    ): \OpenAPI\Client\Model\ApplicationCommandResponse
    {
        list($response) = $this->createGuildApplicationCommandWithHttpInfo($application_id, $guild_id, $application_command_create_request, $contentType);
        return $response;
    }

    /**
     * Operation createGuildApplicationCommandWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandCreateRequest $application_command_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildApplicationCommand'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApplicationCommandResponse|\OpenAPI\Client\Model\ApplicationCommandResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createGuildApplicationCommandWithHttpInfo(
        string $application_id,
        string $guild_id,
        \OpenAPI\Client\Model\ApplicationCommandCreateRequest $application_command_create_request,
        string $contentType = self::contentTypes['createGuildApplicationCommand'][0]
    ): array
    {
        $request = $this->createGuildApplicationCommandRequest($application_id, $guild_id, $application_command_create_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ApplicationCommandResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ApplicationCommandResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApplicationCommandResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 201:
                    if ('\OpenAPI\Client\Model\ApplicationCommandResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ApplicationCommandResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApplicationCommandResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ApplicationCommandResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApplicationCommandResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApplicationCommandResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation createGuildApplicationCommandAsync
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandCreateRequest $application_command_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildApplicationCommand'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createGuildApplicationCommandAsync(
        string $application_id,
        string $guild_id,
        \OpenAPI\Client\Model\ApplicationCommandCreateRequest $application_command_create_request,
        string $contentType = self::contentTypes['createGuildApplicationCommand'][0]
    ): PromiseInterface
    {
        return $this->createGuildApplicationCommandAsyncWithHttpInfo($application_id, $guild_id, $application_command_create_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createGuildApplicationCommandAsyncWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandCreateRequest $application_command_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildApplicationCommand'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createGuildApplicationCommandAsyncWithHttpInfo(
        $application_id,
        $guild_id,
        $application_command_create_request,
        string $contentType = self::contentTypes['createGuildApplicationCommand'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ApplicationCommandResponse';
        $request = $this->createGuildApplicationCommandRequest($application_id, $guild_id, $application_command_create_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createGuildApplicationCommand'
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandCreateRequest $application_command_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildApplicationCommand'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createGuildApplicationCommandRequest(
        $application_id,
        $guild_id,
        $application_command_create_request,
        string $contentType = self::contentTypes['createGuildApplicationCommand'][0]
    ): Request
    {

        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_id when calling createGuildApplicationCommand'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $application_id)) {
            throw new InvalidArgumentException("invalid value for \"application_id\" when calling DefaultAPI.createGuildApplicationCommand, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling createGuildApplicationCommand'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.createGuildApplicationCommand, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'application_command_create_request' is set
        if ($application_command_create_request === null || (is_array($application_command_create_request) && count($application_command_create_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_command_create_request when calling createGuildApplicationCommand'
            );
        }


        $resourcePath = '/applications/{application_id}/guilds/{guild_id}/commands';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'application_id' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($application_command_create_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($application_command_create_request));
            } else {
                $httpBody = $application_command_create_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createGuildChannel
     *
     * @param  string $guild_id guild_id (required)
     * @param  \OpenAPI\Client\Model\CreateGuildChannelRequest $create_guild_channel_request create_guild_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildChannel'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildChannelResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function createGuildChannel(
        string $guild_id,
        \OpenAPI\Client\Model\CreateGuildChannelRequest $create_guild_channel_request,
        string $contentType = self::contentTypes['createGuildChannel'][0]
    ): \OpenAPI\Client\Model\GuildChannelResponse
    {
        list($response) = $this->createGuildChannelWithHttpInfo($guild_id, $create_guild_channel_request, $contentType);
        return $response;
    }

    /**
     * Operation createGuildChannelWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\CreateGuildChannelRequest $create_guild_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildChannel'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildChannelResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createGuildChannelWithHttpInfo(
        string $guild_id,
        \OpenAPI\Client\Model\CreateGuildChannelRequest $create_guild_channel_request,
        string $contentType = self::contentTypes['createGuildChannel'][0]
    ): array
    {
        $request = $this->createGuildChannelRequest($guild_id, $create_guild_channel_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\GuildChannelResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildChannelResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildChannelResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildChannelResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildChannelResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation createGuildChannelAsync
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\CreateGuildChannelRequest $create_guild_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildChannel'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createGuildChannelAsync(
        string $guild_id,
        \OpenAPI\Client\Model\CreateGuildChannelRequest $create_guild_channel_request,
        string $contentType = self::contentTypes['createGuildChannel'][0]
    ): PromiseInterface
    {
        return $this->createGuildChannelAsyncWithHttpInfo($guild_id, $create_guild_channel_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createGuildChannelAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\CreateGuildChannelRequest $create_guild_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildChannel'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createGuildChannelAsyncWithHttpInfo(
        $guild_id,
        $create_guild_channel_request,
        string $contentType = self::contentTypes['createGuildChannel'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildChannelResponse';
        $request = $this->createGuildChannelRequest($guild_id, $create_guild_channel_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createGuildChannel'
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\CreateGuildChannelRequest $create_guild_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildChannel'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createGuildChannelRequest(
        $guild_id,
        $create_guild_channel_request,
        string $contentType = self::contentTypes['createGuildChannel'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling createGuildChannel'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.createGuildChannel, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'create_guild_channel_request' is set
        if ($create_guild_channel_request === null || (is_array($create_guild_channel_request) && count($create_guild_channel_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $create_guild_channel_request when calling createGuildChannel'
            );
        }


        $resourcePath = '/guilds/{guild_id}/channels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_guild_channel_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_guild_channel_request));
            } else {
                $httpBody = $create_guild_channel_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createGuildEmoji
     *
     * @param  string $guild_id guild_id (required)
     * @param  \OpenAPI\Client\Model\CreateGuildEmojiRequest $create_guild_emoji_request create_guild_emoji_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildEmoji'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmojiResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function createGuildEmoji(
        string $guild_id,
        \OpenAPI\Client\Model\CreateGuildEmojiRequest $create_guild_emoji_request,
        string $contentType = self::contentTypes['createGuildEmoji'][0]
    ): \OpenAPI\Client\Model\EmojiResponse
    {
        list($response) = $this->createGuildEmojiWithHttpInfo($guild_id, $create_guild_emoji_request, $contentType);
        return $response;
    }

    /**
     * Operation createGuildEmojiWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\CreateGuildEmojiRequest $create_guild_emoji_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildEmoji'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmojiResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createGuildEmojiWithHttpInfo(
        string $guild_id,
        \OpenAPI\Client\Model\CreateGuildEmojiRequest $create_guild_emoji_request,
        string $contentType = self::contentTypes['createGuildEmoji'][0]
    ): array
    {
        $request = $this->createGuildEmojiRequest($guild_id, $create_guild_emoji_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\EmojiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmojiResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmojiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\EmojiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmojiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation createGuildEmojiAsync
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\CreateGuildEmojiRequest $create_guild_emoji_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildEmoji'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createGuildEmojiAsync(
        string $guild_id,
        \OpenAPI\Client\Model\CreateGuildEmojiRequest $create_guild_emoji_request,
        string $contentType = self::contentTypes['createGuildEmoji'][0]
    ): PromiseInterface
    {
        return $this->createGuildEmojiAsyncWithHttpInfo($guild_id, $create_guild_emoji_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createGuildEmojiAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\CreateGuildEmojiRequest $create_guild_emoji_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildEmoji'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createGuildEmojiAsyncWithHttpInfo(
        $guild_id,
        $create_guild_emoji_request,
        string $contentType = self::contentTypes['createGuildEmoji'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\EmojiResponse';
        $request = $this->createGuildEmojiRequest($guild_id, $create_guild_emoji_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createGuildEmoji'
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\CreateGuildEmojiRequest $create_guild_emoji_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildEmoji'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createGuildEmojiRequest(
        $guild_id,
        $create_guild_emoji_request,
        string $contentType = self::contentTypes['createGuildEmoji'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling createGuildEmoji'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.createGuildEmoji, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'create_guild_emoji_request' is set
        if ($create_guild_emoji_request === null || (is_array($create_guild_emoji_request) && count($create_guild_emoji_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $create_guild_emoji_request when calling createGuildEmoji'
            );
        }


        $resourcePath = '/guilds/{guild_id}/emojis';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_guild_emoji_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_guild_emoji_request));
            } else {
                $httpBody = $create_guild_emoji_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createGuildFromTemplate
     *
     * @param  string $code code (required)
     * @param  \OpenAPI\Client\Model\CreateGuildFromTemplateRequest $create_guild_from_template_request create_guild_from_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildFromTemplate'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function createGuildFromTemplate(
        string $code,
        \OpenAPI\Client\Model\CreateGuildFromTemplateRequest $create_guild_from_template_request,
        string $contentType = self::contentTypes['createGuildFromTemplate'][0]
    ): \OpenAPI\Client\Model\GuildResponse
    {
        list($response) = $this->createGuildFromTemplateWithHttpInfo($code, $create_guild_from_template_request, $contentType);
        return $response;
    }

    /**
     * Operation createGuildFromTemplateWithHttpInfo
     *
     * @param  string $code (required)
     * @param  \OpenAPI\Client\Model\CreateGuildFromTemplateRequest $create_guild_from_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildFromTemplate'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createGuildFromTemplateWithHttpInfo(
        string $code,
        \OpenAPI\Client\Model\CreateGuildFromTemplateRequest $create_guild_from_template_request,
        string $contentType = self::contentTypes['createGuildFromTemplate'][0]
    ): array
    {
        $request = $this->createGuildFromTemplateRequest($code, $create_guild_from_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\GuildResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation createGuildFromTemplateAsync
     *
     * @param  string $code (required)
     * @param  \OpenAPI\Client\Model\CreateGuildFromTemplateRequest $create_guild_from_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildFromTemplate'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createGuildFromTemplateAsync(
        string $code,
        \OpenAPI\Client\Model\CreateGuildFromTemplateRequest $create_guild_from_template_request,
        string $contentType = self::contentTypes['createGuildFromTemplate'][0]
    ): PromiseInterface
    {
        return $this->createGuildFromTemplateAsyncWithHttpInfo($code, $create_guild_from_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createGuildFromTemplateAsyncWithHttpInfo
     *
     * @param  string $code (required)
     * @param  \OpenAPI\Client\Model\CreateGuildFromTemplateRequest $create_guild_from_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildFromTemplate'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createGuildFromTemplateAsyncWithHttpInfo(
        $code,
        $create_guild_from_template_request,
        string $contentType = self::contentTypes['createGuildFromTemplate'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildResponse';
        $request = $this->createGuildFromTemplateRequest($code, $create_guild_from_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createGuildFromTemplate'
     *
     * @param  string $code (required)
     * @param  \OpenAPI\Client\Model\CreateGuildFromTemplateRequest $create_guild_from_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildFromTemplate'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createGuildFromTemplateRequest(
        $code,
        $create_guild_from_template_request,
        string $contentType = self::contentTypes['createGuildFromTemplate'][0]
    ): Request
    {

        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $code when calling createGuildFromTemplate'
            );
        }
        if (strlen($code) > 152133) {
            throw new InvalidArgumentException('invalid length for "$code" when calling DefaultAPI.createGuildFromTemplate, must be smaller than or equal to 152133.');
        }
        
        // verify the required parameter 'create_guild_from_template_request' is set
        if ($create_guild_from_template_request === null || (is_array($create_guild_from_template_request) && count($create_guild_from_template_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $create_guild_from_template_request when calling createGuildFromTemplate'
            );
        }


        $resourcePath = '/guilds/templates/{code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_guild_from_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_guild_from_template_request));
            } else {
                $httpBody = $create_guild_from_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createGuildRole
     *
     * @param  string $guild_id guild_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildRoleRequest $update_guild_role_request update_guild_role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildRole'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildRoleResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function createGuildRole(
        string $guild_id,
        \OpenAPI\Client\Model\UpdateGuildRoleRequest $update_guild_role_request,
        string $contentType = self::contentTypes['createGuildRole'][0]
    ): \OpenAPI\Client\Model\GuildRoleResponse
    {
        list($response) = $this->createGuildRoleWithHttpInfo($guild_id, $update_guild_role_request, $contentType);
        return $response;
    }

    /**
     * Operation createGuildRoleWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildRoleRequest $update_guild_role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildRole'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildRoleResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createGuildRoleWithHttpInfo(
        string $guild_id,
        \OpenAPI\Client\Model\UpdateGuildRoleRequest $update_guild_role_request,
        string $contentType = self::contentTypes['createGuildRole'][0]
    ): array
    {
        $request = $this->createGuildRoleRequest($guild_id, $update_guild_role_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildRoleResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildRoleResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildRoleResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildRoleResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildRoleResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation createGuildRoleAsync
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildRoleRequest $update_guild_role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildRole'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createGuildRoleAsync(
        string $guild_id,
        \OpenAPI\Client\Model\UpdateGuildRoleRequest $update_guild_role_request,
        string $contentType = self::contentTypes['createGuildRole'][0]
    ): PromiseInterface
    {
        return $this->createGuildRoleAsyncWithHttpInfo($guild_id, $update_guild_role_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createGuildRoleAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildRoleRequest $update_guild_role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildRole'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createGuildRoleAsyncWithHttpInfo(
        $guild_id,
        $update_guild_role_request,
        string $contentType = self::contentTypes['createGuildRole'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildRoleResponse';
        $request = $this->createGuildRoleRequest($guild_id, $update_guild_role_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createGuildRole'
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildRoleRequest $update_guild_role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildRole'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createGuildRoleRequest(
        $guild_id,
        $update_guild_role_request,
        string $contentType = self::contentTypes['createGuildRole'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling createGuildRole'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.createGuildRole, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'update_guild_role_request' is set
        if ($update_guild_role_request === null || (is_array($update_guild_role_request) && count($update_guild_role_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $update_guild_role_request when calling createGuildRole'
            );
        }


        $resourcePath = '/guilds/{guild_id}/roles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_guild_role_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_guild_role_request));
            } else {
                $httpBody = $update_guild_role_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createGuildScheduledEvent
     *
     * @param  string $guild_id guild_id (required)
     * @param  \OpenAPI\Client\Model\CreateGuildScheduledEventRequest $create_guild_scheduled_event_request create_guild_scheduled_event_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildScheduledEvent'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetGuildScheduledEvent200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function createGuildScheduledEvent(
        string $guild_id,
        \OpenAPI\Client\Model\CreateGuildScheduledEventRequest $create_guild_scheduled_event_request,
        string $contentType = self::contentTypes['createGuildScheduledEvent'][0]
    ): \OpenAPI\Client\Model\GetGuildScheduledEvent200Response
    {
        list($response) = $this->createGuildScheduledEventWithHttpInfo($guild_id, $create_guild_scheduled_event_request, $contentType);
        return $response;
    }

    /**
     * Operation createGuildScheduledEventWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\CreateGuildScheduledEventRequest $create_guild_scheduled_event_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildScheduledEvent'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetGuildScheduledEvent200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createGuildScheduledEventWithHttpInfo(
        string $guild_id,
        \OpenAPI\Client\Model\CreateGuildScheduledEventRequest $create_guild_scheduled_event_request,
        string $contentType = self::contentTypes['createGuildScheduledEvent'][0]
    ): array
    {
        $request = $this->createGuildScheduledEventRequest($guild_id, $create_guild_scheduled_event_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetGuildScheduledEvent200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetGuildScheduledEvent200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetGuildScheduledEvent200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GetGuildScheduledEvent200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetGuildScheduledEvent200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation createGuildScheduledEventAsync
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\CreateGuildScheduledEventRequest $create_guild_scheduled_event_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildScheduledEvent'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createGuildScheduledEventAsync(
        string $guild_id,
        \OpenAPI\Client\Model\CreateGuildScheduledEventRequest $create_guild_scheduled_event_request,
        string $contentType = self::contentTypes['createGuildScheduledEvent'][0]
    ): PromiseInterface
    {
        return $this->createGuildScheduledEventAsyncWithHttpInfo($guild_id, $create_guild_scheduled_event_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createGuildScheduledEventAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\CreateGuildScheduledEventRequest $create_guild_scheduled_event_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildScheduledEvent'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createGuildScheduledEventAsyncWithHttpInfo(
        $guild_id,
        $create_guild_scheduled_event_request,
        string $contentType = self::contentTypes['createGuildScheduledEvent'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GetGuildScheduledEvent200Response';
        $request = $this->createGuildScheduledEventRequest($guild_id, $create_guild_scheduled_event_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createGuildScheduledEvent'
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\CreateGuildScheduledEventRequest $create_guild_scheduled_event_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildScheduledEvent'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createGuildScheduledEventRequest(
        $guild_id,
        $create_guild_scheduled_event_request,
        string $contentType = self::contentTypes['createGuildScheduledEvent'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling createGuildScheduledEvent'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.createGuildScheduledEvent, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'create_guild_scheduled_event_request' is set
        if ($create_guild_scheduled_event_request === null || (is_array($create_guild_scheduled_event_request) && count($create_guild_scheduled_event_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $create_guild_scheduled_event_request when calling createGuildScheduledEvent'
            );
        }


        $resourcePath = '/guilds/{guild_id}/scheduled-events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_guild_scheduled_event_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_guild_scheduled_event_request));
            } else {
                $httpBody = $create_guild_scheduled_event_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createGuildSticker
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $name name (required)
     * @param  string $tags tags (required)
     * @param  string $file file (required)
     * @param  string|null $description description (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildSticker'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildStickerResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function createGuildSticker(
        string $guild_id,
        string $name,
        string $tags,
        string $file,
        ?string $description = null,
        string $contentType = self::contentTypes['createGuildSticker'][0]
    ): \OpenAPI\Client\Model\GuildStickerResponse
    {
        list($response) = $this->createGuildStickerWithHttpInfo($guild_id, $name, $tags, $file, $description, $contentType);
        return $response;
    }

    /**
     * Operation createGuildStickerWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $name (required)
     * @param  string $tags (required)
     * @param  string $file (required)
     * @param  string|null $description (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildSticker'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildStickerResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createGuildStickerWithHttpInfo(
        string $guild_id,
        string $name,
        string $tags,
        string $file,
        ?string $description = null,
        string $contentType = self::contentTypes['createGuildSticker'][0]
    ): array
    {
        $request = $this->createGuildStickerRequest($guild_id, $name, $tags, $file, $description, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\GuildStickerResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildStickerResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildStickerResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildStickerResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildStickerResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation createGuildStickerAsync
     *
     * @param  string $guild_id (required)
     * @param  string $name (required)
     * @param  string $tags (required)
     * @param  string $file (required)
     * @param  string|null $description (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildSticker'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createGuildStickerAsync(
        string $guild_id,
        string $name,
        string $tags,
        string $file,
        ?string $description = null,
        string $contentType = self::contentTypes['createGuildSticker'][0]
    ): PromiseInterface
    {
        return $this->createGuildStickerAsyncWithHttpInfo($guild_id, $name, $tags, $file, $description, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createGuildStickerAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $name (required)
     * @param  string $tags (required)
     * @param  string $file (required)
     * @param  string|null $description (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildSticker'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createGuildStickerAsyncWithHttpInfo(
        $guild_id,
        $name,
        $tags,
        $file,
        $description = null,
        string $contentType = self::contentTypes['createGuildSticker'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildStickerResponse';
        $request = $this->createGuildStickerRequest($guild_id, $name, $tags, $file, $description, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createGuildSticker'
     *
     * @param  string $guild_id (required)
     * @param  string $name (required)
     * @param  string $tags (required)
     * @param  string $file (required)
     * @param  string|null $description (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildSticker'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createGuildStickerRequest(
        $guild_id,
        $name,
        $tags,
        $file,
        $description = null,
        string $contentType = self::contentTypes['createGuildSticker'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling createGuildSticker'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.createGuildSticker, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $name when calling createGuildSticker'
            );
        }
        if (strlen($name) > 30) {
            throw new InvalidArgumentException('invalid length for "$name" when calling DefaultAPI.createGuildSticker, must be smaller than or equal to 30.');
        }
        if (strlen($name) < 2) {
            throw new InvalidArgumentException('invalid length for "$name" when calling DefaultAPI.createGuildSticker, must be bigger than or equal to 2.');
        }
        
        // verify the required parameter 'tags' is set
        if ($tags === null || (is_array($tags) && count($tags) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $tags when calling createGuildSticker'
            );
        }
        if (strlen($tags) > 200) {
            throw new InvalidArgumentException('invalid length for "$tags" when calling DefaultAPI.createGuildSticker, must be smaller than or equal to 200.');
        }
        if (strlen($tags) < 1) {
            throw new InvalidArgumentException('invalid length for "$tags" when calling DefaultAPI.createGuildSticker, must be bigger than or equal to 1.');
        }
        
        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $file when calling createGuildSticker'
            );
        }

        if ($description !== null && strlen($description) > 100) {
            throw new InvalidArgumentException('invalid length for "$description" when calling DefaultAPI.createGuildSticker, must be smaller than or equal to 100.');
        }
        

        $resourcePath = '/guilds/{guild_id}/stickers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }

        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($tags !== null) {
            $formParams['tags'] = ObjectSerializer::toFormValue($tags);
        }
        // form params
        if ($description !== null) {
            $formParams['description'] = ObjectSerializer::toFormValue($description);
        }
        // form params
        if ($file !== null) {
            $formParams['file'] = ObjectSerializer::toFormValue($file);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createGuildTemplate
     *
     * @param  string $guild_id guild_id (required)
     * @param  \OpenAPI\Client\Model\CreateGuildTemplateRequest $create_guild_template_request create_guild_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildTemplate'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildTemplateResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function createGuildTemplate(
        string $guild_id,
        \OpenAPI\Client\Model\CreateGuildTemplateRequest $create_guild_template_request,
        string $contentType = self::contentTypes['createGuildTemplate'][0]
    ): \OpenAPI\Client\Model\GuildTemplateResponse
    {
        list($response) = $this->createGuildTemplateWithHttpInfo($guild_id, $create_guild_template_request, $contentType);
        return $response;
    }

    /**
     * Operation createGuildTemplateWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\CreateGuildTemplateRequest $create_guild_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildTemplate'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildTemplateResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createGuildTemplateWithHttpInfo(
        string $guild_id,
        \OpenAPI\Client\Model\CreateGuildTemplateRequest $create_guild_template_request,
        string $contentType = self::contentTypes['createGuildTemplate'][0]
    ): array
    {
        $request = $this->createGuildTemplateRequest($guild_id, $create_guild_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildTemplateResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildTemplateResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildTemplateResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildTemplateResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildTemplateResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation createGuildTemplateAsync
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\CreateGuildTemplateRequest $create_guild_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildTemplate'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createGuildTemplateAsync(
        string $guild_id,
        \OpenAPI\Client\Model\CreateGuildTemplateRequest $create_guild_template_request,
        string $contentType = self::contentTypes['createGuildTemplate'][0]
    ): PromiseInterface
    {
        return $this->createGuildTemplateAsyncWithHttpInfo($guild_id, $create_guild_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createGuildTemplateAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\CreateGuildTemplateRequest $create_guild_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildTemplate'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createGuildTemplateAsyncWithHttpInfo(
        $guild_id,
        $create_guild_template_request,
        string $contentType = self::contentTypes['createGuildTemplate'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildTemplateResponse';
        $request = $this->createGuildTemplateRequest($guild_id, $create_guild_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createGuildTemplate'
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\CreateGuildTemplateRequest $create_guild_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createGuildTemplate'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createGuildTemplateRequest(
        $guild_id,
        $create_guild_template_request,
        string $contentType = self::contentTypes['createGuildTemplate'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling createGuildTemplate'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.createGuildTemplate, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'create_guild_template_request' is set
        if ($create_guild_template_request === null || (is_array($create_guild_template_request) && count($create_guild_template_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $create_guild_template_request when calling createGuildTemplate'
            );
        }


        $resourcePath = '/guilds/{guild_id}/templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_guild_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_guild_template_request));
            } else {
                $httpBody = $create_guild_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createInteractionResponse
     *
     * @param  string $interaction_id interaction_id (required)
     * @param  string $interaction_token interaction_token (required)
     * @param  \OpenAPI\Client\Model\CreateInteractionResponseRequest $create_interaction_response_request create_interaction_response_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInteractionResponse'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function createInteractionResponse(
        string $interaction_id,
        string $interaction_token,
        \OpenAPI\Client\Model\CreateInteractionResponseRequest $create_interaction_response_request,
        string $contentType = self::contentTypes['createInteractionResponse'][0]
    ): void
    {
        $this->createInteractionResponseWithHttpInfo($interaction_id, $interaction_token, $create_interaction_response_request, $contentType);
    }

    /**
     * Operation createInteractionResponseWithHttpInfo
     *
     * @param  string $interaction_id (required)
     * @param  string $interaction_token (required)
     * @param  \OpenAPI\Client\Model\CreateInteractionResponseRequest $create_interaction_response_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInteractionResponse'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createInteractionResponseWithHttpInfo(
        string $interaction_id,
        string $interaction_token,
        \OpenAPI\Client\Model\CreateInteractionResponseRequest $create_interaction_response_request,
        string $contentType = self::contentTypes['createInteractionResponse'][0]
    ): array
    {
        $request = $this->createInteractionResponseRequest($interaction_id, $interaction_token, $create_interaction_response_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation createInteractionResponseAsync
     *
     * @param  string $interaction_id (required)
     * @param  string $interaction_token (required)
     * @param  \OpenAPI\Client\Model\CreateInteractionResponseRequest $create_interaction_response_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInteractionResponse'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createInteractionResponseAsync(
        string $interaction_id,
        string $interaction_token,
        \OpenAPI\Client\Model\CreateInteractionResponseRequest $create_interaction_response_request,
        string $contentType = self::contentTypes['createInteractionResponse'][0]
    ): PromiseInterface
    {
        return $this->createInteractionResponseAsyncWithHttpInfo($interaction_id, $interaction_token, $create_interaction_response_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createInteractionResponseAsyncWithHttpInfo
     *
     * @param  string $interaction_id (required)
     * @param  string $interaction_token (required)
     * @param  \OpenAPI\Client\Model\CreateInteractionResponseRequest $create_interaction_response_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInteractionResponse'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createInteractionResponseAsyncWithHttpInfo(
        $interaction_id,
        $interaction_token,
        $create_interaction_response_request,
        string $contentType = self::contentTypes['createInteractionResponse'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->createInteractionResponseRequest($interaction_id, $interaction_token, $create_interaction_response_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createInteractionResponse'
     *
     * @param  string $interaction_id (required)
     * @param  string $interaction_token (required)
     * @param  \OpenAPI\Client\Model\CreateInteractionResponseRequest $create_interaction_response_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInteractionResponse'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createInteractionResponseRequest(
        $interaction_id,
        $interaction_token,
        $create_interaction_response_request,
        string $contentType = self::contentTypes['createInteractionResponse'][0]
    ): Request
    {

        // verify the required parameter 'interaction_id' is set
        if ($interaction_id === null || (is_array($interaction_id) && count($interaction_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $interaction_id when calling createInteractionResponse'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $interaction_id)) {
            throw new InvalidArgumentException("invalid value for \"interaction_id\" when calling DefaultAPI.createInteractionResponse, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'interaction_token' is set
        if ($interaction_token === null || (is_array($interaction_token) && count($interaction_token) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $interaction_token when calling createInteractionResponse'
            );
        }
        if (strlen($interaction_token) > 152133) {
            throw new InvalidArgumentException('invalid length for "$interaction_token" when calling DefaultAPI.createInteractionResponse, must be smaller than or equal to 152133.');
        }
        
        // verify the required parameter 'create_interaction_response_request' is set
        if ($create_interaction_response_request === null || (is_array($create_interaction_response_request) && count($create_interaction_response_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $create_interaction_response_request when calling createInteractionResponse'
            );
        }


        $resourcePath = '/interactions/{interaction_id}/{interaction_token}/callback';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($interaction_id !== null) {
            $resourcePath = str_replace(
                '{' . 'interaction_id' . '}',
                ObjectSerializer::toPathValue($interaction_id),
                $resourcePath
            );
        }
        // path params
        if ($interaction_token !== null) {
            $resourcePath = str_replace(
                '{' . 'interaction_token' . '}',
                ObjectSerializer::toPathValue($interaction_token),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_interaction_response_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_interaction_response_request));
            } else {
                $httpBody = $create_interaction_response_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createMessage
     *
     * @param  string $channel_id channel_id (required)
     * @param  \OpenAPI\Client\Model\MessageCreateRequest $message_create_request message_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMessage'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\MessageResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function createMessage(
        string $channel_id,
        \OpenAPI\Client\Model\MessageCreateRequest $message_create_request,
        string $contentType = self::contentTypes['createMessage'][0]
    ): \OpenAPI\Client\Model\MessageResponse
    {
        list($response) = $this->createMessageWithHttpInfo($channel_id, $message_create_request, $contentType);
        return $response;
    }

    /**
     * Operation createMessageWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\MessageCreateRequest $message_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMessage'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MessageResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createMessageWithHttpInfo(
        string $channel_id,
        \OpenAPI\Client\Model\MessageCreateRequest $message_create_request,
        string $contentType = self::contentTypes['createMessage'][0]
    ): array
    {
        $request = $this->createMessageRequest($channel_id, $message_create_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\MessageResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\MessageResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MessageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\MessageResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MessageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation createMessageAsync
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\MessageCreateRequest $message_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createMessageAsync(
        string $channel_id,
        \OpenAPI\Client\Model\MessageCreateRequest $message_create_request,
        string $contentType = self::contentTypes['createMessage'][0]
    ): PromiseInterface
    {
        return $this->createMessageAsyncWithHttpInfo($channel_id, $message_create_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createMessageAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\MessageCreateRequest $message_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createMessageAsyncWithHttpInfo(
        $channel_id,
        $message_create_request,
        string $contentType = self::contentTypes['createMessage'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\MessageResponse';
        $request = $this->createMessageRequest($channel_id, $message_create_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createMessage'
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\MessageCreateRequest $message_create_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createMessageRequest(
        $channel_id,
        $message_create_request,
        string $contentType = self::contentTypes['createMessage'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling createMessage'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.createMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'message_create_request' is set
        if ($message_create_request === null || (is_array($message_create_request) && count($message_create_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $message_create_request when calling createMessage'
            );
        }


        $resourcePath = '/channels/{channel_id}/messages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($message_create_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($message_create_request));
            } else {
                $httpBody = $message_create_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createStageInstance
     *
     * @param  \OpenAPI\Client\Model\CreateStageInstanceRequest $create_stage_instance_request create_stage_instance_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStageInstance'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\StageInstanceResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function createStageInstance(
        \OpenAPI\Client\Model\CreateStageInstanceRequest $create_stage_instance_request,
        string $contentType = self::contentTypes['createStageInstance'][0]
    ): \OpenAPI\Client\Model\StageInstanceResponse
    {
        list($response) = $this->createStageInstanceWithHttpInfo($create_stage_instance_request, $contentType);
        return $response;
    }

    /**
     * Operation createStageInstanceWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CreateStageInstanceRequest $create_stage_instance_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStageInstance'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\StageInstanceResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createStageInstanceWithHttpInfo(
        \OpenAPI\Client\Model\CreateStageInstanceRequest $create_stage_instance_request,
        string $contentType = self::contentTypes['createStageInstance'][0]
    ): array
    {
        $request = $this->createStageInstanceRequest($create_stage_instance_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\StageInstanceResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\StageInstanceResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\StageInstanceResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\StageInstanceResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StageInstanceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation createStageInstanceAsync
     *
     * @param  \OpenAPI\Client\Model\CreateStageInstanceRequest $create_stage_instance_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStageInstance'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createStageInstanceAsync(
        \OpenAPI\Client\Model\CreateStageInstanceRequest $create_stage_instance_request,
        string $contentType = self::contentTypes['createStageInstance'][0]
    ): PromiseInterface
    {
        return $this->createStageInstanceAsyncWithHttpInfo($create_stage_instance_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createStageInstanceAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\CreateStageInstanceRequest $create_stage_instance_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStageInstance'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createStageInstanceAsyncWithHttpInfo(
        $create_stage_instance_request,
        string $contentType = self::contentTypes['createStageInstance'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\StageInstanceResponse';
        $request = $this->createStageInstanceRequest($create_stage_instance_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createStageInstance'
     *
     * @param  \OpenAPI\Client\Model\CreateStageInstanceRequest $create_stage_instance_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStageInstance'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createStageInstanceRequest(
        $create_stage_instance_request,
        string $contentType = self::contentTypes['createStageInstance'][0]
    ): Request
    {

        // verify the required parameter 'create_stage_instance_request' is set
        if ($create_stage_instance_request === null || (is_array($create_stage_instance_request) && count($create_stage_instance_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $create_stage_instance_request when calling createStageInstance'
            );
        }


        $resourcePath = '/stage-instances';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_stage_instance_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_stage_instance_request));
            } else {
                $httpBody = $create_stage_instance_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createThread
     *
     * @param  string $channel_id channel_id (required)
     * @param  \OpenAPI\Client\Model\CreateThreadRequest $create_thread_request create_thread_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createThread'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\CreatedThreadResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function createThread(
        string $channel_id,
        \OpenAPI\Client\Model\CreateThreadRequest $create_thread_request,
        string $contentType = self::contentTypes['createThread'][0]
    ): \OpenAPI\Client\Model\CreatedThreadResponse
    {
        list($response) = $this->createThreadWithHttpInfo($channel_id, $create_thread_request, $contentType);
        return $response;
    }

    /**
     * Operation createThreadWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\CreateThreadRequest $create_thread_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createThread'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CreatedThreadResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createThreadWithHttpInfo(
        string $channel_id,
        \OpenAPI\Client\Model\CreateThreadRequest $create_thread_request,
        string $contentType = self::contentTypes['createThread'][0]
    ): array
    {
        $request = $this->createThreadRequest($channel_id, $create_thread_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\CreatedThreadResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CreatedThreadResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CreatedThreadResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\CreatedThreadResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CreatedThreadResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation createThreadAsync
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\CreateThreadRequest $create_thread_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createThread'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createThreadAsync(
        string $channel_id,
        \OpenAPI\Client\Model\CreateThreadRequest $create_thread_request,
        string $contentType = self::contentTypes['createThread'][0]
    ): PromiseInterface
    {
        return $this->createThreadAsyncWithHttpInfo($channel_id, $create_thread_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createThreadAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\CreateThreadRequest $create_thread_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createThread'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createThreadAsyncWithHttpInfo(
        $channel_id,
        $create_thread_request,
        string $contentType = self::contentTypes['createThread'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\CreatedThreadResponse';
        $request = $this->createThreadRequest($channel_id, $create_thread_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createThread'
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\CreateThreadRequest $create_thread_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createThread'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createThreadRequest(
        $channel_id,
        $create_thread_request,
        string $contentType = self::contentTypes['createThread'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling createThread'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.createThread, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'create_thread_request' is set
        if ($create_thread_request === null || (is_array($create_thread_request) && count($create_thread_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $create_thread_request when calling createThread'
            );
        }


        $resourcePath = '/channels/{channel_id}/threads';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_thread_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_thread_request));
            } else {
                $httpBody = $create_thread_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createThreadFromMessage
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $message_id message_id (required)
     * @param  \OpenAPI\Client\Model\CreateTextThreadWithMessageRequest $create_text_thread_with_message_request create_text_thread_with_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createThreadFromMessage'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ThreadResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function createThreadFromMessage(
        string $channel_id,
        string $message_id,
        \OpenAPI\Client\Model\CreateTextThreadWithMessageRequest $create_text_thread_with_message_request,
        string $contentType = self::contentTypes['createThreadFromMessage'][0]
    ): \OpenAPI\Client\Model\ThreadResponse
    {
        list($response) = $this->createThreadFromMessageWithHttpInfo($channel_id, $message_id, $create_text_thread_with_message_request, $contentType);
        return $response;
    }

    /**
     * Operation createThreadFromMessageWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  \OpenAPI\Client\Model\CreateTextThreadWithMessageRequest $create_text_thread_with_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createThreadFromMessage'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ThreadResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createThreadFromMessageWithHttpInfo(
        string $channel_id,
        string $message_id,
        \OpenAPI\Client\Model\CreateTextThreadWithMessageRequest $create_text_thread_with_message_request,
        string $contentType = self::contentTypes['createThreadFromMessage'][0]
    ): array
    {
        $request = $this->createThreadFromMessageRequest($channel_id, $message_id, $create_text_thread_with_message_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\ThreadResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ThreadResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ThreadResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ThreadResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ThreadResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation createThreadFromMessageAsync
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  \OpenAPI\Client\Model\CreateTextThreadWithMessageRequest $create_text_thread_with_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createThreadFromMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createThreadFromMessageAsync(
        string $channel_id,
        string $message_id,
        \OpenAPI\Client\Model\CreateTextThreadWithMessageRequest $create_text_thread_with_message_request,
        string $contentType = self::contentTypes['createThreadFromMessage'][0]
    ): PromiseInterface
    {
        return $this->createThreadFromMessageAsyncWithHttpInfo($channel_id, $message_id, $create_text_thread_with_message_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createThreadFromMessageAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  \OpenAPI\Client\Model\CreateTextThreadWithMessageRequest $create_text_thread_with_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createThreadFromMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createThreadFromMessageAsyncWithHttpInfo(
        $channel_id,
        $message_id,
        $create_text_thread_with_message_request,
        string $contentType = self::contentTypes['createThreadFromMessage'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ThreadResponse';
        $request = $this->createThreadFromMessageRequest($channel_id, $message_id, $create_text_thread_with_message_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createThreadFromMessage'
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  \OpenAPI\Client\Model\CreateTextThreadWithMessageRequest $create_text_thread_with_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createThreadFromMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createThreadFromMessageRequest(
        $channel_id,
        $message_id,
        $create_text_thread_with_message_request,
        string $contentType = self::contentTypes['createThreadFromMessage'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling createThreadFromMessage'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.createThreadFromMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $message_id when calling createThreadFromMessage'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $message_id)) {
            throw new InvalidArgumentException("invalid value for \"message_id\" when calling DefaultAPI.createThreadFromMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'create_text_thread_with_message_request' is set
        if ($create_text_thread_with_message_request === null || (is_array($create_text_thread_with_message_request) && count($create_text_thread_with_message_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $create_text_thread_with_message_request when calling createThreadFromMessage'
            );
        }


        $resourcePath = '/channels/{channel_id}/messages/{message_id}/threads';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'message_id' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_text_thread_with_message_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_text_thread_with_message_request));
            } else {
                $httpBody = $create_text_thread_with_message_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createWebhook
     *
     * @param  string $channel_id channel_id (required)
     * @param  \OpenAPI\Client\Model\CreateWebhookRequest $create_webhook_request create_webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWebhook'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildIncomingWebhookResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function createWebhook(
        string $channel_id,
        \OpenAPI\Client\Model\CreateWebhookRequest $create_webhook_request,
        string $contentType = self::contentTypes['createWebhook'][0]
    ): \OpenAPI\Client\Model\GuildIncomingWebhookResponse
    {
        list($response) = $this->createWebhookWithHttpInfo($channel_id, $create_webhook_request, $contentType);
        return $response;
    }

    /**
     * Operation createWebhookWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\CreateWebhookRequest $create_webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWebhook'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildIncomingWebhookResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createWebhookWithHttpInfo(
        string $channel_id,
        \OpenAPI\Client\Model\CreateWebhookRequest $create_webhook_request,
        string $contentType = self::contentTypes['createWebhook'][0]
    ): array
    {
        $request = $this->createWebhookRequest($channel_id, $create_webhook_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildIncomingWebhookResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildIncomingWebhookResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildIncomingWebhookResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildIncomingWebhookResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildIncomingWebhookResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation createWebhookAsync
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\CreateWebhookRequest $create_webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWebhook'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createWebhookAsync(
        string $channel_id,
        \OpenAPI\Client\Model\CreateWebhookRequest $create_webhook_request,
        string $contentType = self::contentTypes['createWebhook'][0]
    ): PromiseInterface
    {
        return $this->createWebhookAsyncWithHttpInfo($channel_id, $create_webhook_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createWebhookAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\CreateWebhookRequest $create_webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWebhook'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createWebhookAsyncWithHttpInfo(
        $channel_id,
        $create_webhook_request,
        string $contentType = self::contentTypes['createWebhook'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildIncomingWebhookResponse';
        $request = $this->createWebhookRequest($channel_id, $create_webhook_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createWebhook'
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\CreateWebhookRequest $create_webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWebhook'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createWebhookRequest(
        $channel_id,
        $create_webhook_request,
        string $contentType = self::contentTypes['createWebhook'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling createWebhook'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.createWebhook, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'create_webhook_request' is set
        if ($create_webhook_request === null || (is_array($create_webhook_request) && count($create_webhook_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $create_webhook_request when calling createWebhook'
            );
        }


        $resourcePath = '/channels/{channel_id}/webhooks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_webhook_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_webhook_request));
            } else {
                $httpBody = $create_webhook_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation crosspostMessage
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $message_id message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['crosspostMessage'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\MessageResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function crosspostMessage(
        string $channel_id,
        string $message_id,
        string $contentType = self::contentTypes['crosspostMessage'][0]
    ): \OpenAPI\Client\Model\MessageResponse
    {
        list($response) = $this->crosspostMessageWithHttpInfo($channel_id, $message_id, $contentType);
        return $response;
    }

    /**
     * Operation crosspostMessageWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['crosspostMessage'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MessageResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function crosspostMessageWithHttpInfo(
        string $channel_id,
        string $message_id,
        string $contentType = self::contentTypes['crosspostMessage'][0]
    ): array
    {
        $request = $this->crosspostMessageRequest($channel_id, $message_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\MessageResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\MessageResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MessageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\MessageResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MessageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation crosspostMessageAsync
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['crosspostMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function crosspostMessageAsync(
        string $channel_id,
        string $message_id,
        string $contentType = self::contentTypes['crosspostMessage'][0]
    ): PromiseInterface
    {
        return $this->crosspostMessageAsyncWithHttpInfo($channel_id, $message_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation crosspostMessageAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['crosspostMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function crosspostMessageAsyncWithHttpInfo(
        $channel_id,
        $message_id,
        string $contentType = self::contentTypes['crosspostMessage'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\MessageResponse';
        $request = $this->crosspostMessageRequest($channel_id, $message_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'crosspostMessage'
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['crosspostMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function crosspostMessageRequest(
        $channel_id,
        $message_id,
        string $contentType = self::contentTypes['crosspostMessage'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling crosspostMessage'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.crosspostMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $message_id when calling crosspostMessage'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $message_id)) {
            throw new InvalidArgumentException("invalid value for \"message_id\" when calling DefaultAPI.crosspostMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/channels/{channel_id}/messages/{message_id}/crosspost';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'message_id' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAllMessageReactions
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $message_id message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllMessageReactions'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteAllMessageReactions(
        string $channel_id,
        string $message_id,
        string $contentType = self::contentTypes['deleteAllMessageReactions'][0]
    ): void
    {
        $this->deleteAllMessageReactionsWithHttpInfo($channel_id, $message_id, $contentType);
    }

    /**
     * Operation deleteAllMessageReactionsWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllMessageReactions'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAllMessageReactionsWithHttpInfo(
        string $channel_id,
        string $message_id,
        string $contentType = self::contentTypes['deleteAllMessageReactions'][0]
    ): array
    {
        $request = $this->deleteAllMessageReactionsRequest($channel_id, $message_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAllMessageReactionsAsync
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllMessageReactions'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteAllMessageReactionsAsync(
        string $channel_id,
        string $message_id,
        string $contentType = self::contentTypes['deleteAllMessageReactions'][0]
    ): PromiseInterface
    {
        return $this->deleteAllMessageReactionsAsyncWithHttpInfo($channel_id, $message_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAllMessageReactionsAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllMessageReactions'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteAllMessageReactionsAsyncWithHttpInfo(
        $channel_id,
        $message_id,
        string $contentType = self::contentTypes['deleteAllMessageReactions'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteAllMessageReactionsRequest($channel_id, $message_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAllMessageReactions'
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllMessageReactions'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAllMessageReactionsRequest(
        $channel_id,
        $message_id,
        string $contentType = self::contentTypes['deleteAllMessageReactions'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling deleteAllMessageReactions'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.deleteAllMessageReactions, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $message_id when calling deleteAllMessageReactions'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $message_id)) {
            throw new InvalidArgumentException("invalid value for \"message_id\" when calling DefaultAPI.deleteAllMessageReactions, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/channels/{channel_id}/messages/{message_id}/reactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'message_id' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAllMessageReactionsByEmoji
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $message_id message_id (required)
     * @param  mixed $emoji_name emoji_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllMessageReactionsByEmoji'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteAllMessageReactionsByEmoji(
        string $channel_id,
        string $message_id,
        mixed $emoji_name,
        string $contentType = self::contentTypes['deleteAllMessageReactionsByEmoji'][0]
    ): void
    {
        $this->deleteAllMessageReactionsByEmojiWithHttpInfo($channel_id, $message_id, $emoji_name, $contentType);
    }

    /**
     * Operation deleteAllMessageReactionsByEmojiWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  mixed $emoji_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllMessageReactionsByEmoji'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAllMessageReactionsByEmojiWithHttpInfo(
        string $channel_id,
        string $message_id,
        mixed $emoji_name,
        string $contentType = self::contentTypes['deleteAllMessageReactionsByEmoji'][0]
    ): array
    {
        $request = $this->deleteAllMessageReactionsByEmojiRequest($channel_id, $message_id, $emoji_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAllMessageReactionsByEmojiAsync
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  mixed $emoji_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllMessageReactionsByEmoji'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteAllMessageReactionsByEmojiAsync(
        string $channel_id,
        string $message_id,
        mixed $emoji_name,
        string $contentType = self::contentTypes['deleteAllMessageReactionsByEmoji'][0]
    ): PromiseInterface
    {
        return $this->deleteAllMessageReactionsByEmojiAsyncWithHttpInfo($channel_id, $message_id, $emoji_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAllMessageReactionsByEmojiAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  mixed $emoji_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllMessageReactionsByEmoji'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteAllMessageReactionsByEmojiAsyncWithHttpInfo(
        $channel_id,
        $message_id,
        $emoji_name,
        string $contentType = self::contentTypes['deleteAllMessageReactionsByEmoji'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteAllMessageReactionsByEmojiRequest($channel_id, $message_id, $emoji_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAllMessageReactionsByEmoji'
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  mixed $emoji_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllMessageReactionsByEmoji'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAllMessageReactionsByEmojiRequest(
        $channel_id,
        $message_id,
        $emoji_name,
        string $contentType = self::contentTypes['deleteAllMessageReactionsByEmoji'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling deleteAllMessageReactionsByEmoji'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.deleteAllMessageReactionsByEmoji, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $message_id when calling deleteAllMessageReactionsByEmoji'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $message_id)) {
            throw new InvalidArgumentException("invalid value for \"message_id\" when calling DefaultAPI.deleteAllMessageReactionsByEmoji, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'emoji_name' is set
        if ($emoji_name === null || (is_array($emoji_name) && count($emoji_name) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $emoji_name when calling deleteAllMessageReactionsByEmoji'
            );
        }
        if (strlen($emoji_name) > 152133) {
            throw new InvalidArgumentException('invalid length for "$emoji_name" when calling DefaultAPI.deleteAllMessageReactionsByEmoji, must be smaller than or equal to 152133.');
        }
        

        $resourcePath = '/channels/{channel_id}/messages/{message_id}/reactions/{emoji_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'message_id' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }
        // path params
        if ($emoji_name !== null) {
            $resourcePath = str_replace(
                '{' . 'emoji_name' . '}',
                ObjectSerializer::toPathValue($emoji_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteApplicationCommand
     *
     * @param  string $application_id application_id (required)
     * @param  string $command_id command_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteApplicationCommand'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteApplicationCommand(
        string $application_id,
        string $command_id,
        string $contentType = self::contentTypes['deleteApplicationCommand'][0]
    ): void
    {
        $this->deleteApplicationCommandWithHttpInfo($application_id, $command_id, $contentType);
    }

    /**
     * Operation deleteApplicationCommandWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $command_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteApplicationCommand'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteApplicationCommandWithHttpInfo(
        string $application_id,
        string $command_id,
        string $contentType = self::contentTypes['deleteApplicationCommand'][0]
    ): array
    {
        $request = $this->deleteApplicationCommandRequest($application_id, $command_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation deleteApplicationCommandAsync
     *
     * @param  string $application_id (required)
     * @param  string $command_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteApplicationCommand'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteApplicationCommandAsync(
        string $application_id,
        string $command_id,
        string $contentType = self::contentTypes['deleteApplicationCommand'][0]
    ): PromiseInterface
    {
        return $this->deleteApplicationCommandAsyncWithHttpInfo($application_id, $command_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteApplicationCommandAsyncWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $command_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteApplicationCommand'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteApplicationCommandAsyncWithHttpInfo(
        $application_id,
        $command_id,
        string $contentType = self::contentTypes['deleteApplicationCommand'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteApplicationCommandRequest($application_id, $command_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteApplicationCommand'
     *
     * @param  string $application_id (required)
     * @param  string $command_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteApplicationCommand'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteApplicationCommandRequest(
        $application_id,
        $command_id,
        string $contentType = self::contentTypes['deleteApplicationCommand'][0]
    ): Request
    {

        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_id when calling deleteApplicationCommand'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $application_id)) {
            throw new InvalidArgumentException("invalid value for \"application_id\" when calling DefaultAPI.deleteApplicationCommand, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'command_id' is set
        if ($command_id === null || (is_array($command_id) && count($command_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $command_id when calling deleteApplicationCommand'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $command_id)) {
            throw new InvalidArgumentException("invalid value for \"command_id\" when calling DefaultAPI.deleteApplicationCommand, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/applications/{application_id}/commands/{command_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'application_id' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($command_id !== null) {
            $resourcePath = str_replace(
                '{' . 'command_id' . '}',
                ObjectSerializer::toPathValue($command_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAutoModerationRule
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $rule_id rule_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAutoModerationRule'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteAutoModerationRule(
        string $guild_id,
        string $rule_id,
        string $contentType = self::contentTypes['deleteAutoModerationRule'][0]
    ): void
    {
        $this->deleteAutoModerationRuleWithHttpInfo($guild_id, $rule_id, $contentType);
    }

    /**
     * Operation deleteAutoModerationRuleWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $rule_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAutoModerationRule'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAutoModerationRuleWithHttpInfo(
        string $guild_id,
        string $rule_id,
        string $contentType = self::contentTypes['deleteAutoModerationRule'][0]
    ): array
    {
        $request = $this->deleteAutoModerationRuleRequest($guild_id, $rule_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAutoModerationRuleAsync
     *
     * @param  string $guild_id (required)
     * @param  string $rule_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAutoModerationRule'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteAutoModerationRuleAsync(
        string $guild_id,
        string $rule_id,
        string $contentType = self::contentTypes['deleteAutoModerationRule'][0]
    ): PromiseInterface
    {
        return $this->deleteAutoModerationRuleAsyncWithHttpInfo($guild_id, $rule_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAutoModerationRuleAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $rule_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAutoModerationRule'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteAutoModerationRuleAsyncWithHttpInfo(
        $guild_id,
        $rule_id,
        string $contentType = self::contentTypes['deleteAutoModerationRule'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteAutoModerationRuleRequest($guild_id, $rule_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAutoModerationRule'
     *
     * @param  string $guild_id (required)
     * @param  string $rule_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAutoModerationRule'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAutoModerationRuleRequest(
        $guild_id,
        $rule_id,
        string $contentType = self::contentTypes['deleteAutoModerationRule'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling deleteAutoModerationRule'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.deleteAutoModerationRule, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'rule_id' is set
        if ($rule_id === null || (is_array($rule_id) && count($rule_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $rule_id when calling deleteAutoModerationRule'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $rule_id)) {
            throw new InvalidArgumentException("invalid value for \"rule_id\" when calling DefaultAPI.deleteAutoModerationRule, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/auto-moderation/rules/{rule_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($rule_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rule_id' . '}',
                ObjectSerializer::toPathValue($rule_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteChannel
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteChannel'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListGuildChannels200ResponseInner|\OpenAPI\Client\Model\ErrorResponse
     */
    public function deleteChannel(
        string $channel_id,
        string $contentType = self::contentTypes['deleteChannel'][0]
    ): \OpenAPI\Client\Model\ListGuildChannels200ResponseInner
    {
        list($response) = $this->deleteChannelWithHttpInfo($channel_id, $contentType);
        return $response;
    }

    /**
     * Operation deleteChannelWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteChannel'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListGuildChannels200ResponseInner|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteChannelWithHttpInfo(
        string $channel_id,
        string $contentType = self::contentTypes['deleteChannel'][0]
    ): array
    {
        $request = $this->deleteChannelRequest($channel_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListGuildChannels200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListGuildChannels200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListGuildChannels200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ListGuildChannels200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListGuildChannels200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation deleteChannelAsync
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteChannel'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteChannelAsync(
        string $channel_id,
        string $contentType = self::contentTypes['deleteChannel'][0]
    ): PromiseInterface
    {
        return $this->deleteChannelAsyncWithHttpInfo($channel_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteChannelAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteChannel'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteChannelAsyncWithHttpInfo(
        $channel_id,
        string $contentType = self::contentTypes['deleteChannel'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ListGuildChannels200ResponseInner';
        $request = $this->deleteChannelRequest($channel_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteChannel'
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteChannel'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteChannelRequest(
        $channel_id,
        string $contentType = self::contentTypes['deleteChannel'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling deleteChannel'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.deleteChannel, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/channels/{channel_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteChannelPermissionOverwrite
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $overwrite_id overwrite_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteChannelPermissionOverwrite'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteChannelPermissionOverwrite(
        string $channel_id,
        string $overwrite_id,
        string $contentType = self::contentTypes['deleteChannelPermissionOverwrite'][0]
    ): void
    {
        $this->deleteChannelPermissionOverwriteWithHttpInfo($channel_id, $overwrite_id, $contentType);
    }

    /**
     * Operation deleteChannelPermissionOverwriteWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $overwrite_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteChannelPermissionOverwrite'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteChannelPermissionOverwriteWithHttpInfo(
        string $channel_id,
        string $overwrite_id,
        string $contentType = self::contentTypes['deleteChannelPermissionOverwrite'][0]
    ): array
    {
        $request = $this->deleteChannelPermissionOverwriteRequest($channel_id, $overwrite_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation deleteChannelPermissionOverwriteAsync
     *
     * @param  string $channel_id (required)
     * @param  string $overwrite_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteChannelPermissionOverwrite'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteChannelPermissionOverwriteAsync(
        string $channel_id,
        string $overwrite_id,
        string $contentType = self::contentTypes['deleteChannelPermissionOverwrite'][0]
    ): PromiseInterface
    {
        return $this->deleteChannelPermissionOverwriteAsyncWithHttpInfo($channel_id, $overwrite_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteChannelPermissionOverwriteAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $overwrite_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteChannelPermissionOverwrite'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteChannelPermissionOverwriteAsyncWithHttpInfo(
        $channel_id,
        $overwrite_id,
        string $contentType = self::contentTypes['deleteChannelPermissionOverwrite'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteChannelPermissionOverwriteRequest($channel_id, $overwrite_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteChannelPermissionOverwrite'
     *
     * @param  string $channel_id (required)
     * @param  string $overwrite_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteChannelPermissionOverwrite'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteChannelPermissionOverwriteRequest(
        $channel_id,
        $overwrite_id,
        string $contentType = self::contentTypes['deleteChannelPermissionOverwrite'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling deleteChannelPermissionOverwrite'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.deleteChannelPermissionOverwrite, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'overwrite_id' is set
        if ($overwrite_id === null || (is_array($overwrite_id) && count($overwrite_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $overwrite_id when calling deleteChannelPermissionOverwrite'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $overwrite_id)) {
            throw new InvalidArgumentException("invalid value for \"overwrite_id\" when calling DefaultAPI.deleteChannelPermissionOverwrite, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/channels/{channel_id}/permissions/{overwrite_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }
        // path params
        if ($overwrite_id !== null) {
            $resourcePath = str_replace(
                '{' . 'overwrite_id' . '}',
                ObjectSerializer::toPathValue($overwrite_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteGroupDmUser
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $user_id user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGroupDmUser'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteGroupDmUser(
        string $channel_id,
        string $user_id,
        string $contentType = self::contentTypes['deleteGroupDmUser'][0]
    ): void
    {
        $this->deleteGroupDmUserWithHttpInfo($channel_id, $user_id, $contentType);
    }

    /**
     * Operation deleteGroupDmUserWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGroupDmUser'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteGroupDmUserWithHttpInfo(
        string $channel_id,
        string $user_id,
        string $contentType = self::contentTypes['deleteGroupDmUser'][0]
    ): array
    {
        $request = $this->deleteGroupDmUserRequest($channel_id, $user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation deleteGroupDmUserAsync
     *
     * @param  string $channel_id (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGroupDmUser'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteGroupDmUserAsync(
        string $channel_id,
        string $user_id,
        string $contentType = self::contentTypes['deleteGroupDmUser'][0]
    ): PromiseInterface
    {
        return $this->deleteGroupDmUserAsyncWithHttpInfo($channel_id, $user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteGroupDmUserAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGroupDmUser'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteGroupDmUserAsyncWithHttpInfo(
        $channel_id,
        $user_id,
        string $contentType = self::contentTypes['deleteGroupDmUser'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteGroupDmUserRequest($channel_id, $user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteGroupDmUser'
     *
     * @param  string $channel_id (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGroupDmUser'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteGroupDmUserRequest(
        $channel_id,
        $user_id,
        string $contentType = self::contentTypes['deleteGroupDmUser'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling deleteGroupDmUser'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.deleteGroupDmUser, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $user_id when calling deleteGroupDmUser'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $user_id)) {
            throw new InvalidArgumentException("invalid value for \"user_id\" when calling DefaultAPI.deleteGroupDmUser, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/channels/{channel_id}/recipients/{user_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteGuild
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuild'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteGuild(
        string $guild_id,
        string $contentType = self::contentTypes['deleteGuild'][0]
    ): void
    {
        $this->deleteGuildWithHttpInfo($guild_id, $contentType);
    }

    /**
     * Operation deleteGuildWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuild'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteGuildWithHttpInfo(
        string $guild_id,
        string $contentType = self::contentTypes['deleteGuild'][0]
    ): array
    {
        $request = $this->deleteGuildRequest($guild_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation deleteGuildAsync
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuild'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteGuildAsync(
        string $guild_id,
        string $contentType = self::contentTypes['deleteGuild'][0]
    ): PromiseInterface
    {
        return $this->deleteGuildAsyncWithHttpInfo($guild_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteGuildAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuild'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteGuildAsyncWithHttpInfo(
        $guild_id,
        string $contentType = self::contentTypes['deleteGuild'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteGuildRequest($guild_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteGuild'
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuild'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteGuildRequest(
        $guild_id,
        string $contentType = self::contentTypes['deleteGuild'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling deleteGuild'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.deleteGuild, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteGuildApplicationCommand
     *
     * @param  string $application_id application_id (required)
     * @param  string $guild_id guild_id (required)
     * @param  string $command_id command_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildApplicationCommand'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteGuildApplicationCommand(
        string $application_id,
        string $guild_id,
        string $command_id,
        string $contentType = self::contentTypes['deleteGuildApplicationCommand'][0]
    ): void
    {
        $this->deleteGuildApplicationCommandWithHttpInfo($application_id, $guild_id, $command_id, $contentType);
    }

    /**
     * Operation deleteGuildApplicationCommandWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  string $command_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildApplicationCommand'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteGuildApplicationCommandWithHttpInfo(
        string $application_id,
        string $guild_id,
        string $command_id,
        string $contentType = self::contentTypes['deleteGuildApplicationCommand'][0]
    ): array
    {
        $request = $this->deleteGuildApplicationCommandRequest($application_id, $guild_id, $command_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation deleteGuildApplicationCommandAsync
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  string $command_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildApplicationCommand'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteGuildApplicationCommandAsync(
        string $application_id,
        string $guild_id,
        string $command_id,
        string $contentType = self::contentTypes['deleteGuildApplicationCommand'][0]
    ): PromiseInterface
    {
        return $this->deleteGuildApplicationCommandAsyncWithHttpInfo($application_id, $guild_id, $command_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteGuildApplicationCommandAsyncWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  string $command_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildApplicationCommand'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteGuildApplicationCommandAsyncWithHttpInfo(
        $application_id,
        $guild_id,
        $command_id,
        string $contentType = self::contentTypes['deleteGuildApplicationCommand'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteGuildApplicationCommandRequest($application_id, $guild_id, $command_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteGuildApplicationCommand'
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  string $command_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildApplicationCommand'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteGuildApplicationCommandRequest(
        $application_id,
        $guild_id,
        $command_id,
        string $contentType = self::contentTypes['deleteGuildApplicationCommand'][0]
    ): Request
    {

        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_id when calling deleteGuildApplicationCommand'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $application_id)) {
            throw new InvalidArgumentException("invalid value for \"application_id\" when calling DefaultAPI.deleteGuildApplicationCommand, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling deleteGuildApplicationCommand'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.deleteGuildApplicationCommand, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'command_id' is set
        if ($command_id === null || (is_array($command_id) && count($command_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $command_id when calling deleteGuildApplicationCommand'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $command_id)) {
            throw new InvalidArgumentException("invalid value for \"command_id\" when calling DefaultAPI.deleteGuildApplicationCommand, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/applications/{application_id}/guilds/{guild_id}/commands/{command_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'application_id' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($command_id !== null) {
            $resourcePath = str_replace(
                '{' . 'command_id' . '}',
                ObjectSerializer::toPathValue($command_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteGuildEmoji
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $emoji_id emoji_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildEmoji'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteGuildEmoji(
        string $guild_id,
        string $emoji_id,
        string $contentType = self::contentTypes['deleteGuildEmoji'][0]
    ): void
    {
        $this->deleteGuildEmojiWithHttpInfo($guild_id, $emoji_id, $contentType);
    }

    /**
     * Operation deleteGuildEmojiWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $emoji_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildEmoji'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteGuildEmojiWithHttpInfo(
        string $guild_id,
        string $emoji_id,
        string $contentType = self::contentTypes['deleteGuildEmoji'][0]
    ): array
    {
        $request = $this->deleteGuildEmojiRequest($guild_id, $emoji_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation deleteGuildEmojiAsync
     *
     * @param  string $guild_id (required)
     * @param  string $emoji_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildEmoji'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteGuildEmojiAsync(
        string $guild_id,
        string $emoji_id,
        string $contentType = self::contentTypes['deleteGuildEmoji'][0]
    ): PromiseInterface
    {
        return $this->deleteGuildEmojiAsyncWithHttpInfo($guild_id, $emoji_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteGuildEmojiAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $emoji_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildEmoji'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteGuildEmojiAsyncWithHttpInfo(
        $guild_id,
        $emoji_id,
        string $contentType = self::contentTypes['deleteGuildEmoji'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteGuildEmojiRequest($guild_id, $emoji_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteGuildEmoji'
     *
     * @param  string $guild_id (required)
     * @param  string $emoji_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildEmoji'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteGuildEmojiRequest(
        $guild_id,
        $emoji_id,
        string $contentType = self::contentTypes['deleteGuildEmoji'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling deleteGuildEmoji'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.deleteGuildEmoji, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'emoji_id' is set
        if ($emoji_id === null || (is_array($emoji_id) && count($emoji_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $emoji_id when calling deleteGuildEmoji'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $emoji_id)) {
            throw new InvalidArgumentException("invalid value for \"emoji_id\" when calling DefaultAPI.deleteGuildEmoji, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/emojis/{emoji_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($emoji_id !== null) {
            $resourcePath = str_replace(
                '{' . 'emoji_id' . '}',
                ObjectSerializer::toPathValue($emoji_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteGuildIntegration
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $integration_id integration_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildIntegration'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteGuildIntegration(
        string $guild_id,
        string $integration_id,
        string $contentType = self::contentTypes['deleteGuildIntegration'][0]
    ): void
    {
        $this->deleteGuildIntegrationWithHttpInfo($guild_id, $integration_id, $contentType);
    }

    /**
     * Operation deleteGuildIntegrationWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $integration_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildIntegration'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteGuildIntegrationWithHttpInfo(
        string $guild_id,
        string $integration_id,
        string $contentType = self::contentTypes['deleteGuildIntegration'][0]
    ): array
    {
        $request = $this->deleteGuildIntegrationRequest($guild_id, $integration_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation deleteGuildIntegrationAsync
     *
     * @param  string $guild_id (required)
     * @param  string $integration_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildIntegration'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteGuildIntegrationAsync(
        string $guild_id,
        string $integration_id,
        string $contentType = self::contentTypes['deleteGuildIntegration'][0]
    ): PromiseInterface
    {
        return $this->deleteGuildIntegrationAsyncWithHttpInfo($guild_id, $integration_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteGuildIntegrationAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $integration_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildIntegration'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteGuildIntegrationAsyncWithHttpInfo(
        $guild_id,
        $integration_id,
        string $contentType = self::contentTypes['deleteGuildIntegration'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteGuildIntegrationRequest($guild_id, $integration_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteGuildIntegration'
     *
     * @param  string $guild_id (required)
     * @param  string $integration_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildIntegration'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteGuildIntegrationRequest(
        $guild_id,
        $integration_id,
        string $contentType = self::contentTypes['deleteGuildIntegration'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling deleteGuildIntegration'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.deleteGuildIntegration, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'integration_id' is set
        if ($integration_id === null || (is_array($integration_id) && count($integration_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $integration_id when calling deleteGuildIntegration'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $integration_id)) {
            throw new InvalidArgumentException("invalid value for \"integration_id\" when calling DefaultAPI.deleteGuildIntegration, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/integrations/{integration_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($integration_id !== null) {
            $resourcePath = str_replace(
                '{' . 'integration_id' . '}',
                ObjectSerializer::toPathValue($integration_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteGuildMember
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $user_id user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildMember'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteGuildMember(
        string $guild_id,
        string $user_id,
        string $contentType = self::contentTypes['deleteGuildMember'][0]
    ): void
    {
        $this->deleteGuildMemberWithHttpInfo($guild_id, $user_id, $contentType);
    }

    /**
     * Operation deleteGuildMemberWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildMember'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteGuildMemberWithHttpInfo(
        string $guild_id,
        string $user_id,
        string $contentType = self::contentTypes['deleteGuildMember'][0]
    ): array
    {
        $request = $this->deleteGuildMemberRequest($guild_id, $user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation deleteGuildMemberAsync
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildMember'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteGuildMemberAsync(
        string $guild_id,
        string $user_id,
        string $contentType = self::contentTypes['deleteGuildMember'][0]
    ): PromiseInterface
    {
        return $this->deleteGuildMemberAsyncWithHttpInfo($guild_id, $user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteGuildMemberAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildMember'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteGuildMemberAsyncWithHttpInfo(
        $guild_id,
        $user_id,
        string $contentType = self::contentTypes['deleteGuildMember'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteGuildMemberRequest($guild_id, $user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteGuildMember'
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildMember'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteGuildMemberRequest(
        $guild_id,
        $user_id,
        string $contentType = self::contentTypes['deleteGuildMember'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling deleteGuildMember'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.deleteGuildMember, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $user_id when calling deleteGuildMember'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $user_id)) {
            throw new InvalidArgumentException("invalid value for \"user_id\" when calling DefaultAPI.deleteGuildMember, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/members/{user_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteGuildMemberRole
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $user_id user_id (required)
     * @param  string $role_id role_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildMemberRole'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteGuildMemberRole(
        string $guild_id,
        string $user_id,
        string $role_id,
        string $contentType = self::contentTypes['deleteGuildMemberRole'][0]
    ): void
    {
        $this->deleteGuildMemberRoleWithHttpInfo($guild_id, $user_id, $role_id, $contentType);
    }

    /**
     * Operation deleteGuildMemberRoleWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  string $role_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildMemberRole'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteGuildMemberRoleWithHttpInfo(
        string $guild_id,
        string $user_id,
        string $role_id,
        string $contentType = self::contentTypes['deleteGuildMemberRole'][0]
    ): array
    {
        $request = $this->deleteGuildMemberRoleRequest($guild_id, $user_id, $role_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation deleteGuildMemberRoleAsync
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  string $role_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildMemberRole'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteGuildMemberRoleAsync(
        string $guild_id,
        string $user_id,
        string $role_id,
        string $contentType = self::contentTypes['deleteGuildMemberRole'][0]
    ): PromiseInterface
    {
        return $this->deleteGuildMemberRoleAsyncWithHttpInfo($guild_id, $user_id, $role_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteGuildMemberRoleAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  string $role_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildMemberRole'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteGuildMemberRoleAsyncWithHttpInfo(
        $guild_id,
        $user_id,
        $role_id,
        string $contentType = self::contentTypes['deleteGuildMemberRole'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteGuildMemberRoleRequest($guild_id, $user_id, $role_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteGuildMemberRole'
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  string $role_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildMemberRole'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteGuildMemberRoleRequest(
        $guild_id,
        $user_id,
        $role_id,
        string $contentType = self::contentTypes['deleteGuildMemberRole'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling deleteGuildMemberRole'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.deleteGuildMemberRole, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $user_id when calling deleteGuildMemberRole'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $user_id)) {
            throw new InvalidArgumentException("invalid value for \"user_id\" when calling DefaultAPI.deleteGuildMemberRole, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'role_id' is set
        if ($role_id === null || (is_array($role_id) && count($role_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $role_id when calling deleteGuildMemberRole'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $role_id)) {
            throw new InvalidArgumentException("invalid value for \"role_id\" when calling DefaultAPI.deleteGuildMemberRole, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/members/{user_id}/roles/{role_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }
        // path params
        if ($role_id !== null) {
            $resourcePath = str_replace(
                '{' . 'role_id' . '}',
                ObjectSerializer::toPathValue($role_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteGuildRole
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $role_id role_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildRole'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteGuildRole(
        string $guild_id,
        string $role_id,
        string $contentType = self::contentTypes['deleteGuildRole'][0]
    ): void
    {
        $this->deleteGuildRoleWithHttpInfo($guild_id, $role_id, $contentType);
    }

    /**
     * Operation deleteGuildRoleWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $role_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildRole'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteGuildRoleWithHttpInfo(
        string $guild_id,
        string $role_id,
        string $contentType = self::contentTypes['deleteGuildRole'][0]
    ): array
    {
        $request = $this->deleteGuildRoleRequest($guild_id, $role_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation deleteGuildRoleAsync
     *
     * @param  string $guild_id (required)
     * @param  string $role_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildRole'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteGuildRoleAsync(
        string $guild_id,
        string $role_id,
        string $contentType = self::contentTypes['deleteGuildRole'][0]
    ): PromiseInterface
    {
        return $this->deleteGuildRoleAsyncWithHttpInfo($guild_id, $role_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteGuildRoleAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $role_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildRole'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteGuildRoleAsyncWithHttpInfo(
        $guild_id,
        $role_id,
        string $contentType = self::contentTypes['deleteGuildRole'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteGuildRoleRequest($guild_id, $role_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteGuildRole'
     *
     * @param  string $guild_id (required)
     * @param  string $role_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildRole'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteGuildRoleRequest(
        $guild_id,
        $role_id,
        string $contentType = self::contentTypes['deleteGuildRole'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling deleteGuildRole'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.deleteGuildRole, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'role_id' is set
        if ($role_id === null || (is_array($role_id) && count($role_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $role_id when calling deleteGuildRole'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $role_id)) {
            throw new InvalidArgumentException("invalid value for \"role_id\" when calling DefaultAPI.deleteGuildRole, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/roles/{role_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($role_id !== null) {
            $resourcePath = str_replace(
                '{' . 'role_id' . '}',
                ObjectSerializer::toPathValue($role_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteGuildScheduledEvent
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $guild_scheduled_event_id guild_scheduled_event_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildScheduledEvent'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteGuildScheduledEvent(
        string $guild_id,
        string $guild_scheduled_event_id,
        string $contentType = self::contentTypes['deleteGuildScheduledEvent'][0]
    ): void
    {
        $this->deleteGuildScheduledEventWithHttpInfo($guild_id, $guild_scheduled_event_id, $contentType);
    }

    /**
     * Operation deleteGuildScheduledEventWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $guild_scheduled_event_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildScheduledEvent'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteGuildScheduledEventWithHttpInfo(
        string $guild_id,
        string $guild_scheduled_event_id,
        string $contentType = self::contentTypes['deleteGuildScheduledEvent'][0]
    ): array
    {
        $request = $this->deleteGuildScheduledEventRequest($guild_id, $guild_scheduled_event_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation deleteGuildScheduledEventAsync
     *
     * @param  string $guild_id (required)
     * @param  string $guild_scheduled_event_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildScheduledEvent'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteGuildScheduledEventAsync(
        string $guild_id,
        string $guild_scheduled_event_id,
        string $contentType = self::contentTypes['deleteGuildScheduledEvent'][0]
    ): PromiseInterface
    {
        return $this->deleteGuildScheduledEventAsyncWithHttpInfo($guild_id, $guild_scheduled_event_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteGuildScheduledEventAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $guild_scheduled_event_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildScheduledEvent'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteGuildScheduledEventAsyncWithHttpInfo(
        $guild_id,
        $guild_scheduled_event_id,
        string $contentType = self::contentTypes['deleteGuildScheduledEvent'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteGuildScheduledEventRequest($guild_id, $guild_scheduled_event_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteGuildScheduledEvent'
     *
     * @param  string $guild_id (required)
     * @param  string $guild_scheduled_event_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildScheduledEvent'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteGuildScheduledEventRequest(
        $guild_id,
        $guild_scheduled_event_id,
        string $contentType = self::contentTypes['deleteGuildScheduledEvent'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling deleteGuildScheduledEvent'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.deleteGuildScheduledEvent, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'guild_scheduled_event_id' is set
        if ($guild_scheduled_event_id === null || (is_array($guild_scheduled_event_id) && count($guild_scheduled_event_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_scheduled_event_id when calling deleteGuildScheduledEvent'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_scheduled_event_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_scheduled_event_id\" when calling DefaultAPI.deleteGuildScheduledEvent, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/scheduled-events/{guild_scheduled_event_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($guild_scheduled_event_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_scheduled_event_id' . '}',
                ObjectSerializer::toPathValue($guild_scheduled_event_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteGuildSticker
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $sticker_id sticker_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildSticker'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteGuildSticker(
        string $guild_id,
        string $sticker_id,
        string $contentType = self::contentTypes['deleteGuildSticker'][0]
    ): void
    {
        $this->deleteGuildStickerWithHttpInfo($guild_id, $sticker_id, $contentType);
    }

    /**
     * Operation deleteGuildStickerWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $sticker_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildSticker'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteGuildStickerWithHttpInfo(
        string $guild_id,
        string $sticker_id,
        string $contentType = self::contentTypes['deleteGuildSticker'][0]
    ): array
    {
        $request = $this->deleteGuildStickerRequest($guild_id, $sticker_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation deleteGuildStickerAsync
     *
     * @param  string $guild_id (required)
     * @param  string $sticker_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildSticker'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteGuildStickerAsync(
        string $guild_id,
        string $sticker_id,
        string $contentType = self::contentTypes['deleteGuildSticker'][0]
    ): PromiseInterface
    {
        return $this->deleteGuildStickerAsyncWithHttpInfo($guild_id, $sticker_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteGuildStickerAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $sticker_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildSticker'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteGuildStickerAsyncWithHttpInfo(
        $guild_id,
        $sticker_id,
        string $contentType = self::contentTypes['deleteGuildSticker'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteGuildStickerRequest($guild_id, $sticker_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteGuildSticker'
     *
     * @param  string $guild_id (required)
     * @param  string $sticker_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildSticker'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteGuildStickerRequest(
        $guild_id,
        $sticker_id,
        string $contentType = self::contentTypes['deleteGuildSticker'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling deleteGuildSticker'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.deleteGuildSticker, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'sticker_id' is set
        if ($sticker_id === null || (is_array($sticker_id) && count($sticker_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sticker_id when calling deleteGuildSticker'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $sticker_id)) {
            throw new InvalidArgumentException("invalid value for \"sticker_id\" when calling DefaultAPI.deleteGuildSticker, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/stickers/{sticker_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($sticker_id !== null) {
            $resourcePath = str_replace(
                '{' . 'sticker_id' . '}',
                ObjectSerializer::toPathValue($sticker_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteGuildTemplate
     *
     * @param  string $guild_id guild_id (required)
     * @param  mixed $code code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildTemplate'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildTemplateResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function deleteGuildTemplate(
        string $guild_id,
        mixed $code,
        string $contentType = self::contentTypes['deleteGuildTemplate'][0]
    ): \OpenAPI\Client\Model\GuildTemplateResponse
    {
        list($response) = $this->deleteGuildTemplateWithHttpInfo($guild_id, $code, $contentType);
        return $response;
    }

    /**
     * Operation deleteGuildTemplateWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  mixed $code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildTemplate'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildTemplateResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteGuildTemplateWithHttpInfo(
        string $guild_id,
        mixed $code,
        string $contentType = self::contentTypes['deleteGuildTemplate'][0]
    ): array
    {
        $request = $this->deleteGuildTemplateRequest($guild_id, $code, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildTemplateResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildTemplateResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildTemplateResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildTemplateResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildTemplateResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation deleteGuildTemplateAsync
     *
     * @param  string $guild_id (required)
     * @param  mixed $code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildTemplate'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteGuildTemplateAsync(
        string $guild_id,
        mixed $code,
        string $contentType = self::contentTypes['deleteGuildTemplate'][0]
    ): PromiseInterface
    {
        return $this->deleteGuildTemplateAsyncWithHttpInfo($guild_id, $code, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteGuildTemplateAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  mixed $code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildTemplate'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteGuildTemplateAsyncWithHttpInfo(
        $guild_id,
        $code,
        string $contentType = self::contentTypes['deleteGuildTemplate'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildTemplateResponse';
        $request = $this->deleteGuildTemplateRequest($guild_id, $code, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteGuildTemplate'
     *
     * @param  string $guild_id (required)
     * @param  mixed $code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteGuildTemplate'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteGuildTemplateRequest(
        $guild_id,
        $code,
        string $contentType = self::contentTypes['deleteGuildTemplate'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling deleteGuildTemplate'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.deleteGuildTemplate, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $code when calling deleteGuildTemplate'
            );
        }
        if (strlen($code) > 152133) {
            throw new InvalidArgumentException('invalid length for "$code" when calling DefaultAPI.deleteGuildTemplate, must be smaller than or equal to 152133.');
        }
        

        $resourcePath = '/guilds/{guild_id}/templates/{code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteMessage
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $message_id message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMessage'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteMessage(
        string $channel_id,
        string $message_id,
        string $contentType = self::contentTypes['deleteMessage'][0]
    ): void
    {
        $this->deleteMessageWithHttpInfo($channel_id, $message_id, $contentType);
    }

    /**
     * Operation deleteMessageWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMessage'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteMessageWithHttpInfo(
        string $channel_id,
        string $message_id,
        string $contentType = self::contentTypes['deleteMessage'][0]
    ): array
    {
        $request = $this->deleteMessageRequest($channel_id, $message_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation deleteMessageAsync
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteMessageAsync(
        string $channel_id,
        string $message_id,
        string $contentType = self::contentTypes['deleteMessage'][0]
    ): PromiseInterface
    {
        return $this->deleteMessageAsyncWithHttpInfo($channel_id, $message_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteMessageAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteMessageAsyncWithHttpInfo(
        $channel_id,
        $message_id,
        string $contentType = self::contentTypes['deleteMessage'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteMessageRequest($channel_id, $message_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteMessage'
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteMessageRequest(
        $channel_id,
        $message_id,
        string $contentType = self::contentTypes['deleteMessage'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling deleteMessage'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.deleteMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $message_id when calling deleteMessage'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $message_id)) {
            throw new InvalidArgumentException("invalid value for \"message_id\" when calling DefaultAPI.deleteMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/channels/{channel_id}/messages/{message_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'message_id' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteMyMessageReaction
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $message_id message_id (required)
     * @param  string $emoji_name emoji_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMyMessageReaction'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteMyMessageReaction(
        string $channel_id,
        string $message_id,
        string $emoji_name,
        string $contentType = self::contentTypes['deleteMyMessageReaction'][0]
    ): void
    {
        $this->deleteMyMessageReactionWithHttpInfo($channel_id, $message_id, $emoji_name, $contentType);
    }

    /**
     * Operation deleteMyMessageReactionWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $emoji_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMyMessageReaction'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteMyMessageReactionWithHttpInfo(
        string $channel_id,
        string $message_id,
        string $emoji_name,
        string $contentType = self::contentTypes['deleteMyMessageReaction'][0]
    ): array
    {
        $request = $this->deleteMyMessageReactionRequest($channel_id, $message_id, $emoji_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation deleteMyMessageReactionAsync
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $emoji_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMyMessageReaction'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteMyMessageReactionAsync(
        string $channel_id,
        string $message_id,
        string $emoji_name,
        string $contentType = self::contentTypes['deleteMyMessageReaction'][0]
    ): PromiseInterface
    {
        return $this->deleteMyMessageReactionAsyncWithHttpInfo($channel_id, $message_id, $emoji_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteMyMessageReactionAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $emoji_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMyMessageReaction'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteMyMessageReactionAsyncWithHttpInfo(
        $channel_id,
        $message_id,
        $emoji_name,
        string $contentType = self::contentTypes['deleteMyMessageReaction'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteMyMessageReactionRequest($channel_id, $message_id, $emoji_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteMyMessageReaction'
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $emoji_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMyMessageReaction'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteMyMessageReactionRequest(
        $channel_id,
        $message_id,
        $emoji_name,
        string $contentType = self::contentTypes['deleteMyMessageReaction'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling deleteMyMessageReaction'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.deleteMyMessageReaction, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $message_id when calling deleteMyMessageReaction'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $message_id)) {
            throw new InvalidArgumentException("invalid value for \"message_id\" when calling DefaultAPI.deleteMyMessageReaction, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'emoji_name' is set
        if ($emoji_name === null || (is_array($emoji_name) && count($emoji_name) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $emoji_name when calling deleteMyMessageReaction'
            );
        }
        if (strlen($emoji_name) > 152133) {
            throw new InvalidArgumentException('invalid length for "$emoji_name" when calling DefaultAPI.deleteMyMessageReaction, must be smaller than or equal to 152133.');
        }
        

        $resourcePath = '/channels/{channel_id}/messages/{message_id}/reactions/{emoji_name}/@me';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'message_id' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }
        // path params
        if ($emoji_name !== null) {
            $resourcePath = str_replace(
                '{' . 'emoji_name' . '}',
                ObjectSerializer::toPathValue($emoji_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteOriginalWebhookMessage
     *
     * @param  string $webhook_id webhook_id (required)
     * @param  string $webhook_token webhook_token (required)
     * @param  string|null $thread_id thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOriginalWebhookMessage'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteOriginalWebhookMessage(
        string $webhook_id,
        string $webhook_token,
        ?string $thread_id = null,
        string $contentType = self::contentTypes['deleteOriginalWebhookMessage'][0]
    ): void
    {
        $this->deleteOriginalWebhookMessageWithHttpInfo($webhook_id, $webhook_token, $thread_id, $contentType);
    }

    /**
     * Operation deleteOriginalWebhookMessageWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  string $webhook_token (required)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOriginalWebhookMessage'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteOriginalWebhookMessageWithHttpInfo(
        string $webhook_id,
        string $webhook_token,
        ?string $thread_id = null,
        string $contentType = self::contentTypes['deleteOriginalWebhookMessage'][0]
    ): array
    {
        $request = $this->deleteOriginalWebhookMessageRequest($webhook_id, $webhook_token, $thread_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation deleteOriginalWebhookMessageAsync
     *
     * @param  string $webhook_id (required)
     * @param  string $webhook_token (required)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOriginalWebhookMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteOriginalWebhookMessageAsync(
        string $webhook_id,
        string $webhook_token,
        ?string $thread_id = null,
        string $contentType = self::contentTypes['deleteOriginalWebhookMessage'][0]
    ): PromiseInterface
    {
        return $this->deleteOriginalWebhookMessageAsyncWithHttpInfo($webhook_id, $webhook_token, $thread_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteOriginalWebhookMessageAsyncWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  string $webhook_token (required)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOriginalWebhookMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteOriginalWebhookMessageAsyncWithHttpInfo(
        $webhook_id,
        $webhook_token,
        $thread_id = null,
        string $contentType = self::contentTypes['deleteOriginalWebhookMessage'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteOriginalWebhookMessageRequest($webhook_id, $webhook_token, $thread_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteOriginalWebhookMessage'
     *
     * @param  string $webhook_id (required)
     * @param  string $webhook_token (required)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteOriginalWebhookMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteOriginalWebhookMessageRequest(
        $webhook_id,
        $webhook_token,
        $thread_id = null,
        string $contentType = self::contentTypes['deleteOriginalWebhookMessage'][0]
    ): Request
    {

        // verify the required parameter 'webhook_id' is set
        if ($webhook_id === null || (is_array($webhook_id) && count($webhook_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webhook_id when calling deleteOriginalWebhookMessage'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $webhook_id)) {
            throw new InvalidArgumentException("invalid value for \"webhook_id\" when calling DefaultAPI.deleteOriginalWebhookMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'webhook_token' is set
        if ($webhook_token === null || (is_array($webhook_token) && count($webhook_token) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webhook_token when calling deleteOriginalWebhookMessage'
            );
        }
        if (strlen($webhook_token) > 152133) {
            throw new InvalidArgumentException('invalid length for "$webhook_token" when calling DefaultAPI.deleteOriginalWebhookMessage, must be smaller than or equal to 152133.');
        }
        
        if ($thread_id !== null && !preg_match("/^(0|[1-9][0-9]*)$/", $thread_id)) {
            throw new InvalidArgumentException("invalid value for \"thread_id\" when calling DefaultAPI.deleteOriginalWebhookMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/webhooks/{webhook_id}/{webhook_token}/messages/@original';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $thread_id,
            'thread_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($webhook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_id' . '}',
                ObjectSerializer::toPathValue($webhook_id),
                $resourcePath
            );
        }
        // path params
        if ($webhook_token !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_token' . '}',
                ObjectSerializer::toPathValue($webhook_token),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteStageInstance
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStageInstance'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteStageInstance(
        string $channel_id,
        string $contentType = self::contentTypes['deleteStageInstance'][0]
    ): void
    {
        $this->deleteStageInstanceWithHttpInfo($channel_id, $contentType);
    }

    /**
     * Operation deleteStageInstanceWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStageInstance'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteStageInstanceWithHttpInfo(
        string $channel_id,
        string $contentType = self::contentTypes['deleteStageInstance'][0]
    ): array
    {
        $request = $this->deleteStageInstanceRequest($channel_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation deleteStageInstanceAsync
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStageInstance'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteStageInstanceAsync(
        string $channel_id,
        string $contentType = self::contentTypes['deleteStageInstance'][0]
    ): PromiseInterface
    {
        return $this->deleteStageInstanceAsyncWithHttpInfo($channel_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteStageInstanceAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStageInstance'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteStageInstanceAsyncWithHttpInfo(
        $channel_id,
        string $contentType = self::contentTypes['deleteStageInstance'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteStageInstanceRequest($channel_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteStageInstance'
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteStageInstance'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteStageInstanceRequest(
        $channel_id,
        string $contentType = self::contentTypes['deleteStageInstance'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling deleteStageInstance'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.deleteStageInstance, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/stage-instances/{channel_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteThreadMember
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $user_id user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteThreadMember'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteThreadMember(
        string $channel_id,
        string $user_id,
        string $contentType = self::contentTypes['deleteThreadMember'][0]
    ): void
    {
        $this->deleteThreadMemberWithHttpInfo($channel_id, $user_id, $contentType);
    }

    /**
     * Operation deleteThreadMemberWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteThreadMember'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteThreadMemberWithHttpInfo(
        string $channel_id,
        string $user_id,
        string $contentType = self::contentTypes['deleteThreadMember'][0]
    ): array
    {
        $request = $this->deleteThreadMemberRequest($channel_id, $user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation deleteThreadMemberAsync
     *
     * @param  string $channel_id (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteThreadMember'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteThreadMemberAsync(
        string $channel_id,
        string $user_id,
        string $contentType = self::contentTypes['deleteThreadMember'][0]
    ): PromiseInterface
    {
        return $this->deleteThreadMemberAsyncWithHttpInfo($channel_id, $user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteThreadMemberAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteThreadMember'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteThreadMemberAsyncWithHttpInfo(
        $channel_id,
        $user_id,
        string $contentType = self::contentTypes['deleteThreadMember'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteThreadMemberRequest($channel_id, $user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteThreadMember'
     *
     * @param  string $channel_id (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteThreadMember'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteThreadMemberRequest(
        $channel_id,
        $user_id,
        string $contentType = self::contentTypes['deleteThreadMember'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling deleteThreadMember'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.deleteThreadMember, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $user_id when calling deleteThreadMember'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $user_id)) {
            throw new InvalidArgumentException("invalid value for \"user_id\" when calling DefaultAPI.deleteThreadMember, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/channels/{channel_id}/thread-members/{user_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteUserMessageReaction
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $message_id message_id (required)
     * @param  mixed $emoji_name emoji_name (required)
     * @param  string $user_id user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteUserMessageReaction'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteUserMessageReaction(
        string $channel_id,
        string $message_id,
        mixed $emoji_name,
        string $user_id,
        string $contentType = self::contentTypes['deleteUserMessageReaction'][0]
    ): void
    {
        $this->deleteUserMessageReactionWithHttpInfo($channel_id, $message_id, $emoji_name, $user_id, $contentType);
    }

    /**
     * Operation deleteUserMessageReactionWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  mixed $emoji_name (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteUserMessageReaction'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteUserMessageReactionWithHttpInfo(
        string $channel_id,
        string $message_id,
        mixed $emoji_name,
        string $user_id,
        string $contentType = self::contentTypes['deleteUserMessageReaction'][0]
    ): array
    {
        $request = $this->deleteUserMessageReactionRequest($channel_id, $message_id, $emoji_name, $user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation deleteUserMessageReactionAsync
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  mixed $emoji_name (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteUserMessageReaction'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteUserMessageReactionAsync(
        string $channel_id,
        string $message_id,
        mixed $emoji_name,
        string $user_id,
        string $contentType = self::contentTypes['deleteUserMessageReaction'][0]
    ): PromiseInterface
    {
        return $this->deleteUserMessageReactionAsyncWithHttpInfo($channel_id, $message_id, $emoji_name, $user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteUserMessageReactionAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  mixed $emoji_name (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteUserMessageReaction'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteUserMessageReactionAsyncWithHttpInfo(
        $channel_id,
        $message_id,
        $emoji_name,
        $user_id,
        string $contentType = self::contentTypes['deleteUserMessageReaction'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteUserMessageReactionRequest($channel_id, $message_id, $emoji_name, $user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteUserMessageReaction'
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  mixed $emoji_name (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteUserMessageReaction'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteUserMessageReactionRequest(
        $channel_id,
        $message_id,
        $emoji_name,
        $user_id,
        string $contentType = self::contentTypes['deleteUserMessageReaction'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling deleteUserMessageReaction'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.deleteUserMessageReaction, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $message_id when calling deleteUserMessageReaction'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $message_id)) {
            throw new InvalidArgumentException("invalid value for \"message_id\" when calling DefaultAPI.deleteUserMessageReaction, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'emoji_name' is set
        if ($emoji_name === null || (is_array($emoji_name) && count($emoji_name) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $emoji_name when calling deleteUserMessageReaction'
            );
        }
        if (strlen($emoji_name) > 152133) {
            throw new InvalidArgumentException('invalid length for "$emoji_name" when calling DefaultAPI.deleteUserMessageReaction, must be smaller than or equal to 152133.');
        }
        
        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $user_id when calling deleteUserMessageReaction'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $user_id)) {
            throw new InvalidArgumentException("invalid value for \"user_id\" when calling DefaultAPI.deleteUserMessageReaction, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/channels/{channel_id}/messages/{message_id}/reactions/{emoji_name}/{user_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'message_id' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }
        // path params
        if ($emoji_name !== null) {
            $resourcePath = str_replace(
                '{' . 'emoji_name' . '}',
                ObjectSerializer::toPathValue($emoji_name),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteWebhook
     *
     * @param  string $webhook_id webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhook'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteWebhook(
        string $webhook_id,
        string $contentType = self::contentTypes['deleteWebhook'][0]
    ): void
    {
        $this->deleteWebhookWithHttpInfo($webhook_id, $contentType);
    }

    /**
     * Operation deleteWebhookWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhook'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteWebhookWithHttpInfo(
        string $webhook_id,
        string $contentType = self::contentTypes['deleteWebhook'][0]
    ): array
    {
        $request = $this->deleteWebhookRequest($webhook_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation deleteWebhookAsync
     *
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhook'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteWebhookAsync(
        string $webhook_id,
        string $contentType = self::contentTypes['deleteWebhook'][0]
    ): PromiseInterface
    {
        return $this->deleteWebhookAsyncWithHttpInfo($webhook_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteWebhookAsyncWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhook'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteWebhookAsyncWithHttpInfo(
        $webhook_id,
        string $contentType = self::contentTypes['deleteWebhook'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteWebhookRequest($webhook_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteWebhook'
     *
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhook'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteWebhookRequest(
        $webhook_id,
        string $contentType = self::contentTypes['deleteWebhook'][0]
    ): Request
    {

        // verify the required parameter 'webhook_id' is set
        if ($webhook_id === null || (is_array($webhook_id) && count($webhook_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webhook_id when calling deleteWebhook'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $webhook_id)) {
            throw new InvalidArgumentException("invalid value for \"webhook_id\" when calling DefaultAPI.deleteWebhook, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/webhooks/{webhook_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webhook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_id' . '}',
                ObjectSerializer::toPathValue($webhook_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteWebhookByToken
     *
     * @param  string $webhook_id webhook_id (required)
     * @param  mixed $webhook_token webhook_token (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhookByToken'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteWebhookByToken(
        string $webhook_id,
        mixed $webhook_token,
        string $contentType = self::contentTypes['deleteWebhookByToken'][0]
    ): void
    {
        $this->deleteWebhookByTokenWithHttpInfo($webhook_id, $webhook_token, $contentType);
    }

    /**
     * Operation deleteWebhookByTokenWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhookByToken'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteWebhookByTokenWithHttpInfo(
        string $webhook_id,
        mixed $webhook_token,
        string $contentType = self::contentTypes['deleteWebhookByToken'][0]
    ): array
    {
        $request = $this->deleteWebhookByTokenRequest($webhook_id, $webhook_token, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation deleteWebhookByTokenAsync
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhookByToken'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteWebhookByTokenAsync(
        string $webhook_id,
        mixed $webhook_token,
        string $contentType = self::contentTypes['deleteWebhookByToken'][0]
    ): PromiseInterface
    {
        return $this->deleteWebhookByTokenAsyncWithHttpInfo($webhook_id, $webhook_token, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteWebhookByTokenAsyncWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhookByToken'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteWebhookByTokenAsyncWithHttpInfo(
        $webhook_id,
        $webhook_token,
        string $contentType = self::contentTypes['deleteWebhookByToken'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteWebhookByTokenRequest($webhook_id, $webhook_token, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteWebhookByToken'
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhookByToken'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteWebhookByTokenRequest(
        $webhook_id,
        $webhook_token,
        string $contentType = self::contentTypes['deleteWebhookByToken'][0]
    ): Request
    {

        // verify the required parameter 'webhook_id' is set
        if ($webhook_id === null || (is_array($webhook_id) && count($webhook_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webhook_id when calling deleteWebhookByToken'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $webhook_id)) {
            throw new InvalidArgumentException("invalid value for \"webhook_id\" when calling DefaultAPI.deleteWebhookByToken, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'webhook_token' is set
        if ($webhook_token === null || (is_array($webhook_token) && count($webhook_token) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webhook_token when calling deleteWebhookByToken'
            );
        }
        if (strlen($webhook_token) > 152133) {
            throw new InvalidArgumentException('invalid length for "$webhook_token" when calling DefaultAPI.deleteWebhookByToken, must be smaller than or equal to 152133.');
        }
        

        $resourcePath = '/webhooks/{webhook_id}/{webhook_token}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webhook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_id' . '}',
                ObjectSerializer::toPathValue($webhook_id),
                $resourcePath
            );
        }
        // path params
        if ($webhook_token !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_token' . '}',
                ObjectSerializer::toPathValue($webhook_token),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteWebhookMessage
     *
     * @param  string $webhook_id webhook_id (required)
     * @param  mixed $webhook_token webhook_token (required)
     * @param  string $message_id message_id (required)
     * @param  string|null $thread_id thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhookMessage'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteWebhookMessage(
        string $webhook_id,
        mixed $webhook_token,
        string $message_id,
        ?string $thread_id = null,
        string $contentType = self::contentTypes['deleteWebhookMessage'][0]
    ): void
    {
        $this->deleteWebhookMessageWithHttpInfo($webhook_id, $webhook_token, $message_id, $thread_id, $contentType);
    }

    /**
     * Operation deleteWebhookMessageWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  string $message_id (required)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhookMessage'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteWebhookMessageWithHttpInfo(
        string $webhook_id,
        mixed $webhook_token,
        string $message_id,
        ?string $thread_id = null,
        string $contentType = self::contentTypes['deleteWebhookMessage'][0]
    ): array
    {
        $request = $this->deleteWebhookMessageRequest($webhook_id, $webhook_token, $message_id, $thread_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation deleteWebhookMessageAsync
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  string $message_id (required)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhookMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteWebhookMessageAsync(
        string $webhook_id,
        mixed $webhook_token,
        string $message_id,
        ?string $thread_id = null,
        string $contentType = self::contentTypes['deleteWebhookMessage'][0]
    ): PromiseInterface
    {
        return $this->deleteWebhookMessageAsyncWithHttpInfo($webhook_id, $webhook_token, $message_id, $thread_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteWebhookMessageAsyncWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  string $message_id (required)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhookMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteWebhookMessageAsyncWithHttpInfo(
        $webhook_id,
        $webhook_token,
        $message_id,
        $thread_id = null,
        string $contentType = self::contentTypes['deleteWebhookMessage'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteWebhookMessageRequest($webhook_id, $webhook_token, $message_id, $thread_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteWebhookMessage'
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  string $message_id (required)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhookMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteWebhookMessageRequest(
        $webhook_id,
        $webhook_token,
        $message_id,
        $thread_id = null,
        string $contentType = self::contentTypes['deleteWebhookMessage'][0]
    ): Request
    {

        // verify the required parameter 'webhook_id' is set
        if ($webhook_id === null || (is_array($webhook_id) && count($webhook_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webhook_id when calling deleteWebhookMessage'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $webhook_id)) {
            throw new InvalidArgumentException("invalid value for \"webhook_id\" when calling DefaultAPI.deleteWebhookMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'webhook_token' is set
        if ($webhook_token === null || (is_array($webhook_token) && count($webhook_token) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webhook_token when calling deleteWebhookMessage'
            );
        }
        if (strlen($webhook_token) > 152133) {
            throw new InvalidArgumentException('invalid length for "$webhook_token" when calling DefaultAPI.deleteWebhookMessage, must be smaller than or equal to 152133.');
        }
        
        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $message_id when calling deleteWebhookMessage'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $message_id)) {
            throw new InvalidArgumentException("invalid value for \"message_id\" when calling DefaultAPI.deleteWebhookMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        if ($thread_id !== null && !preg_match("/^(0|[1-9][0-9]*)$/", $thread_id)) {
            throw new InvalidArgumentException("invalid value for \"thread_id\" when calling DefaultAPI.deleteWebhookMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/webhooks/{webhook_id}/{webhook_token}/messages/{message_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $thread_id,
            'thread_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($webhook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_id' . '}',
                ObjectSerializer::toPathValue($webhook_id),
                $resourcePath
            );
        }
        // path params
        if ($webhook_token !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_token' . '}',
                ObjectSerializer::toPathValue($webhook_token),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'message_id' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation executeGithubCompatibleWebhook
     *
     * @param  string $webhook_id webhook_id (required)
     * @param  mixed $webhook_token webhook_token (required)
     * @param  \OpenAPI\Client\Model\GithubWebhook $github_webhook github_webhook (required)
     * @param  bool|null $wait wait (optional)
     * @param  string|null $thread_id thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['executeGithubCompatibleWebhook'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function executeGithubCompatibleWebhook(
        string $webhook_id,
        mixed $webhook_token,
        \OpenAPI\Client\Model\GithubWebhook $github_webhook,
        ?bool $wait = null,
        ?string $thread_id = null,
        string $contentType = self::contentTypes['executeGithubCompatibleWebhook'][0]
    ): void
    {
        $this->executeGithubCompatibleWebhookWithHttpInfo($webhook_id, $webhook_token, $github_webhook, $wait, $thread_id, $contentType);
    }

    /**
     * Operation executeGithubCompatibleWebhookWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  \OpenAPI\Client\Model\GithubWebhook $github_webhook (required)
     * @param  bool|null $wait (optional)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['executeGithubCompatibleWebhook'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function executeGithubCompatibleWebhookWithHttpInfo(
        string $webhook_id,
        mixed $webhook_token,
        \OpenAPI\Client\Model\GithubWebhook $github_webhook,
        ?bool $wait = null,
        ?string $thread_id = null,
        string $contentType = self::contentTypes['executeGithubCompatibleWebhook'][0]
    ): array
    {
        $request = $this->executeGithubCompatibleWebhookRequest($webhook_id, $webhook_token, $github_webhook, $wait, $thread_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation executeGithubCompatibleWebhookAsync
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  \OpenAPI\Client\Model\GithubWebhook $github_webhook (required)
     * @param  bool|null $wait (optional)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['executeGithubCompatibleWebhook'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function executeGithubCompatibleWebhookAsync(
        string $webhook_id,
        mixed $webhook_token,
        \OpenAPI\Client\Model\GithubWebhook $github_webhook,
        ?bool $wait = null,
        ?string $thread_id = null,
        string $contentType = self::contentTypes['executeGithubCompatibleWebhook'][0]
    ): PromiseInterface
    {
        return $this->executeGithubCompatibleWebhookAsyncWithHttpInfo($webhook_id, $webhook_token, $github_webhook, $wait, $thread_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation executeGithubCompatibleWebhookAsyncWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  \OpenAPI\Client\Model\GithubWebhook $github_webhook (required)
     * @param  bool|null $wait (optional)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['executeGithubCompatibleWebhook'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function executeGithubCompatibleWebhookAsyncWithHttpInfo(
        $webhook_id,
        $webhook_token,
        $github_webhook,
        $wait = null,
        $thread_id = null,
        string $contentType = self::contentTypes['executeGithubCompatibleWebhook'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->executeGithubCompatibleWebhookRequest($webhook_id, $webhook_token, $github_webhook, $wait, $thread_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'executeGithubCompatibleWebhook'
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  \OpenAPI\Client\Model\GithubWebhook $github_webhook (required)
     * @param  bool|null $wait (optional)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['executeGithubCompatibleWebhook'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function executeGithubCompatibleWebhookRequest(
        $webhook_id,
        $webhook_token,
        $github_webhook,
        $wait = null,
        $thread_id = null,
        string $contentType = self::contentTypes['executeGithubCompatibleWebhook'][0]
    ): Request
    {

        // verify the required parameter 'webhook_id' is set
        if ($webhook_id === null || (is_array($webhook_id) && count($webhook_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webhook_id when calling executeGithubCompatibleWebhook'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $webhook_id)) {
            throw new InvalidArgumentException("invalid value for \"webhook_id\" when calling DefaultAPI.executeGithubCompatibleWebhook, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'webhook_token' is set
        if ($webhook_token === null || (is_array($webhook_token) && count($webhook_token) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webhook_token when calling executeGithubCompatibleWebhook'
            );
        }
        if (strlen($webhook_token) > 152133) {
            throw new InvalidArgumentException('invalid length for "$webhook_token" when calling DefaultAPI.executeGithubCompatibleWebhook, must be smaller than or equal to 152133.');
        }
        
        // verify the required parameter 'github_webhook' is set
        if ($github_webhook === null || (is_array($github_webhook) && count($github_webhook) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $github_webhook when calling executeGithubCompatibleWebhook'
            );
        }


        if ($thread_id !== null && !preg_match("/^(0|[1-9][0-9]*)$/", $thread_id)) {
            throw new InvalidArgumentException("invalid value for \"thread_id\" when calling DefaultAPI.executeGithubCompatibleWebhook, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/webhooks/{webhook_id}/{webhook_token}/github';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $wait,
            'wait', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $thread_id,
            'thread_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($webhook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_id' . '}',
                ObjectSerializer::toPathValue($webhook_id),
                $resourcePath
            );
        }
        // path params
        if ($webhook_token !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_token' . '}',
                ObjectSerializer::toPathValue($webhook_token),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($github_webhook)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($github_webhook));
            } else {
                $httpBody = $github_webhook;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation executeSlackCompatibleWebhook
     *
     * @param  string $webhook_id webhook_id (required)
     * @param  mixed $webhook_token webhook_token (required)
     * @param  \OpenAPI\Client\Model\SlackWebhook $slack_webhook slack_webhook (required)
     * @param  bool|null $wait wait (optional)
     * @param  string|null $thread_id thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['executeSlackCompatibleWebhook'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return string|\OpenAPI\Client\Model\ErrorResponse
     */
    public function executeSlackCompatibleWebhook(
        string $webhook_id,
        mixed $webhook_token,
        \OpenAPI\Client\Model\SlackWebhook $slack_webhook,
        ?bool $wait = null,
        ?string $thread_id = null,
        string $contentType = self::contentTypes['executeSlackCompatibleWebhook'][0]
    ): string
    {
        list($response) = $this->executeSlackCompatibleWebhookWithHttpInfo($webhook_id, $webhook_token, $slack_webhook, $wait, $thread_id, $contentType);
        return $response;
    }

    /**
     * Operation executeSlackCompatibleWebhookWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  \OpenAPI\Client\Model\SlackWebhook $slack_webhook (required)
     * @param  bool|null $wait (optional)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['executeSlackCompatibleWebhook'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of string|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function executeSlackCompatibleWebhookWithHttpInfo(
        string $webhook_id,
        mixed $webhook_token,
        \OpenAPI\Client\Model\SlackWebhook $slack_webhook,
        ?bool $wait = null,
        ?string $thread_id = null,
        string $contentType = self::contentTypes['executeSlackCompatibleWebhook'][0]
    ): array
    {
        $request = $this->executeSlackCompatibleWebhookRequest($webhook_id, $webhook_token, $slack_webhook, $wait, $thread_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation executeSlackCompatibleWebhookAsync
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  \OpenAPI\Client\Model\SlackWebhook $slack_webhook (required)
     * @param  bool|null $wait (optional)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['executeSlackCompatibleWebhook'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function executeSlackCompatibleWebhookAsync(
        string $webhook_id,
        mixed $webhook_token,
        \OpenAPI\Client\Model\SlackWebhook $slack_webhook,
        ?bool $wait = null,
        ?string $thread_id = null,
        string $contentType = self::contentTypes['executeSlackCompatibleWebhook'][0]
    ): PromiseInterface
    {
        return $this->executeSlackCompatibleWebhookAsyncWithHttpInfo($webhook_id, $webhook_token, $slack_webhook, $wait, $thread_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation executeSlackCompatibleWebhookAsyncWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  \OpenAPI\Client\Model\SlackWebhook $slack_webhook (required)
     * @param  bool|null $wait (optional)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['executeSlackCompatibleWebhook'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function executeSlackCompatibleWebhookAsyncWithHttpInfo(
        $webhook_id,
        $webhook_token,
        $slack_webhook,
        $wait = null,
        $thread_id = null,
        string $contentType = self::contentTypes['executeSlackCompatibleWebhook'][0]
    ): PromiseInterface
    {
        $returnType = 'string';
        $request = $this->executeSlackCompatibleWebhookRequest($webhook_id, $webhook_token, $slack_webhook, $wait, $thread_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'executeSlackCompatibleWebhook'
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  \OpenAPI\Client\Model\SlackWebhook $slack_webhook (required)
     * @param  bool|null $wait (optional)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['executeSlackCompatibleWebhook'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function executeSlackCompatibleWebhookRequest(
        $webhook_id,
        $webhook_token,
        $slack_webhook,
        $wait = null,
        $thread_id = null,
        string $contentType = self::contentTypes['executeSlackCompatibleWebhook'][0]
    ): Request
    {

        // verify the required parameter 'webhook_id' is set
        if ($webhook_id === null || (is_array($webhook_id) && count($webhook_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webhook_id when calling executeSlackCompatibleWebhook'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $webhook_id)) {
            throw new InvalidArgumentException("invalid value for \"webhook_id\" when calling DefaultAPI.executeSlackCompatibleWebhook, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'webhook_token' is set
        if ($webhook_token === null || (is_array($webhook_token) && count($webhook_token) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webhook_token when calling executeSlackCompatibleWebhook'
            );
        }
        if (strlen($webhook_token) > 152133) {
            throw new InvalidArgumentException('invalid length for "$webhook_token" when calling DefaultAPI.executeSlackCompatibleWebhook, must be smaller than or equal to 152133.');
        }
        
        // verify the required parameter 'slack_webhook' is set
        if ($slack_webhook === null || (is_array($slack_webhook) && count($slack_webhook) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $slack_webhook when calling executeSlackCompatibleWebhook'
            );
        }


        if ($thread_id !== null && !preg_match("/^(0|[1-9][0-9]*)$/", $thread_id)) {
            throw new InvalidArgumentException("invalid value for \"thread_id\" when calling DefaultAPI.executeSlackCompatibleWebhook, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/webhooks/{webhook_id}/{webhook_token}/slack';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $wait,
            'wait', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $thread_id,
            'thread_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($webhook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_id' . '}',
                ObjectSerializer::toPathValue($webhook_id),
                $resourcePath
            );
        }
        // path params
        if ($webhook_token !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_token' . '}',
                ObjectSerializer::toPathValue($webhook_token),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($slack_webhook)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($slack_webhook));
            } else {
                $httpBody = $slack_webhook;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation executeWebhook
     *
     * @param  string $webhook_id webhook_id (required)
     * @param  mixed $webhook_token webhook_token (required)
     * @param  \OpenAPI\Client\Model\ExecuteWebhookRequest $execute_webhook_request execute_webhook_request (required)
     * @param  bool|null $wait wait (optional)
     * @param  string|null $thread_id thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['executeWebhook'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\MessageResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function executeWebhook(
        string $webhook_id,
        mixed $webhook_token,
        \OpenAPI\Client\Model\ExecuteWebhookRequest $execute_webhook_request,
        ?bool $wait = null,
        ?string $thread_id = null,
        string $contentType = self::contentTypes['executeWebhook'][0]
    ): \OpenAPI\Client\Model\MessageResponse
    {
        list($response) = $this->executeWebhookWithHttpInfo($webhook_id, $webhook_token, $execute_webhook_request, $wait, $thread_id, $contentType);
        return $response;
    }

    /**
     * Operation executeWebhookWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  \OpenAPI\Client\Model\ExecuteWebhookRequest $execute_webhook_request (required)
     * @param  bool|null $wait (optional)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['executeWebhook'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MessageResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function executeWebhookWithHttpInfo(
        string $webhook_id,
        mixed $webhook_token,
        \OpenAPI\Client\Model\ExecuteWebhookRequest $execute_webhook_request,
        ?bool $wait = null,
        ?string $thread_id = null,
        string $contentType = self::contentTypes['executeWebhook'][0]
    ): array
    {
        $request = $this->executeWebhookRequest($webhook_id, $webhook_token, $execute_webhook_request, $wait, $thread_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\MessageResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\MessageResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MessageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\MessageResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MessageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation executeWebhookAsync
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  \OpenAPI\Client\Model\ExecuteWebhookRequest $execute_webhook_request (required)
     * @param  bool|null $wait (optional)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['executeWebhook'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function executeWebhookAsync(
        string $webhook_id,
        mixed $webhook_token,
        \OpenAPI\Client\Model\ExecuteWebhookRequest $execute_webhook_request,
        ?bool $wait = null,
        ?string $thread_id = null,
        string $contentType = self::contentTypes['executeWebhook'][0]
    ): PromiseInterface
    {
        return $this->executeWebhookAsyncWithHttpInfo($webhook_id, $webhook_token, $execute_webhook_request, $wait, $thread_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation executeWebhookAsyncWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  \OpenAPI\Client\Model\ExecuteWebhookRequest $execute_webhook_request (required)
     * @param  bool|null $wait (optional)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['executeWebhook'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function executeWebhookAsyncWithHttpInfo(
        $webhook_id,
        $webhook_token,
        $execute_webhook_request,
        $wait = null,
        $thread_id = null,
        string $contentType = self::contentTypes['executeWebhook'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\MessageResponse';
        $request = $this->executeWebhookRequest($webhook_id, $webhook_token, $execute_webhook_request, $wait, $thread_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'executeWebhook'
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  \OpenAPI\Client\Model\ExecuteWebhookRequest $execute_webhook_request (required)
     * @param  bool|null $wait (optional)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['executeWebhook'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function executeWebhookRequest(
        $webhook_id,
        $webhook_token,
        $execute_webhook_request,
        $wait = null,
        $thread_id = null,
        string $contentType = self::contentTypes['executeWebhook'][0]
    ): Request
    {

        // verify the required parameter 'webhook_id' is set
        if ($webhook_id === null || (is_array($webhook_id) && count($webhook_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webhook_id when calling executeWebhook'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $webhook_id)) {
            throw new InvalidArgumentException("invalid value for \"webhook_id\" when calling DefaultAPI.executeWebhook, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'webhook_token' is set
        if ($webhook_token === null || (is_array($webhook_token) && count($webhook_token) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webhook_token when calling executeWebhook'
            );
        }
        if (strlen($webhook_token) > 152133) {
            throw new InvalidArgumentException('invalid length for "$webhook_token" when calling DefaultAPI.executeWebhook, must be smaller than or equal to 152133.');
        }
        
        // verify the required parameter 'execute_webhook_request' is set
        if ($execute_webhook_request === null || (is_array($execute_webhook_request) && count($execute_webhook_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $execute_webhook_request when calling executeWebhook'
            );
        }


        if ($thread_id !== null && !preg_match("/^(0|[1-9][0-9]*)$/", $thread_id)) {
            throw new InvalidArgumentException("invalid value for \"thread_id\" when calling DefaultAPI.executeWebhook, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/webhooks/{webhook_id}/{webhook_token}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $wait,
            'wait', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $thread_id,
            'thread_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($webhook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_id' . '}',
                ObjectSerializer::toPathValue($webhook_id),
                $resourcePath
            );
        }
        // path params
        if ($webhook_token !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_token' . '}',
                ObjectSerializer::toPathValue($webhook_token),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($execute_webhook_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($execute_webhook_request));
            } else {
                $httpBody = $execute_webhook_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation followChannel
     *
     * @param  string $channel_id channel_id (required)
     * @param  \OpenAPI\Client\Model\FollowChannelRequest $follow_channel_request follow_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['followChannel'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ChannelFollowerResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function followChannel(
        string $channel_id,
        \OpenAPI\Client\Model\FollowChannelRequest $follow_channel_request,
        string $contentType = self::contentTypes['followChannel'][0]
    ): \OpenAPI\Client\Model\ChannelFollowerResponse
    {
        list($response) = $this->followChannelWithHttpInfo($channel_id, $follow_channel_request, $contentType);
        return $response;
    }

    /**
     * Operation followChannelWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\FollowChannelRequest $follow_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['followChannel'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ChannelFollowerResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function followChannelWithHttpInfo(
        string $channel_id,
        \OpenAPI\Client\Model\FollowChannelRequest $follow_channel_request,
        string $contentType = self::contentTypes['followChannel'][0]
    ): array
    {
        $request = $this->followChannelRequest($channel_id, $follow_channel_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ChannelFollowerResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ChannelFollowerResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ChannelFollowerResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ChannelFollowerResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ChannelFollowerResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation followChannelAsync
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\FollowChannelRequest $follow_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['followChannel'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function followChannelAsync(
        string $channel_id,
        \OpenAPI\Client\Model\FollowChannelRequest $follow_channel_request,
        string $contentType = self::contentTypes['followChannel'][0]
    ): PromiseInterface
    {
        return $this->followChannelAsyncWithHttpInfo($channel_id, $follow_channel_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation followChannelAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\FollowChannelRequest $follow_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['followChannel'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function followChannelAsyncWithHttpInfo(
        $channel_id,
        $follow_channel_request,
        string $contentType = self::contentTypes['followChannel'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ChannelFollowerResponse';
        $request = $this->followChannelRequest($channel_id, $follow_channel_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'followChannel'
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\FollowChannelRequest $follow_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['followChannel'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function followChannelRequest(
        $channel_id,
        $follow_channel_request,
        string $contentType = self::contentTypes['followChannel'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling followChannel'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.followChannel, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'follow_channel_request' is set
        if ($follow_channel_request === null || (is_array($follow_channel_request) && count($follow_channel_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $follow_channel_request when calling followChannel'
            );
        }


        $resourcePath = '/channels/{channel_id}/followers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($follow_channel_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($follow_channel_request));
            } else {
                $httpBody = $follow_channel_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getActiveGuildThreads
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getActiveGuildThreads'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ThreadsResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getActiveGuildThreads(
        string $guild_id,
        string $contentType = self::contentTypes['getActiveGuildThreads'][0]
    ): \OpenAPI\Client\Model\ThreadsResponse
    {
        list($response) = $this->getActiveGuildThreadsWithHttpInfo($guild_id, $contentType);
        return $response;
    }

    /**
     * Operation getActiveGuildThreadsWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getActiveGuildThreads'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ThreadsResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getActiveGuildThreadsWithHttpInfo(
        string $guild_id,
        string $contentType = self::contentTypes['getActiveGuildThreads'][0]
    ): array
    {
        $request = $this->getActiveGuildThreadsRequest($guild_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ThreadsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ThreadsResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ThreadsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ThreadsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ThreadsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getActiveGuildThreadsAsync
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getActiveGuildThreads'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getActiveGuildThreadsAsync(
        string $guild_id,
        string $contentType = self::contentTypes['getActiveGuildThreads'][0]
    ): PromiseInterface
    {
        return $this->getActiveGuildThreadsAsyncWithHttpInfo($guild_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getActiveGuildThreadsAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getActiveGuildThreads'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getActiveGuildThreadsAsyncWithHttpInfo(
        $guild_id,
        string $contentType = self::contentTypes['getActiveGuildThreads'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ThreadsResponse';
        $request = $this->getActiveGuildThreadsRequest($guild_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getActiveGuildThreads'
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getActiveGuildThreads'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getActiveGuildThreadsRequest(
        $guild_id,
        string $contentType = self::contentTypes['getActiveGuildThreads'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling getActiveGuildThreads'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.getActiveGuildThreads, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/threads/active';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApplication
     *
     * @param  string $application_id application_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApplication'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\PrivateApplicationResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getApplication(
        string $application_id,
        string $contentType = self::contentTypes['getApplication'][0]
    ): \OpenAPI\Client\Model\PrivateApplicationResponse
    {
        list($response) = $this->getApplicationWithHttpInfo($application_id, $contentType);
        return $response;
    }

    /**
     * Operation getApplicationWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApplication'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PrivateApplicationResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApplicationWithHttpInfo(
        string $application_id,
        string $contentType = self::contentTypes['getApplication'][0]
    ): array
    {
        $request = $this->getApplicationRequest($application_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PrivateApplicationResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PrivateApplicationResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PrivateApplicationResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\PrivateApplicationResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PrivateApplicationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getApplicationAsync
     *
     * @param  string $application_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApplication'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getApplicationAsync(
        string $application_id,
        string $contentType = self::contentTypes['getApplication'][0]
    ): PromiseInterface
    {
        return $this->getApplicationAsyncWithHttpInfo($application_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApplicationAsyncWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApplication'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getApplicationAsyncWithHttpInfo(
        $application_id,
        string $contentType = self::contentTypes['getApplication'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\PrivateApplicationResponse';
        $request = $this->getApplicationRequest($application_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApplication'
     *
     * @param  string $application_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApplication'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getApplicationRequest(
        $application_id,
        string $contentType = self::contentTypes['getApplication'][0]
    ): Request
    {

        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_id when calling getApplication'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $application_id)) {
            throw new InvalidArgumentException("invalid value for \"application_id\" when calling DefaultAPI.getApplication, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/applications/{application_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'application_id' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApplicationCommand
     *
     * @param  string $application_id application_id (required)
     * @param  string $command_id command_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApplicationCommand'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApplicationCommandResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getApplicationCommand(
        string $application_id,
        string $command_id,
        string $contentType = self::contentTypes['getApplicationCommand'][0]
    ): \OpenAPI\Client\Model\ApplicationCommandResponse
    {
        list($response) = $this->getApplicationCommandWithHttpInfo($application_id, $command_id, $contentType);
        return $response;
    }

    /**
     * Operation getApplicationCommandWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $command_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApplicationCommand'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApplicationCommandResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApplicationCommandWithHttpInfo(
        string $application_id,
        string $command_id,
        string $contentType = self::contentTypes['getApplicationCommand'][0]
    ): array
    {
        $request = $this->getApplicationCommandRequest($application_id, $command_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ApplicationCommandResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ApplicationCommandResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApplicationCommandResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ApplicationCommandResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApplicationCommandResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getApplicationCommandAsync
     *
     * @param  string $application_id (required)
     * @param  string $command_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApplicationCommand'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getApplicationCommandAsync(
        string $application_id,
        string $command_id,
        string $contentType = self::contentTypes['getApplicationCommand'][0]
    ): PromiseInterface
    {
        return $this->getApplicationCommandAsyncWithHttpInfo($application_id, $command_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApplicationCommandAsyncWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $command_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApplicationCommand'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getApplicationCommandAsyncWithHttpInfo(
        $application_id,
        $command_id,
        string $contentType = self::contentTypes['getApplicationCommand'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ApplicationCommandResponse';
        $request = $this->getApplicationCommandRequest($application_id, $command_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApplicationCommand'
     *
     * @param  string $application_id (required)
     * @param  string $command_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApplicationCommand'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getApplicationCommandRequest(
        $application_id,
        $command_id,
        string $contentType = self::contentTypes['getApplicationCommand'][0]
    ): Request
    {

        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_id when calling getApplicationCommand'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $application_id)) {
            throw new InvalidArgumentException("invalid value for \"application_id\" when calling DefaultAPI.getApplicationCommand, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'command_id' is set
        if ($command_id === null || (is_array($command_id) && count($command_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $command_id when calling getApplicationCommand'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $command_id)) {
            throw new InvalidArgumentException("invalid value for \"command_id\" when calling DefaultAPI.getApplicationCommand, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/applications/{application_id}/commands/{command_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'application_id' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($command_id !== null) {
            $resourcePath = str_replace(
                '{' . 'command_id' . '}',
                ObjectSerializer::toPathValue($command_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApplicationRoleConnectionsMetadata
     *
     * @param  string $application_id application_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApplicationRoleConnectionsMetadata'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApplicationRoleConnectionsMetadataItemResponse[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getApplicationRoleConnectionsMetadata(
        string $application_id,
        string $contentType = self::contentTypes['getApplicationRoleConnectionsMetadata'][0]
    ): array
    {
        list($response) = $this->getApplicationRoleConnectionsMetadataWithHttpInfo($application_id, $contentType);
        return $response;
    }

    /**
     * Operation getApplicationRoleConnectionsMetadataWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApplicationRoleConnectionsMetadata'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApplicationRoleConnectionsMetadataItemResponse[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApplicationRoleConnectionsMetadataWithHttpInfo(
        string $application_id,
        string $contentType = self::contentTypes['getApplicationRoleConnectionsMetadata'][0]
    ): array
    {
        $request = $this->getApplicationRoleConnectionsMetadataRequest($application_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ApplicationRoleConnectionsMetadataItemResponse[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ApplicationRoleConnectionsMetadataItemResponse[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApplicationRoleConnectionsMetadataItemResponse[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ApplicationRoleConnectionsMetadataItemResponse[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApplicationRoleConnectionsMetadataItemResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getApplicationRoleConnectionsMetadataAsync
     *
     * @param  string $application_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApplicationRoleConnectionsMetadata'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getApplicationRoleConnectionsMetadataAsync(
        string $application_id,
        string $contentType = self::contentTypes['getApplicationRoleConnectionsMetadata'][0]
    ): PromiseInterface
    {
        return $this->getApplicationRoleConnectionsMetadataAsyncWithHttpInfo($application_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApplicationRoleConnectionsMetadataAsyncWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApplicationRoleConnectionsMetadata'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getApplicationRoleConnectionsMetadataAsyncWithHttpInfo(
        $application_id,
        string $contentType = self::contentTypes['getApplicationRoleConnectionsMetadata'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ApplicationRoleConnectionsMetadataItemResponse[]';
        $request = $this->getApplicationRoleConnectionsMetadataRequest($application_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApplicationRoleConnectionsMetadata'
     *
     * @param  string $application_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApplicationRoleConnectionsMetadata'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getApplicationRoleConnectionsMetadataRequest(
        $application_id,
        string $contentType = self::contentTypes['getApplicationRoleConnectionsMetadata'][0]
    ): Request
    {

        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_id when calling getApplicationRoleConnectionsMetadata'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $application_id)) {
            throw new InvalidArgumentException("invalid value for \"application_id\" when calling DefaultAPI.getApplicationRoleConnectionsMetadata, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/applications/{application_id}/role-connections/metadata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'application_id' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getApplicationUserRoleConnection
     *
     * @param  string $application_id application_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApplicationUserRoleConnection'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApplicationUserRoleConnectionResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getApplicationUserRoleConnection(
        string $application_id,
        string $contentType = self::contentTypes['getApplicationUserRoleConnection'][0]
    ): \OpenAPI\Client\Model\ApplicationUserRoleConnectionResponse
    {
        list($response) = $this->getApplicationUserRoleConnectionWithHttpInfo($application_id, $contentType);
        return $response;
    }

    /**
     * Operation getApplicationUserRoleConnectionWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApplicationUserRoleConnection'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApplicationUserRoleConnectionResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getApplicationUserRoleConnectionWithHttpInfo(
        string $application_id,
        string $contentType = self::contentTypes['getApplicationUserRoleConnection'][0]
    ): array
    {
        $request = $this->getApplicationUserRoleConnectionRequest($application_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ApplicationUserRoleConnectionResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ApplicationUserRoleConnectionResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApplicationUserRoleConnectionResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ApplicationUserRoleConnectionResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApplicationUserRoleConnectionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getApplicationUserRoleConnectionAsync
     *
     * @param  string $application_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApplicationUserRoleConnection'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getApplicationUserRoleConnectionAsync(
        string $application_id,
        string $contentType = self::contentTypes['getApplicationUserRoleConnection'][0]
    ): PromiseInterface
    {
        return $this->getApplicationUserRoleConnectionAsyncWithHttpInfo($application_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getApplicationUserRoleConnectionAsyncWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApplicationUserRoleConnection'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getApplicationUserRoleConnectionAsyncWithHttpInfo(
        $application_id,
        string $contentType = self::contentTypes['getApplicationUserRoleConnection'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ApplicationUserRoleConnectionResponse';
        $request = $this->getApplicationUserRoleConnectionRequest($application_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getApplicationUserRoleConnection'
     *
     * @param  string $application_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getApplicationUserRoleConnection'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getApplicationUserRoleConnectionRequest(
        $application_id,
        string $contentType = self::contentTypes['getApplicationUserRoleConnection'][0]
    ): Request
    {

        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_id when calling getApplicationUserRoleConnection'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $application_id)) {
            throw new InvalidArgumentException("invalid value for \"application_id\" when calling DefaultAPI.getApplicationUserRoleConnection, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/users/@me/applications/{application_id}/role-connection';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'application_id' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAutoModerationRule
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $rule_id rule_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAutoModerationRule'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetAutoModerationRule200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getAutoModerationRule(
        string $guild_id,
        string $rule_id,
        string $contentType = self::contentTypes['getAutoModerationRule'][0]
    ): \OpenAPI\Client\Model\GetAutoModerationRule200Response
    {
        list($response) = $this->getAutoModerationRuleWithHttpInfo($guild_id, $rule_id, $contentType);
        return $response;
    }

    /**
     * Operation getAutoModerationRuleWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $rule_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAutoModerationRule'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetAutoModerationRule200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAutoModerationRuleWithHttpInfo(
        string $guild_id,
        string $rule_id,
        string $contentType = self::contentTypes['getAutoModerationRule'][0]
    ): array
    {
        $request = $this->getAutoModerationRuleRequest($guild_id, $rule_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetAutoModerationRule200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetAutoModerationRule200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetAutoModerationRule200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GetAutoModerationRule200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetAutoModerationRule200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getAutoModerationRuleAsync
     *
     * @param  string $guild_id (required)
     * @param  string $rule_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAutoModerationRule'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getAutoModerationRuleAsync(
        string $guild_id,
        string $rule_id,
        string $contentType = self::contentTypes['getAutoModerationRule'][0]
    ): PromiseInterface
    {
        return $this->getAutoModerationRuleAsyncWithHttpInfo($guild_id, $rule_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAutoModerationRuleAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $rule_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAutoModerationRule'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getAutoModerationRuleAsyncWithHttpInfo(
        $guild_id,
        $rule_id,
        string $contentType = self::contentTypes['getAutoModerationRule'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GetAutoModerationRule200Response';
        $request = $this->getAutoModerationRuleRequest($guild_id, $rule_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAutoModerationRule'
     *
     * @param  string $guild_id (required)
     * @param  string $rule_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAutoModerationRule'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAutoModerationRuleRequest(
        $guild_id,
        $rule_id,
        string $contentType = self::contentTypes['getAutoModerationRule'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling getAutoModerationRule'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.getAutoModerationRule, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'rule_id' is set
        if ($rule_id === null || (is_array($rule_id) && count($rule_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $rule_id when calling getAutoModerationRule'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $rule_id)) {
            throw new InvalidArgumentException("invalid value for \"rule_id\" when calling DefaultAPI.getAutoModerationRule, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/auto-moderation/rules/{rule_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($rule_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rule_id' . '}',
                ObjectSerializer::toPathValue($rule_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBotGateway
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBotGateway'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GatewayBotResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getBotGateway(
        string $contentType = self::contentTypes['getBotGateway'][0]
    ): \OpenAPI\Client\Model\GatewayBotResponse
    {
        list($response) = $this->getBotGatewayWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getBotGatewayWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBotGateway'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GatewayBotResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBotGatewayWithHttpInfo(
        string $contentType = self::contentTypes['getBotGateway'][0]
    ): array
    {
        $request = $this->getBotGatewayRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GatewayBotResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GatewayBotResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GatewayBotResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GatewayBotResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GatewayBotResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getBotGatewayAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBotGateway'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getBotGatewayAsync(
        string $contentType = self::contentTypes['getBotGateway'][0]
    ): PromiseInterface
    {
        return $this->getBotGatewayAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBotGatewayAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBotGateway'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getBotGatewayAsyncWithHttpInfo(
        string $contentType = self::contentTypes['getBotGateway'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GatewayBotResponse';
        $request = $this->getBotGatewayRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBotGateway'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBotGateway'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBotGatewayRequest(
        string $contentType = self::contentTypes['getBotGateway'][0]
    ): Request
    {


        $resourcePath = '/gateway/bot';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getChannel
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChannel'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListGuildChannels200ResponseInner|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getChannel(
        string $channel_id,
        string $contentType = self::contentTypes['getChannel'][0]
    ): \OpenAPI\Client\Model\ListGuildChannels200ResponseInner
    {
        list($response) = $this->getChannelWithHttpInfo($channel_id, $contentType);
        return $response;
    }

    /**
     * Operation getChannelWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChannel'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListGuildChannels200ResponseInner|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getChannelWithHttpInfo(
        string $channel_id,
        string $contentType = self::contentTypes['getChannel'][0]
    ): array
    {
        $request = $this->getChannelRequest($channel_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListGuildChannels200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListGuildChannels200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListGuildChannels200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ListGuildChannels200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListGuildChannels200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getChannelAsync
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChannel'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getChannelAsync(
        string $channel_id,
        string $contentType = self::contentTypes['getChannel'][0]
    ): PromiseInterface
    {
        return $this->getChannelAsyncWithHttpInfo($channel_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getChannelAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChannel'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getChannelAsyncWithHttpInfo(
        $channel_id,
        string $contentType = self::contentTypes['getChannel'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ListGuildChannels200ResponseInner';
        $request = $this->getChannelRequest($channel_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getChannel'
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getChannel'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getChannelRequest(
        $channel_id,
        string $contentType = self::contentTypes['getChannel'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling getChannel'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.getChannel, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/channels/{channel_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGateway
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGateway'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GatewayResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getGateway(
        string $contentType = self::contentTypes['getGateway'][0]
    ): \OpenAPI\Client\Model\GatewayResponse
    {
        list($response) = $this->getGatewayWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getGatewayWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGateway'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GatewayResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGatewayWithHttpInfo(
        string $contentType = self::contentTypes['getGateway'][0]
    ): array
    {
        $request = $this->getGatewayRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GatewayResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GatewayResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GatewayResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GatewayResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GatewayResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getGatewayAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGateway'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGatewayAsync(
        string $contentType = self::contentTypes['getGateway'][0]
    ): PromiseInterface
    {
        return $this->getGatewayAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGatewayAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGateway'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGatewayAsyncWithHttpInfo(
        string $contentType = self::contentTypes['getGateway'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GatewayResponse';
        $request = $this->getGatewayRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGateway'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGateway'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGatewayRequest(
        string $contentType = self::contentTypes['getGateway'][0]
    ): Request
    {


        $resourcePath = '/gateway';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuild
     *
     * @param  string $guild_id guild_id (required)
     * @param  bool|null $with_counts with_counts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuild'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildWithCountsResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getGuild(
        string $guild_id,
        ?bool $with_counts = null,
        string $contentType = self::contentTypes['getGuild'][0]
    ): \OpenAPI\Client\Model\GuildWithCountsResponse
    {
        list($response) = $this->getGuildWithHttpInfo($guild_id, $with_counts, $contentType);
        return $response;
    }

    /**
     * Operation getGuildWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  bool|null $with_counts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuild'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildWithCountsResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuildWithHttpInfo(
        string $guild_id,
        ?bool $with_counts = null,
        string $contentType = self::contentTypes['getGuild'][0]
    ): array
    {
        $request = $this->getGuildRequest($guild_id, $with_counts, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildWithCountsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildWithCountsResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildWithCountsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildWithCountsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildWithCountsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getGuildAsync
     *
     * @param  string $guild_id (required)
     * @param  bool|null $with_counts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuild'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildAsync(
        string $guild_id,
        ?bool $with_counts = null,
        string $contentType = self::contentTypes['getGuild'][0]
    ): PromiseInterface
    {
        return $this->getGuildAsyncWithHttpInfo($guild_id, $with_counts, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuildAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  bool|null $with_counts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuild'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildAsyncWithHttpInfo(
        $guild_id,
        $with_counts = null,
        string $contentType = self::contentTypes['getGuild'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildWithCountsResponse';
        $request = $this->getGuildRequest($guild_id, $with_counts, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuild'
     *
     * @param  string $guild_id (required)
     * @param  bool|null $with_counts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuild'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGuildRequest(
        $guild_id,
        $with_counts = null,
        string $contentType = self::contentTypes['getGuild'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling getGuild'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.getGuild, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        


        $resourcePath = '/guilds/{guild_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_counts,
            'with_counts', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuildApplicationCommand
     *
     * @param  string $application_id application_id (required)
     * @param  string $guild_id guild_id (required)
     * @param  string $command_id command_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildApplicationCommand'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApplicationCommandResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getGuildApplicationCommand(
        string $application_id,
        string $guild_id,
        string $command_id,
        string $contentType = self::contentTypes['getGuildApplicationCommand'][0]
    ): \OpenAPI\Client\Model\ApplicationCommandResponse
    {
        list($response) = $this->getGuildApplicationCommandWithHttpInfo($application_id, $guild_id, $command_id, $contentType);
        return $response;
    }

    /**
     * Operation getGuildApplicationCommandWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  string $command_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildApplicationCommand'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApplicationCommandResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuildApplicationCommandWithHttpInfo(
        string $application_id,
        string $guild_id,
        string $command_id,
        string $contentType = self::contentTypes['getGuildApplicationCommand'][0]
    ): array
    {
        $request = $this->getGuildApplicationCommandRequest($application_id, $guild_id, $command_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ApplicationCommandResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ApplicationCommandResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApplicationCommandResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ApplicationCommandResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApplicationCommandResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getGuildApplicationCommandAsync
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  string $command_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildApplicationCommand'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildApplicationCommandAsync(
        string $application_id,
        string $guild_id,
        string $command_id,
        string $contentType = self::contentTypes['getGuildApplicationCommand'][0]
    ): PromiseInterface
    {
        return $this->getGuildApplicationCommandAsyncWithHttpInfo($application_id, $guild_id, $command_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuildApplicationCommandAsyncWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  string $command_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildApplicationCommand'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildApplicationCommandAsyncWithHttpInfo(
        $application_id,
        $guild_id,
        $command_id,
        string $contentType = self::contentTypes['getGuildApplicationCommand'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ApplicationCommandResponse';
        $request = $this->getGuildApplicationCommandRequest($application_id, $guild_id, $command_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuildApplicationCommand'
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  string $command_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildApplicationCommand'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGuildApplicationCommandRequest(
        $application_id,
        $guild_id,
        $command_id,
        string $contentType = self::contentTypes['getGuildApplicationCommand'][0]
    ): Request
    {

        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_id when calling getGuildApplicationCommand'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $application_id)) {
            throw new InvalidArgumentException("invalid value for \"application_id\" when calling DefaultAPI.getGuildApplicationCommand, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling getGuildApplicationCommand'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.getGuildApplicationCommand, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'command_id' is set
        if ($command_id === null || (is_array($command_id) && count($command_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $command_id when calling getGuildApplicationCommand'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $command_id)) {
            throw new InvalidArgumentException("invalid value for \"command_id\" when calling DefaultAPI.getGuildApplicationCommand, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/applications/{application_id}/guilds/{guild_id}/commands/{command_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'application_id' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($command_id !== null) {
            $resourcePath = str_replace(
                '{' . 'command_id' . '}',
                ObjectSerializer::toPathValue($command_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuildApplicationCommandPermissions
     *
     * @param  string $application_id application_id (required)
     * @param  string $guild_id guild_id (required)
     * @param  string $command_id command_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildApplicationCommandPermissions'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\CommandPermissionsResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getGuildApplicationCommandPermissions(
        string $application_id,
        string $guild_id,
        string $command_id,
        string $contentType = self::contentTypes['getGuildApplicationCommandPermissions'][0]
    ): \OpenAPI\Client\Model\CommandPermissionsResponse
    {
        list($response) = $this->getGuildApplicationCommandPermissionsWithHttpInfo($application_id, $guild_id, $command_id, $contentType);
        return $response;
    }

    /**
     * Operation getGuildApplicationCommandPermissionsWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  string $command_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildApplicationCommandPermissions'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CommandPermissionsResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuildApplicationCommandPermissionsWithHttpInfo(
        string $application_id,
        string $guild_id,
        string $command_id,
        string $contentType = self::contentTypes['getGuildApplicationCommandPermissions'][0]
    ): array
    {
        $request = $this->getGuildApplicationCommandPermissionsRequest($application_id, $guild_id, $command_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CommandPermissionsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CommandPermissionsResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CommandPermissionsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\CommandPermissionsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CommandPermissionsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getGuildApplicationCommandPermissionsAsync
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  string $command_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildApplicationCommandPermissions'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildApplicationCommandPermissionsAsync(
        string $application_id,
        string $guild_id,
        string $command_id,
        string $contentType = self::contentTypes['getGuildApplicationCommandPermissions'][0]
    ): PromiseInterface
    {
        return $this->getGuildApplicationCommandPermissionsAsyncWithHttpInfo($application_id, $guild_id, $command_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuildApplicationCommandPermissionsAsyncWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  string $command_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildApplicationCommandPermissions'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildApplicationCommandPermissionsAsyncWithHttpInfo(
        $application_id,
        $guild_id,
        $command_id,
        string $contentType = self::contentTypes['getGuildApplicationCommandPermissions'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\CommandPermissionsResponse';
        $request = $this->getGuildApplicationCommandPermissionsRequest($application_id, $guild_id, $command_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuildApplicationCommandPermissions'
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  string $command_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildApplicationCommandPermissions'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGuildApplicationCommandPermissionsRequest(
        $application_id,
        $guild_id,
        $command_id,
        string $contentType = self::contentTypes['getGuildApplicationCommandPermissions'][0]
    ): Request
    {

        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_id when calling getGuildApplicationCommandPermissions'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $application_id)) {
            throw new InvalidArgumentException("invalid value for \"application_id\" when calling DefaultAPI.getGuildApplicationCommandPermissions, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling getGuildApplicationCommandPermissions'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.getGuildApplicationCommandPermissions, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'command_id' is set
        if ($command_id === null || (is_array($command_id) && count($command_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $command_id when calling getGuildApplicationCommandPermissions'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $command_id)) {
            throw new InvalidArgumentException("invalid value for \"command_id\" when calling DefaultAPI.getGuildApplicationCommandPermissions, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/applications/{application_id}/guilds/{guild_id}/commands/{command_id}/permissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'application_id' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($command_id !== null) {
            $resourcePath = str_replace(
                '{' . 'command_id' . '}',
                ObjectSerializer::toPathValue($command_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuildBan
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $user_id user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildBan'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildBanResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getGuildBan(
        string $guild_id,
        string $user_id,
        string $contentType = self::contentTypes['getGuildBan'][0]
    ): \OpenAPI\Client\Model\GuildBanResponse
    {
        list($response) = $this->getGuildBanWithHttpInfo($guild_id, $user_id, $contentType);
        return $response;
    }

    /**
     * Operation getGuildBanWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildBan'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildBanResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuildBanWithHttpInfo(
        string $guild_id,
        string $user_id,
        string $contentType = self::contentTypes['getGuildBan'][0]
    ): array
    {
        $request = $this->getGuildBanRequest($guild_id, $user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildBanResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildBanResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildBanResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildBanResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildBanResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getGuildBanAsync
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildBan'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildBanAsync(
        string $guild_id,
        string $user_id,
        string $contentType = self::contentTypes['getGuildBan'][0]
    ): PromiseInterface
    {
        return $this->getGuildBanAsyncWithHttpInfo($guild_id, $user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuildBanAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildBan'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildBanAsyncWithHttpInfo(
        $guild_id,
        $user_id,
        string $contentType = self::contentTypes['getGuildBan'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildBanResponse';
        $request = $this->getGuildBanRequest($guild_id, $user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuildBan'
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildBan'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGuildBanRequest(
        $guild_id,
        $user_id,
        string $contentType = self::contentTypes['getGuildBan'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling getGuildBan'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.getGuildBan, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $user_id when calling getGuildBan'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $user_id)) {
            throw new InvalidArgumentException("invalid value for \"user_id\" when calling DefaultAPI.getGuildBan, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/bans/{user_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuildEmoji
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $emoji_id emoji_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildEmoji'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmojiResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getGuildEmoji(
        string $guild_id,
        string $emoji_id,
        string $contentType = self::contentTypes['getGuildEmoji'][0]
    ): \OpenAPI\Client\Model\EmojiResponse
    {
        list($response) = $this->getGuildEmojiWithHttpInfo($guild_id, $emoji_id, $contentType);
        return $response;
    }

    /**
     * Operation getGuildEmojiWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $emoji_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildEmoji'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmojiResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuildEmojiWithHttpInfo(
        string $guild_id,
        string $emoji_id,
        string $contentType = self::contentTypes['getGuildEmoji'][0]
    ): array
    {
        $request = $this->getGuildEmojiRequest($guild_id, $emoji_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EmojiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmojiResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmojiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\EmojiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmojiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getGuildEmojiAsync
     *
     * @param  string $guild_id (required)
     * @param  string $emoji_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildEmoji'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildEmojiAsync(
        string $guild_id,
        string $emoji_id,
        string $contentType = self::contentTypes['getGuildEmoji'][0]
    ): PromiseInterface
    {
        return $this->getGuildEmojiAsyncWithHttpInfo($guild_id, $emoji_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuildEmojiAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $emoji_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildEmoji'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildEmojiAsyncWithHttpInfo(
        $guild_id,
        $emoji_id,
        string $contentType = self::contentTypes['getGuildEmoji'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\EmojiResponse';
        $request = $this->getGuildEmojiRequest($guild_id, $emoji_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuildEmoji'
     *
     * @param  string $guild_id (required)
     * @param  string $emoji_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildEmoji'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGuildEmojiRequest(
        $guild_id,
        $emoji_id,
        string $contentType = self::contentTypes['getGuildEmoji'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling getGuildEmoji'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.getGuildEmoji, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'emoji_id' is set
        if ($emoji_id === null || (is_array($emoji_id) && count($emoji_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $emoji_id when calling getGuildEmoji'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $emoji_id)) {
            throw new InvalidArgumentException("invalid value for \"emoji_id\" when calling DefaultAPI.getGuildEmoji, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/emojis/{emoji_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($emoji_id !== null) {
            $resourcePath = str_replace(
                '{' . 'emoji_id' . '}',
                ObjectSerializer::toPathValue($emoji_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuildMember
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $user_id user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildMember'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildMemberResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getGuildMember(
        string $guild_id,
        string $user_id,
        string $contentType = self::contentTypes['getGuildMember'][0]
    ): \OpenAPI\Client\Model\GuildMemberResponse
    {
        list($response) = $this->getGuildMemberWithHttpInfo($guild_id, $user_id, $contentType);
        return $response;
    }

    /**
     * Operation getGuildMemberWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildMember'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildMemberResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuildMemberWithHttpInfo(
        string $guild_id,
        string $user_id,
        string $contentType = self::contentTypes['getGuildMember'][0]
    ): array
    {
        $request = $this->getGuildMemberRequest($guild_id, $user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildMemberResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildMemberResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildMemberResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildMemberResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildMemberResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getGuildMemberAsync
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildMember'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildMemberAsync(
        string $guild_id,
        string $user_id,
        string $contentType = self::contentTypes['getGuildMember'][0]
    ): PromiseInterface
    {
        return $this->getGuildMemberAsyncWithHttpInfo($guild_id, $user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuildMemberAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildMember'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildMemberAsyncWithHttpInfo(
        $guild_id,
        $user_id,
        string $contentType = self::contentTypes['getGuildMember'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildMemberResponse';
        $request = $this->getGuildMemberRequest($guild_id, $user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuildMember'
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildMember'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGuildMemberRequest(
        $guild_id,
        $user_id,
        string $contentType = self::contentTypes['getGuildMember'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling getGuildMember'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.getGuildMember, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $user_id when calling getGuildMember'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $user_id)) {
            throw new InvalidArgumentException("invalid value for \"user_id\" when calling DefaultAPI.getGuildMember, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/members/{user_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuildNewMemberWelcome
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildNewMemberWelcome'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildHomeSettingsResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getGuildNewMemberWelcome(
        string $guild_id,
        string $contentType = self::contentTypes['getGuildNewMemberWelcome'][0]
    ): \OpenAPI\Client\Model\GuildHomeSettingsResponse
    {
        list($response) = $this->getGuildNewMemberWelcomeWithHttpInfo($guild_id, $contentType);
        return $response;
    }

    /**
     * Operation getGuildNewMemberWelcomeWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildNewMemberWelcome'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildHomeSettingsResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuildNewMemberWelcomeWithHttpInfo(
        string $guild_id,
        string $contentType = self::contentTypes['getGuildNewMemberWelcome'][0]
    ): array
    {
        $request = $this->getGuildNewMemberWelcomeRequest($guild_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildHomeSettingsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildHomeSettingsResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildHomeSettingsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildHomeSettingsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildHomeSettingsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getGuildNewMemberWelcomeAsync
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildNewMemberWelcome'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildNewMemberWelcomeAsync(
        string $guild_id,
        string $contentType = self::contentTypes['getGuildNewMemberWelcome'][0]
    ): PromiseInterface
    {
        return $this->getGuildNewMemberWelcomeAsyncWithHttpInfo($guild_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuildNewMemberWelcomeAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildNewMemberWelcome'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildNewMemberWelcomeAsyncWithHttpInfo(
        $guild_id,
        string $contentType = self::contentTypes['getGuildNewMemberWelcome'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildHomeSettingsResponse';
        $request = $this->getGuildNewMemberWelcomeRequest($guild_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuildNewMemberWelcome'
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildNewMemberWelcome'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGuildNewMemberWelcomeRequest(
        $guild_id,
        string $contentType = self::contentTypes['getGuildNewMemberWelcome'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling getGuildNewMemberWelcome'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.getGuildNewMemberWelcome, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/new-member-welcome';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuildPreview
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildPreview'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildPreviewResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getGuildPreview(
        string $guild_id,
        string $contentType = self::contentTypes['getGuildPreview'][0]
    ): \OpenAPI\Client\Model\GuildPreviewResponse
    {
        list($response) = $this->getGuildPreviewWithHttpInfo($guild_id, $contentType);
        return $response;
    }

    /**
     * Operation getGuildPreviewWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildPreview'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildPreviewResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuildPreviewWithHttpInfo(
        string $guild_id,
        string $contentType = self::contentTypes['getGuildPreview'][0]
    ): array
    {
        $request = $this->getGuildPreviewRequest($guild_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildPreviewResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildPreviewResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildPreviewResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildPreviewResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildPreviewResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getGuildPreviewAsync
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildPreview'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildPreviewAsync(
        string $guild_id,
        string $contentType = self::contentTypes['getGuildPreview'][0]
    ): PromiseInterface
    {
        return $this->getGuildPreviewAsyncWithHttpInfo($guild_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuildPreviewAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildPreview'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildPreviewAsyncWithHttpInfo(
        $guild_id,
        string $contentType = self::contentTypes['getGuildPreview'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildPreviewResponse';
        $request = $this->getGuildPreviewRequest($guild_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuildPreview'
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildPreview'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGuildPreviewRequest(
        $guild_id,
        string $contentType = self::contentTypes['getGuildPreview'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling getGuildPreview'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.getGuildPreview, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuildScheduledEvent
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $guild_scheduled_event_id guild_scheduled_event_id (required)
     * @param  bool|null $with_user_count with_user_count (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildScheduledEvent'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetGuildScheduledEvent200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getGuildScheduledEvent(
        string $guild_id,
        string $guild_scheduled_event_id,
        ?bool $with_user_count = null,
        string $contentType = self::contentTypes['getGuildScheduledEvent'][0]
    ): \OpenAPI\Client\Model\GetGuildScheduledEvent200Response
    {
        list($response) = $this->getGuildScheduledEventWithHttpInfo($guild_id, $guild_scheduled_event_id, $with_user_count, $contentType);
        return $response;
    }

    /**
     * Operation getGuildScheduledEventWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $guild_scheduled_event_id (required)
     * @param  bool|null $with_user_count (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildScheduledEvent'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetGuildScheduledEvent200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuildScheduledEventWithHttpInfo(
        string $guild_id,
        string $guild_scheduled_event_id,
        ?bool $with_user_count = null,
        string $contentType = self::contentTypes['getGuildScheduledEvent'][0]
    ): array
    {
        $request = $this->getGuildScheduledEventRequest($guild_id, $guild_scheduled_event_id, $with_user_count, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetGuildScheduledEvent200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetGuildScheduledEvent200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetGuildScheduledEvent200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GetGuildScheduledEvent200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetGuildScheduledEvent200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getGuildScheduledEventAsync
     *
     * @param  string $guild_id (required)
     * @param  string $guild_scheduled_event_id (required)
     * @param  bool|null $with_user_count (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildScheduledEvent'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildScheduledEventAsync(
        string $guild_id,
        string $guild_scheduled_event_id,
        ?bool $with_user_count = null,
        string $contentType = self::contentTypes['getGuildScheduledEvent'][0]
    ): PromiseInterface
    {
        return $this->getGuildScheduledEventAsyncWithHttpInfo($guild_id, $guild_scheduled_event_id, $with_user_count, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuildScheduledEventAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $guild_scheduled_event_id (required)
     * @param  bool|null $with_user_count (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildScheduledEvent'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildScheduledEventAsyncWithHttpInfo(
        $guild_id,
        $guild_scheduled_event_id,
        $with_user_count = null,
        string $contentType = self::contentTypes['getGuildScheduledEvent'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GetGuildScheduledEvent200Response';
        $request = $this->getGuildScheduledEventRequest($guild_id, $guild_scheduled_event_id, $with_user_count, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuildScheduledEvent'
     *
     * @param  string $guild_id (required)
     * @param  string $guild_scheduled_event_id (required)
     * @param  bool|null $with_user_count (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildScheduledEvent'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGuildScheduledEventRequest(
        $guild_id,
        $guild_scheduled_event_id,
        $with_user_count = null,
        string $contentType = self::contentTypes['getGuildScheduledEvent'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling getGuildScheduledEvent'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.getGuildScheduledEvent, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'guild_scheduled_event_id' is set
        if ($guild_scheduled_event_id === null || (is_array($guild_scheduled_event_id) && count($guild_scheduled_event_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_scheduled_event_id when calling getGuildScheduledEvent'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_scheduled_event_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_scheduled_event_id\" when calling DefaultAPI.getGuildScheduledEvent, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        


        $resourcePath = '/guilds/{guild_id}/scheduled-events/{guild_scheduled_event_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_user_count,
            'with_user_count', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($guild_scheduled_event_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_scheduled_event_id' . '}',
                ObjectSerializer::toPathValue($guild_scheduled_event_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuildSticker
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $sticker_id sticker_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildSticker'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildStickerResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getGuildSticker(
        string $guild_id,
        string $sticker_id,
        string $contentType = self::contentTypes['getGuildSticker'][0]
    ): \OpenAPI\Client\Model\GuildStickerResponse
    {
        list($response) = $this->getGuildStickerWithHttpInfo($guild_id, $sticker_id, $contentType);
        return $response;
    }

    /**
     * Operation getGuildStickerWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $sticker_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildSticker'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildStickerResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuildStickerWithHttpInfo(
        string $guild_id,
        string $sticker_id,
        string $contentType = self::contentTypes['getGuildSticker'][0]
    ): array
    {
        $request = $this->getGuildStickerRequest($guild_id, $sticker_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildStickerResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildStickerResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildStickerResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildStickerResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildStickerResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getGuildStickerAsync
     *
     * @param  string $guild_id (required)
     * @param  string $sticker_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildSticker'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildStickerAsync(
        string $guild_id,
        string $sticker_id,
        string $contentType = self::contentTypes['getGuildSticker'][0]
    ): PromiseInterface
    {
        return $this->getGuildStickerAsyncWithHttpInfo($guild_id, $sticker_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuildStickerAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $sticker_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildSticker'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildStickerAsyncWithHttpInfo(
        $guild_id,
        $sticker_id,
        string $contentType = self::contentTypes['getGuildSticker'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildStickerResponse';
        $request = $this->getGuildStickerRequest($guild_id, $sticker_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuildSticker'
     *
     * @param  string $guild_id (required)
     * @param  string $sticker_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildSticker'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGuildStickerRequest(
        $guild_id,
        $sticker_id,
        string $contentType = self::contentTypes['getGuildSticker'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling getGuildSticker'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.getGuildSticker, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'sticker_id' is set
        if ($sticker_id === null || (is_array($sticker_id) && count($sticker_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sticker_id when calling getGuildSticker'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $sticker_id)) {
            throw new InvalidArgumentException("invalid value for \"sticker_id\" when calling DefaultAPI.getGuildSticker, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/stickers/{sticker_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($sticker_id !== null) {
            $resourcePath = str_replace(
                '{' . 'sticker_id' . '}',
                ObjectSerializer::toPathValue($sticker_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuildTemplate
     *
     * @param  string $code code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildTemplate'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildTemplateResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getGuildTemplate(
        string $code,
        string $contentType = self::contentTypes['getGuildTemplate'][0]
    ): \OpenAPI\Client\Model\GuildTemplateResponse
    {
        list($response) = $this->getGuildTemplateWithHttpInfo($code, $contentType);
        return $response;
    }

    /**
     * Operation getGuildTemplateWithHttpInfo
     *
     * @param  string $code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildTemplate'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildTemplateResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuildTemplateWithHttpInfo(
        string $code,
        string $contentType = self::contentTypes['getGuildTemplate'][0]
    ): array
    {
        $request = $this->getGuildTemplateRequest($code, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildTemplateResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildTemplateResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildTemplateResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildTemplateResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildTemplateResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getGuildTemplateAsync
     *
     * @param  string $code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildTemplate'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildTemplateAsync(
        string $code,
        string $contentType = self::contentTypes['getGuildTemplate'][0]
    ): PromiseInterface
    {
        return $this->getGuildTemplateAsyncWithHttpInfo($code, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuildTemplateAsyncWithHttpInfo
     *
     * @param  string $code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildTemplate'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildTemplateAsyncWithHttpInfo(
        $code,
        string $contentType = self::contentTypes['getGuildTemplate'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildTemplateResponse';
        $request = $this->getGuildTemplateRequest($code, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuildTemplate'
     *
     * @param  string $code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildTemplate'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGuildTemplateRequest(
        $code,
        string $contentType = self::contentTypes['getGuildTemplate'][0]
    ): Request
    {

        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $code when calling getGuildTemplate'
            );
        }
        if (strlen($code) > 152133) {
            throw new InvalidArgumentException('invalid length for "$code" when calling DefaultAPI.getGuildTemplate, must be smaller than or equal to 152133.');
        }
        

        $resourcePath = '/guilds/templates/{code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuildVanityUrl
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildVanityUrl'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\VanityURLResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getGuildVanityUrl(
        string $guild_id,
        string $contentType = self::contentTypes['getGuildVanityUrl'][0]
    ): \OpenAPI\Client\Model\VanityURLResponse
    {
        list($response) = $this->getGuildVanityUrlWithHttpInfo($guild_id, $contentType);
        return $response;
    }

    /**
     * Operation getGuildVanityUrlWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildVanityUrl'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VanityURLResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuildVanityUrlWithHttpInfo(
        string $guild_id,
        string $contentType = self::contentTypes['getGuildVanityUrl'][0]
    ): array
    {
        $request = $this->getGuildVanityUrlRequest($guild_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\VanityURLResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VanityURLResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VanityURLResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\VanityURLResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VanityURLResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getGuildVanityUrlAsync
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildVanityUrl'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildVanityUrlAsync(
        string $guild_id,
        string $contentType = self::contentTypes['getGuildVanityUrl'][0]
    ): PromiseInterface
    {
        return $this->getGuildVanityUrlAsyncWithHttpInfo($guild_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuildVanityUrlAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildVanityUrl'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildVanityUrlAsyncWithHttpInfo(
        $guild_id,
        string $contentType = self::contentTypes['getGuildVanityUrl'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\VanityURLResponse';
        $request = $this->getGuildVanityUrlRequest($guild_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuildVanityUrl'
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildVanityUrl'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGuildVanityUrlRequest(
        $guild_id,
        string $contentType = self::contentTypes['getGuildVanityUrl'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling getGuildVanityUrl'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.getGuildVanityUrl, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/vanity-url';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuildWebhooks
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildWebhooks'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getGuildWebhooks(
        string $guild_id,
        string $contentType = self::contentTypes['getGuildWebhooks'][0]
    ): array
    {
        list($response) = $this->getGuildWebhooksWithHttpInfo($guild_id, $contentType);
        return $response;
    }

    /**
     * Operation getGuildWebhooksWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildWebhooks'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuildWebhooksWithHttpInfo(
        string $guild_id,
        string $contentType = self::contentTypes['getGuildWebhooks'][0]
    ): array
    {
        $request = $this->getGuildWebhooksRequest($guild_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getGuildWebhooksAsync
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildWebhooks'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildWebhooksAsync(
        string $guild_id,
        string $contentType = self::contentTypes['getGuildWebhooks'][0]
    ): PromiseInterface
    {
        return $this->getGuildWebhooksAsyncWithHttpInfo($guild_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuildWebhooksAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildWebhooks'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildWebhooksAsyncWithHttpInfo(
        $guild_id,
        string $contentType = self::contentTypes['getGuildWebhooks'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner[]';
        $request = $this->getGuildWebhooksRequest($guild_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuildWebhooks'
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildWebhooks'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGuildWebhooksRequest(
        $guild_id,
        string $contentType = self::contentTypes['getGuildWebhooks'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling getGuildWebhooks'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.getGuildWebhooks, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/webhooks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuildWelcomeScreen
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildWelcomeScreen'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildWelcomeScreenResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getGuildWelcomeScreen(
        string $guild_id,
        string $contentType = self::contentTypes['getGuildWelcomeScreen'][0]
    ): \OpenAPI\Client\Model\GuildWelcomeScreenResponse
    {
        list($response) = $this->getGuildWelcomeScreenWithHttpInfo($guild_id, $contentType);
        return $response;
    }

    /**
     * Operation getGuildWelcomeScreenWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildWelcomeScreen'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildWelcomeScreenResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuildWelcomeScreenWithHttpInfo(
        string $guild_id,
        string $contentType = self::contentTypes['getGuildWelcomeScreen'][0]
    ): array
    {
        $request = $this->getGuildWelcomeScreenRequest($guild_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildWelcomeScreenResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildWelcomeScreenResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildWelcomeScreenResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildWelcomeScreenResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildWelcomeScreenResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getGuildWelcomeScreenAsync
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildWelcomeScreen'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildWelcomeScreenAsync(
        string $guild_id,
        string $contentType = self::contentTypes['getGuildWelcomeScreen'][0]
    ): PromiseInterface
    {
        return $this->getGuildWelcomeScreenAsyncWithHttpInfo($guild_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuildWelcomeScreenAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildWelcomeScreen'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildWelcomeScreenAsyncWithHttpInfo(
        $guild_id,
        string $contentType = self::contentTypes['getGuildWelcomeScreen'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildWelcomeScreenResponse';
        $request = $this->getGuildWelcomeScreenRequest($guild_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuildWelcomeScreen'
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildWelcomeScreen'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGuildWelcomeScreenRequest(
        $guild_id,
        string $contentType = self::contentTypes['getGuildWelcomeScreen'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling getGuildWelcomeScreen'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.getGuildWelcomeScreen, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/welcome-screen';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuildWidget
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildWidget'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\WidgetResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getGuildWidget(
        string $guild_id,
        string $contentType = self::contentTypes['getGuildWidget'][0]
    ): \OpenAPI\Client\Model\WidgetResponse
    {
        list($response) = $this->getGuildWidgetWithHttpInfo($guild_id, $contentType);
        return $response;
    }

    /**
     * Operation getGuildWidgetWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildWidget'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WidgetResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuildWidgetWithHttpInfo(
        string $guild_id,
        string $contentType = self::contentTypes['getGuildWidget'][0]
    ): array
    {
        $request = $this->getGuildWidgetRequest($guild_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WidgetResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WidgetResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WidgetResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\WidgetResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WidgetResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getGuildWidgetAsync
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildWidget'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildWidgetAsync(
        string $guild_id,
        string $contentType = self::contentTypes['getGuildWidget'][0]
    ): PromiseInterface
    {
        return $this->getGuildWidgetAsyncWithHttpInfo($guild_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuildWidgetAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildWidget'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildWidgetAsyncWithHttpInfo(
        $guild_id,
        string $contentType = self::contentTypes['getGuildWidget'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\WidgetResponse';
        $request = $this->getGuildWidgetRequest($guild_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuildWidget'
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildWidget'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGuildWidgetRequest(
        $guild_id,
        string $contentType = self::contentTypes['getGuildWidget'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling getGuildWidget'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.getGuildWidget, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/widget.json';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuildWidgetPng
     *
     * @param  string $guild_id guild_id (required)
     * @param  WidgetImageStyles|null $style style (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildWidgetPng'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return string|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getGuildWidgetPng(
        string $guild_id,
        ?WidgetImageStyles $style = null,
        string $contentType = self::contentTypes['getGuildWidgetPng'][0]
    ): string
    {
        list($response) = $this->getGuildWidgetPngWithHttpInfo($guild_id, $style, $contentType);
        return $response;
    }

    /**
     * Operation getGuildWidgetPngWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  WidgetImageStyles|null $style (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildWidgetPng'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of string|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuildWidgetPngWithHttpInfo(
        string $guild_id,
        ?WidgetImageStyles $style = null,
        string $contentType = self::contentTypes['getGuildWidgetPng'][0]
    ): array
    {
        $request = $this->getGuildWidgetPngRequest($guild_id, $style, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getGuildWidgetPngAsync
     *
     * @param  string $guild_id (required)
     * @param  WidgetImageStyles|null $style (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildWidgetPng'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildWidgetPngAsync(
        string $guild_id,
        ?WidgetImageStyles $style = null,
        string $contentType = self::contentTypes['getGuildWidgetPng'][0]
    ): PromiseInterface
    {
        return $this->getGuildWidgetPngAsyncWithHttpInfo($guild_id, $style, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuildWidgetPngAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  WidgetImageStyles|null $style (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildWidgetPng'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildWidgetPngAsyncWithHttpInfo(
        $guild_id,
        $style = null,
        string $contentType = self::contentTypes['getGuildWidgetPng'][0]
    ): PromiseInterface
    {
        $returnType = 'string';
        $request = $this->getGuildWidgetPngRequest($guild_id, $style, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuildWidgetPng'
     *
     * @param  string $guild_id (required)
     * @param  WidgetImageStyles|null $style (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildWidgetPng'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGuildWidgetPngRequest(
        $guild_id,
        $style = null,
        string $contentType = self::contentTypes['getGuildWidgetPng'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling getGuildWidgetPng'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.getGuildWidgetPng, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        


        $resourcePath = '/guilds/{guild_id}/widget.png';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $style,
            'style', // param base name
            'OneOf', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['image/png', 'application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuildWidgetSettings
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildWidgetSettings'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\WidgetSettingsResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getGuildWidgetSettings(
        string $guild_id,
        string $contentType = self::contentTypes['getGuildWidgetSettings'][0]
    ): \OpenAPI\Client\Model\WidgetSettingsResponse
    {
        list($response) = $this->getGuildWidgetSettingsWithHttpInfo($guild_id, $contentType);
        return $response;
    }

    /**
     * Operation getGuildWidgetSettingsWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildWidgetSettings'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WidgetSettingsResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuildWidgetSettingsWithHttpInfo(
        string $guild_id,
        string $contentType = self::contentTypes['getGuildWidgetSettings'][0]
    ): array
    {
        $request = $this->getGuildWidgetSettingsRequest($guild_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WidgetSettingsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WidgetSettingsResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WidgetSettingsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\WidgetSettingsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WidgetSettingsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getGuildWidgetSettingsAsync
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildWidgetSettings'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildWidgetSettingsAsync(
        string $guild_id,
        string $contentType = self::contentTypes['getGuildWidgetSettings'][0]
    ): PromiseInterface
    {
        return $this->getGuildWidgetSettingsAsyncWithHttpInfo($guild_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuildWidgetSettingsAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildWidgetSettings'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildWidgetSettingsAsyncWithHttpInfo(
        $guild_id,
        string $contentType = self::contentTypes['getGuildWidgetSettings'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\WidgetSettingsResponse';
        $request = $this->getGuildWidgetSettingsRequest($guild_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuildWidgetSettings'
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildWidgetSettings'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGuildWidgetSettingsRequest(
        $guild_id,
        string $contentType = self::contentTypes['getGuildWidgetSettings'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling getGuildWidgetSettings'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.getGuildWidgetSettings, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/widget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuildsOnboarding
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildsOnboarding'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\UserGuildOnboardingResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getGuildsOnboarding(
        string $guild_id,
        string $contentType = self::contentTypes['getGuildsOnboarding'][0]
    ): \OpenAPI\Client\Model\UserGuildOnboardingResponse
    {
        list($response) = $this->getGuildsOnboardingWithHttpInfo($guild_id, $contentType);
        return $response;
    }

    /**
     * Operation getGuildsOnboardingWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildsOnboarding'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\UserGuildOnboardingResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuildsOnboardingWithHttpInfo(
        string $guild_id,
        string $contentType = self::contentTypes['getGuildsOnboarding'][0]
    ): array
    {
        $request = $this->getGuildsOnboardingRequest($guild_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\UserGuildOnboardingResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\UserGuildOnboardingResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\UserGuildOnboardingResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\UserGuildOnboardingResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\UserGuildOnboardingResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getGuildsOnboardingAsync
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildsOnboarding'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildsOnboardingAsync(
        string $guild_id,
        string $contentType = self::contentTypes['getGuildsOnboarding'][0]
    ): PromiseInterface
    {
        return $this->getGuildsOnboardingAsyncWithHttpInfo($guild_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuildsOnboardingAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildsOnboarding'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getGuildsOnboardingAsyncWithHttpInfo(
        $guild_id,
        string $contentType = self::contentTypes['getGuildsOnboarding'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\UserGuildOnboardingResponse';
        $request = $this->getGuildsOnboardingRequest($guild_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuildsOnboarding'
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGuildsOnboarding'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGuildsOnboardingRequest(
        $guild_id,
        string $contentType = self::contentTypes['getGuildsOnboarding'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling getGuildsOnboarding'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.getGuildsOnboarding, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/onboarding';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMessage
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $message_id message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessage'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\MessageResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getMessage(
        string $channel_id,
        string $message_id,
        string $contentType = self::contentTypes['getMessage'][0]
    ): \OpenAPI\Client\Model\MessageResponse
    {
        list($response) = $this->getMessageWithHttpInfo($channel_id, $message_id, $contentType);
        return $response;
    }

    /**
     * Operation getMessageWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessage'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MessageResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMessageWithHttpInfo(
        string $channel_id,
        string $message_id,
        string $contentType = self::contentTypes['getMessage'][0]
    ): array
    {
        $request = $this->getMessageRequest($channel_id, $message_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\MessageResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\MessageResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MessageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\MessageResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MessageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getMessageAsync
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getMessageAsync(
        string $channel_id,
        string $message_id,
        string $contentType = self::contentTypes['getMessage'][0]
    ): PromiseInterface
    {
        return $this->getMessageAsyncWithHttpInfo($channel_id, $message_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMessageAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getMessageAsyncWithHttpInfo(
        $channel_id,
        $message_id,
        string $contentType = self::contentTypes['getMessage'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\MessageResponse';
        $request = $this->getMessageRequest($channel_id, $message_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMessage'
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMessageRequest(
        $channel_id,
        $message_id,
        string $contentType = self::contentTypes['getMessage'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling getMessage'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.getMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $message_id when calling getMessage'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $message_id)) {
            throw new InvalidArgumentException("invalid value for \"message_id\" when calling DefaultAPI.getMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/channels/{channel_id}/messages/{message_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'message_id' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMyApplication
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyApplication'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\PrivateApplicationResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getMyApplication(
        string $contentType = self::contentTypes['getMyApplication'][0]
    ): \OpenAPI\Client\Model\PrivateApplicationResponse
    {
        list($response) = $this->getMyApplicationWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getMyApplicationWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyApplication'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PrivateApplicationResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMyApplicationWithHttpInfo(
        string $contentType = self::contentTypes['getMyApplication'][0]
    ): array
    {
        $request = $this->getMyApplicationRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PrivateApplicationResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PrivateApplicationResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PrivateApplicationResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\PrivateApplicationResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PrivateApplicationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getMyApplicationAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyApplication'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getMyApplicationAsync(
        string $contentType = self::contentTypes['getMyApplication'][0]
    ): PromiseInterface
    {
        return $this->getMyApplicationAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMyApplicationAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyApplication'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getMyApplicationAsyncWithHttpInfo(
        string $contentType = self::contentTypes['getMyApplication'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\PrivateApplicationResponse';
        $request = $this->getMyApplicationRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMyApplication'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyApplication'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMyApplicationRequest(
        string $contentType = self::contentTypes['getMyApplication'][0]
    ): Request
    {


        $resourcePath = '/applications/@me';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMyGuildMember
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyGuildMember'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\PrivateGuildMemberResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getMyGuildMember(
        string $guild_id,
        string $contentType = self::contentTypes['getMyGuildMember'][0]
    ): \OpenAPI\Client\Model\PrivateGuildMemberResponse
    {
        list($response) = $this->getMyGuildMemberWithHttpInfo($guild_id, $contentType);
        return $response;
    }

    /**
     * Operation getMyGuildMemberWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyGuildMember'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PrivateGuildMemberResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMyGuildMemberWithHttpInfo(
        string $guild_id,
        string $contentType = self::contentTypes['getMyGuildMember'][0]
    ): array
    {
        $request = $this->getMyGuildMemberRequest($guild_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PrivateGuildMemberResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PrivateGuildMemberResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PrivateGuildMemberResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\PrivateGuildMemberResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PrivateGuildMemberResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getMyGuildMemberAsync
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyGuildMember'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getMyGuildMemberAsync(
        string $guild_id,
        string $contentType = self::contentTypes['getMyGuildMember'][0]
    ): PromiseInterface
    {
        return $this->getMyGuildMemberAsyncWithHttpInfo($guild_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMyGuildMemberAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyGuildMember'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getMyGuildMemberAsyncWithHttpInfo(
        $guild_id,
        string $contentType = self::contentTypes['getMyGuildMember'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\PrivateGuildMemberResponse';
        $request = $this->getMyGuildMemberRequest($guild_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMyGuildMember'
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyGuildMember'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMyGuildMemberRequest(
        $guild_id,
        string $contentType = self::contentTypes['getMyGuildMember'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling getMyGuildMember'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.getMyGuildMember, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/users/@me/guilds/{guild_id}/member';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMyOauth2Application
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyOauth2Application'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\PrivateApplicationResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getMyOauth2Application(
        string $contentType = self::contentTypes['getMyOauth2Application'][0]
    ): \OpenAPI\Client\Model\PrivateApplicationResponse
    {
        list($response) = $this->getMyOauth2ApplicationWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getMyOauth2ApplicationWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyOauth2Application'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PrivateApplicationResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMyOauth2ApplicationWithHttpInfo(
        string $contentType = self::contentTypes['getMyOauth2Application'][0]
    ): array
    {
        $request = $this->getMyOauth2ApplicationRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PrivateApplicationResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PrivateApplicationResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PrivateApplicationResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\PrivateApplicationResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PrivateApplicationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getMyOauth2ApplicationAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyOauth2Application'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getMyOauth2ApplicationAsync(
        string $contentType = self::contentTypes['getMyOauth2Application'][0]
    ): PromiseInterface
    {
        return $this->getMyOauth2ApplicationAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMyOauth2ApplicationAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyOauth2Application'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getMyOauth2ApplicationAsyncWithHttpInfo(
        string $contentType = self::contentTypes['getMyOauth2Application'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\PrivateApplicationResponse';
        $request = $this->getMyOauth2ApplicationRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMyOauth2Application'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyOauth2Application'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMyOauth2ApplicationRequest(
        string $contentType = self::contentTypes['getMyOauth2Application'][0]
    ): Request
    {


        $resourcePath = '/oauth2/applications/@me';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMyOauth2Authorization
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyOauth2Authorization'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\OAuth2GetAuthorizationResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getMyOauth2Authorization(
        string $contentType = self::contentTypes['getMyOauth2Authorization'][0]
    ): \OpenAPI\Client\Model\OAuth2GetAuthorizationResponse
    {
        list($response) = $this->getMyOauth2AuthorizationWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getMyOauth2AuthorizationWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyOauth2Authorization'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OAuth2GetAuthorizationResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMyOauth2AuthorizationWithHttpInfo(
        string $contentType = self::contentTypes['getMyOauth2Authorization'][0]
    ): array
    {
        $request = $this->getMyOauth2AuthorizationRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OAuth2GetAuthorizationResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\OAuth2GetAuthorizationResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OAuth2GetAuthorizationResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\OAuth2GetAuthorizationResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OAuth2GetAuthorizationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getMyOauth2AuthorizationAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyOauth2Authorization'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getMyOauth2AuthorizationAsync(
        string $contentType = self::contentTypes['getMyOauth2Authorization'][0]
    ): PromiseInterface
    {
        return $this->getMyOauth2AuthorizationAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMyOauth2AuthorizationAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyOauth2Authorization'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getMyOauth2AuthorizationAsyncWithHttpInfo(
        string $contentType = self::contentTypes['getMyOauth2Authorization'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\OAuth2GetAuthorizationResponse';
        $request = $this->getMyOauth2AuthorizationRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMyOauth2Authorization'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyOauth2Authorization'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMyOauth2AuthorizationRequest(
        string $contentType = self::contentTypes['getMyOauth2Authorization'][0]
    ): Request
    {


        $resourcePath = '/oauth2/@me';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMyUser
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyUser'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\UserPIIResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getMyUser(
        string $contentType = self::contentTypes['getMyUser'][0]
    ): \OpenAPI\Client\Model\UserPIIResponse
    {
        list($response) = $this->getMyUserWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getMyUserWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyUser'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\UserPIIResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMyUserWithHttpInfo(
        string $contentType = self::contentTypes['getMyUser'][0]
    ): array
    {
        $request = $this->getMyUserRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\UserPIIResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\UserPIIResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\UserPIIResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\UserPIIResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\UserPIIResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getMyUserAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyUser'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getMyUserAsync(
        string $contentType = self::contentTypes['getMyUser'][0]
    ): PromiseInterface
    {
        return $this->getMyUserAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMyUserAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyUser'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getMyUserAsyncWithHttpInfo(
        string $contentType = self::contentTypes['getMyUser'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\UserPIIResponse';
        $request = $this->getMyUserRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMyUser'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyUser'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMyUserRequest(
        string $contentType = self::contentTypes['getMyUser'][0]
    ): Request
    {


        $resourcePath = '/users/@me';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOriginalWebhookMessage
     *
     * @param  string $webhook_id webhook_id (required)
     * @param  string $webhook_token webhook_token (required)
     * @param  string|null $thread_id thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOriginalWebhookMessage'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\MessageResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getOriginalWebhookMessage(
        string $webhook_id,
        string $webhook_token,
        ?string $thread_id = null,
        string $contentType = self::contentTypes['getOriginalWebhookMessage'][0]
    ): \OpenAPI\Client\Model\MessageResponse
    {
        list($response) = $this->getOriginalWebhookMessageWithHttpInfo($webhook_id, $webhook_token, $thread_id, $contentType);
        return $response;
    }

    /**
     * Operation getOriginalWebhookMessageWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  string $webhook_token (required)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOriginalWebhookMessage'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MessageResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOriginalWebhookMessageWithHttpInfo(
        string $webhook_id,
        string $webhook_token,
        ?string $thread_id = null,
        string $contentType = self::contentTypes['getOriginalWebhookMessage'][0]
    ): array
    {
        $request = $this->getOriginalWebhookMessageRequest($webhook_id, $webhook_token, $thread_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\MessageResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\MessageResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MessageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\MessageResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MessageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getOriginalWebhookMessageAsync
     *
     * @param  string $webhook_id (required)
     * @param  string $webhook_token (required)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOriginalWebhookMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getOriginalWebhookMessageAsync(
        string $webhook_id,
        string $webhook_token,
        ?string $thread_id = null,
        string $contentType = self::contentTypes['getOriginalWebhookMessage'][0]
    ): PromiseInterface
    {
        return $this->getOriginalWebhookMessageAsyncWithHttpInfo($webhook_id, $webhook_token, $thread_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOriginalWebhookMessageAsyncWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  string $webhook_token (required)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOriginalWebhookMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getOriginalWebhookMessageAsyncWithHttpInfo(
        $webhook_id,
        $webhook_token,
        $thread_id = null,
        string $contentType = self::contentTypes['getOriginalWebhookMessage'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\MessageResponse';
        $request = $this->getOriginalWebhookMessageRequest($webhook_id, $webhook_token, $thread_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOriginalWebhookMessage'
     *
     * @param  string $webhook_id (required)
     * @param  string $webhook_token (required)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOriginalWebhookMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOriginalWebhookMessageRequest(
        $webhook_id,
        $webhook_token,
        $thread_id = null,
        string $contentType = self::contentTypes['getOriginalWebhookMessage'][0]
    ): Request
    {

        // verify the required parameter 'webhook_id' is set
        if ($webhook_id === null || (is_array($webhook_id) && count($webhook_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webhook_id when calling getOriginalWebhookMessage'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $webhook_id)) {
            throw new InvalidArgumentException("invalid value for \"webhook_id\" when calling DefaultAPI.getOriginalWebhookMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'webhook_token' is set
        if ($webhook_token === null || (is_array($webhook_token) && count($webhook_token) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webhook_token when calling getOriginalWebhookMessage'
            );
        }
        if (strlen($webhook_token) > 152133) {
            throw new InvalidArgumentException('invalid length for "$webhook_token" when calling DefaultAPI.getOriginalWebhookMessage, must be smaller than or equal to 152133.');
        }
        
        if ($thread_id !== null && !preg_match("/^(0|[1-9][0-9]*)$/", $thread_id)) {
            throw new InvalidArgumentException("invalid value for \"thread_id\" when calling DefaultAPI.getOriginalWebhookMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/webhooks/{webhook_id}/{webhook_token}/messages/@original';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $thread_id,
            'thread_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($webhook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_id' . '}',
                ObjectSerializer::toPathValue($webhook_id),
                $resourcePath
            );
        }
        // path params
        if ($webhook_token !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_token' . '}',
                ObjectSerializer::toPathValue($webhook_token),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStageInstance
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStageInstance'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\StageInstanceResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getStageInstance(
        string $channel_id,
        string $contentType = self::contentTypes['getStageInstance'][0]
    ): \OpenAPI\Client\Model\StageInstanceResponse
    {
        list($response) = $this->getStageInstanceWithHttpInfo($channel_id, $contentType);
        return $response;
    }

    /**
     * Operation getStageInstanceWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStageInstance'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\StageInstanceResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStageInstanceWithHttpInfo(
        string $channel_id,
        string $contentType = self::contentTypes['getStageInstance'][0]
    ): array
    {
        $request = $this->getStageInstanceRequest($channel_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\StageInstanceResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\StageInstanceResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\StageInstanceResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\StageInstanceResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StageInstanceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getStageInstanceAsync
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStageInstance'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getStageInstanceAsync(
        string $channel_id,
        string $contentType = self::contentTypes['getStageInstance'][0]
    ): PromiseInterface
    {
        return $this->getStageInstanceAsyncWithHttpInfo($channel_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStageInstanceAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStageInstance'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getStageInstanceAsyncWithHttpInfo(
        $channel_id,
        string $contentType = self::contentTypes['getStageInstance'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\StageInstanceResponse';
        $request = $this->getStageInstanceRequest($channel_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStageInstance'
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStageInstance'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getStageInstanceRequest(
        $channel_id,
        string $contentType = self::contentTypes['getStageInstance'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling getStageInstance'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.getStageInstance, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/stage-instances/{channel_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSticker
     *
     * @param  string $sticker_id sticker_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSticker'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetSticker200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getSticker(
        string $sticker_id,
        string $contentType = self::contentTypes['getSticker'][0]
    ): \OpenAPI\Client\Model\GetSticker200Response
    {
        list($response) = $this->getStickerWithHttpInfo($sticker_id, $contentType);
        return $response;
    }

    /**
     * Operation getStickerWithHttpInfo
     *
     * @param  string $sticker_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSticker'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetSticker200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStickerWithHttpInfo(
        string $sticker_id,
        string $contentType = self::contentTypes['getSticker'][0]
    ): array
    {
        $request = $this->getStickerRequest($sticker_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetSticker200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetSticker200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetSticker200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GetSticker200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetSticker200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getStickerAsync
     *
     * @param  string $sticker_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSticker'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getStickerAsync(
        string $sticker_id,
        string $contentType = self::contentTypes['getSticker'][0]
    ): PromiseInterface
    {
        return $this->getStickerAsyncWithHttpInfo($sticker_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStickerAsyncWithHttpInfo
     *
     * @param  string $sticker_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSticker'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getStickerAsyncWithHttpInfo(
        $sticker_id,
        string $contentType = self::contentTypes['getSticker'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GetSticker200Response';
        $request = $this->getStickerRequest($sticker_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSticker'
     *
     * @param  string $sticker_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSticker'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getStickerRequest(
        $sticker_id,
        string $contentType = self::contentTypes['getSticker'][0]
    ): Request
    {

        // verify the required parameter 'sticker_id' is set
        if ($sticker_id === null || (is_array($sticker_id) && count($sticker_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sticker_id when calling getSticker'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $sticker_id)) {
            throw new InvalidArgumentException("invalid value for \"sticker_id\" when calling DefaultAPI.getSticker, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/stickers/{sticker_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sticker_id !== null) {
            $resourcePath = str_replace(
                '{' . 'sticker_id' . '}',
                ObjectSerializer::toPathValue($sticker_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getThreadMember
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $user_id user_id (required)
     * @param  bool|null $with_member with_member (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getThreadMember'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ThreadMemberResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getThreadMember(
        string $channel_id,
        string $user_id,
        ?bool $with_member = null,
        string $contentType = self::contentTypes['getThreadMember'][0]
    ): \OpenAPI\Client\Model\ThreadMemberResponse
    {
        list($response) = $this->getThreadMemberWithHttpInfo($channel_id, $user_id, $with_member, $contentType);
        return $response;
    }

    /**
     * Operation getThreadMemberWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $user_id (required)
     * @param  bool|null $with_member (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getThreadMember'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ThreadMemberResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getThreadMemberWithHttpInfo(
        string $channel_id,
        string $user_id,
        ?bool $with_member = null,
        string $contentType = self::contentTypes['getThreadMember'][0]
    ): array
    {
        $request = $this->getThreadMemberRequest($channel_id, $user_id, $with_member, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ThreadMemberResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ThreadMemberResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ThreadMemberResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ThreadMemberResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ThreadMemberResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getThreadMemberAsync
     *
     * @param  string $channel_id (required)
     * @param  string $user_id (required)
     * @param  bool|null $with_member (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getThreadMember'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getThreadMemberAsync(
        string $channel_id,
        string $user_id,
        ?bool $with_member = null,
        string $contentType = self::contentTypes['getThreadMember'][0]
    ): PromiseInterface
    {
        return $this->getThreadMemberAsyncWithHttpInfo($channel_id, $user_id, $with_member, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getThreadMemberAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $user_id (required)
     * @param  bool|null $with_member (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getThreadMember'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getThreadMemberAsyncWithHttpInfo(
        $channel_id,
        $user_id,
        $with_member = null,
        string $contentType = self::contentTypes['getThreadMember'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ThreadMemberResponse';
        $request = $this->getThreadMemberRequest($channel_id, $user_id, $with_member, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getThreadMember'
     *
     * @param  string $channel_id (required)
     * @param  string $user_id (required)
     * @param  bool|null $with_member (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getThreadMember'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getThreadMemberRequest(
        $channel_id,
        $user_id,
        $with_member = null,
        string $contentType = self::contentTypes['getThreadMember'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling getThreadMember'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.getThreadMember, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $user_id when calling getThreadMember'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $user_id)) {
            throw new InvalidArgumentException("invalid value for \"user_id\" when calling DefaultAPI.getThreadMember, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        


        $resourcePath = '/channels/{channel_id}/thread-members/{user_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_member,
            'with_member', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUser
     *
     * @param  string $user_id user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUser'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\UserResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getUser(
        string $user_id,
        string $contentType = self::contentTypes['getUser'][0]
    ): \OpenAPI\Client\Model\UserResponse
    {
        list($response) = $this->getUserWithHttpInfo($user_id, $contentType);
        return $response;
    }

    /**
     * Operation getUserWithHttpInfo
     *
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUser'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\UserResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getUserWithHttpInfo(
        string $user_id,
        string $contentType = self::contentTypes['getUser'][0]
    ): array
    {
        $request = $this->getUserRequest($user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\UserResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\UserResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\UserResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\UserResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\UserResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getUserAsync
     *
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUser'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getUserAsync(
        string $user_id,
        string $contentType = self::contentTypes['getUser'][0]
    ): PromiseInterface
    {
        return $this->getUserAsyncWithHttpInfo($user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUserAsyncWithHttpInfo
     *
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUser'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getUserAsyncWithHttpInfo(
        $user_id,
        string $contentType = self::contentTypes['getUser'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\UserResponse';
        $request = $this->getUserRequest($user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUser'
     *
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getUser'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getUserRequest(
        $user_id,
        string $contentType = self::contentTypes['getUser'][0]
    ): Request
    {

        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $user_id when calling getUser'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $user_id)) {
            throw new InvalidArgumentException("invalid value for \"user_id\" when calling DefaultAPI.getUser, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/users/{user_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWebhook
     *
     * @param  string $webhook_id webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhook'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getWebhook(
        string $webhook_id,
        string $contentType = self::contentTypes['getWebhook'][0]
    ): \OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner
    {
        list($response) = $this->getWebhookWithHttpInfo($webhook_id, $contentType);
        return $response;
    }

    /**
     * Operation getWebhookWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhook'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWebhookWithHttpInfo(
        string $webhook_id,
        string $contentType = self::contentTypes['getWebhook'][0]
    ): array
    {
        $request = $this->getWebhookRequest($webhook_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getWebhookAsync
     *
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhook'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getWebhookAsync(
        string $webhook_id,
        string $contentType = self::contentTypes['getWebhook'][0]
    ): PromiseInterface
    {
        return $this->getWebhookAsyncWithHttpInfo($webhook_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWebhookAsyncWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhook'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getWebhookAsyncWithHttpInfo(
        $webhook_id,
        string $contentType = self::contentTypes['getWebhook'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner';
        $request = $this->getWebhookRequest($webhook_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWebhook'
     *
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhook'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getWebhookRequest(
        $webhook_id,
        string $contentType = self::contentTypes['getWebhook'][0]
    ): Request
    {

        // verify the required parameter 'webhook_id' is set
        if ($webhook_id === null || (is_array($webhook_id) && count($webhook_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webhook_id when calling getWebhook'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $webhook_id)) {
            throw new InvalidArgumentException("invalid value for \"webhook_id\" when calling DefaultAPI.getWebhook, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/webhooks/{webhook_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webhook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_id' . '}',
                ObjectSerializer::toPathValue($webhook_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWebhookByToken
     *
     * @param  string $webhook_id webhook_id (required)
     * @param  mixed $webhook_token webhook_token (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookByToken'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getWebhookByToken(
        string $webhook_id,
        mixed $webhook_token,
        string $contentType = self::contentTypes['getWebhookByToken'][0]
    ): \OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner
    {
        list($response) = $this->getWebhookByTokenWithHttpInfo($webhook_id, $webhook_token, $contentType);
        return $response;
    }

    /**
     * Operation getWebhookByTokenWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookByToken'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWebhookByTokenWithHttpInfo(
        string $webhook_id,
        mixed $webhook_token,
        string $contentType = self::contentTypes['getWebhookByToken'][0]
    ): array
    {
        $request = $this->getWebhookByTokenRequest($webhook_id, $webhook_token, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getWebhookByTokenAsync
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookByToken'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getWebhookByTokenAsync(
        string $webhook_id,
        mixed $webhook_token,
        string $contentType = self::contentTypes['getWebhookByToken'][0]
    ): PromiseInterface
    {
        return $this->getWebhookByTokenAsyncWithHttpInfo($webhook_id, $webhook_token, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWebhookByTokenAsyncWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookByToken'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getWebhookByTokenAsyncWithHttpInfo(
        $webhook_id,
        $webhook_token,
        string $contentType = self::contentTypes['getWebhookByToken'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner';
        $request = $this->getWebhookByTokenRequest($webhook_id, $webhook_token, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWebhookByToken'
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookByToken'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getWebhookByTokenRequest(
        $webhook_id,
        $webhook_token,
        string $contentType = self::contentTypes['getWebhookByToken'][0]
    ): Request
    {

        // verify the required parameter 'webhook_id' is set
        if ($webhook_id === null || (is_array($webhook_id) && count($webhook_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webhook_id when calling getWebhookByToken'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $webhook_id)) {
            throw new InvalidArgumentException("invalid value for \"webhook_id\" when calling DefaultAPI.getWebhookByToken, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'webhook_token' is set
        if ($webhook_token === null || (is_array($webhook_token) && count($webhook_token) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webhook_token when calling getWebhookByToken'
            );
        }
        if (strlen($webhook_token) > 152133) {
            throw new InvalidArgumentException('invalid length for "$webhook_token" when calling DefaultAPI.getWebhookByToken, must be smaller than or equal to 152133.');
        }
        

        $resourcePath = '/webhooks/{webhook_id}/{webhook_token}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webhook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_id' . '}',
                ObjectSerializer::toPathValue($webhook_id),
                $resourcePath
            );
        }
        // path params
        if ($webhook_token !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_token' . '}',
                ObjectSerializer::toPathValue($webhook_token),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWebhookMessage
     *
     * @param  string $webhook_id webhook_id (required)
     * @param  mixed $webhook_token webhook_token (required)
     * @param  string $message_id message_id (required)
     * @param  string|null $thread_id thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookMessage'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\MessageResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function getWebhookMessage(
        string $webhook_id,
        mixed $webhook_token,
        string $message_id,
        ?string $thread_id = null,
        string $contentType = self::contentTypes['getWebhookMessage'][0]
    ): \OpenAPI\Client\Model\MessageResponse
    {
        list($response) = $this->getWebhookMessageWithHttpInfo($webhook_id, $webhook_token, $message_id, $thread_id, $contentType);
        return $response;
    }

    /**
     * Operation getWebhookMessageWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  string $message_id (required)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookMessage'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MessageResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWebhookMessageWithHttpInfo(
        string $webhook_id,
        mixed $webhook_token,
        string $message_id,
        ?string $thread_id = null,
        string $contentType = self::contentTypes['getWebhookMessage'][0]
    ): array
    {
        $request = $this->getWebhookMessageRequest($webhook_id, $webhook_token, $message_id, $thread_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\MessageResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\MessageResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MessageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\MessageResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MessageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation getWebhookMessageAsync
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  string $message_id (required)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getWebhookMessageAsync(
        string $webhook_id,
        mixed $webhook_token,
        string $message_id,
        ?string $thread_id = null,
        string $contentType = self::contentTypes['getWebhookMessage'][0]
    ): PromiseInterface
    {
        return $this->getWebhookMessageAsyncWithHttpInfo($webhook_id, $webhook_token, $message_id, $thread_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWebhookMessageAsyncWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  string $message_id (required)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getWebhookMessageAsyncWithHttpInfo(
        $webhook_id,
        $webhook_token,
        $message_id,
        $thread_id = null,
        string $contentType = self::contentTypes['getWebhookMessage'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\MessageResponse';
        $request = $this->getWebhookMessageRequest($webhook_id, $webhook_token, $message_id, $thread_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWebhookMessage'
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  string $message_id (required)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getWebhookMessageRequest(
        $webhook_id,
        $webhook_token,
        $message_id,
        $thread_id = null,
        string $contentType = self::contentTypes['getWebhookMessage'][0]
    ): Request
    {

        // verify the required parameter 'webhook_id' is set
        if ($webhook_id === null || (is_array($webhook_id) && count($webhook_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webhook_id when calling getWebhookMessage'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $webhook_id)) {
            throw new InvalidArgumentException("invalid value for \"webhook_id\" when calling DefaultAPI.getWebhookMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'webhook_token' is set
        if ($webhook_token === null || (is_array($webhook_token) && count($webhook_token) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webhook_token when calling getWebhookMessage'
            );
        }
        if (strlen($webhook_token) > 152133) {
            throw new InvalidArgumentException('invalid length for "$webhook_token" when calling DefaultAPI.getWebhookMessage, must be smaller than or equal to 152133.');
        }
        
        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $message_id when calling getWebhookMessage'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $message_id)) {
            throw new InvalidArgumentException("invalid value for \"message_id\" when calling DefaultAPI.getWebhookMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        if ($thread_id !== null && !preg_match("/^(0|[1-9][0-9]*)$/", $thread_id)) {
            throw new InvalidArgumentException("invalid value for \"thread_id\" when calling DefaultAPI.getWebhookMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/webhooks/{webhook_id}/{webhook_token}/messages/{message_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $thread_id,
            'thread_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($webhook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_id' . '}',
                ObjectSerializer::toPathValue($webhook_id),
                $resourcePath
            );
        }
        // path params
        if ($webhook_token !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_token' . '}',
                ObjectSerializer::toPathValue($webhook_token),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'message_id' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inviteResolve
     *
     * @param  mixed $code code (required)
     * @param  bool|null $with_counts with_counts (optional)
     * @param  string|null $guild_scheduled_event_id guild_scheduled_event_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['inviteResolve'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListChannelInvites200ResponseInner|\OpenAPI\Client\Model\ErrorResponse
     */
    public function inviteResolve(
        mixed $code,
        ?bool $with_counts = null,
        ?string $guild_scheduled_event_id = null,
        string $contentType = self::contentTypes['inviteResolve'][0]
    ): \OpenAPI\Client\Model\ListChannelInvites200ResponseInner
    {
        list($response) = $this->inviteResolveWithHttpInfo($code, $with_counts, $guild_scheduled_event_id, $contentType);
        return $response;
    }

    /**
     * Operation inviteResolveWithHttpInfo
     *
     * @param  mixed $code (required)
     * @param  bool|null $with_counts (optional)
     * @param  string|null $guild_scheduled_event_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['inviteResolve'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListChannelInvites200ResponseInner|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function inviteResolveWithHttpInfo(
        mixed $code,
        ?bool $with_counts = null,
        ?string $guild_scheduled_event_id = null,
        string $contentType = self::contentTypes['inviteResolve'][0]
    ): array
    {
        $request = $this->inviteResolveRequest($code, $with_counts, $guild_scheduled_event_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListChannelInvites200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListChannelInvites200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListChannelInvites200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ListChannelInvites200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListChannelInvites200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation inviteResolveAsync
     *
     * @param  mixed $code (required)
     * @param  bool|null $with_counts (optional)
     * @param  string|null $guild_scheduled_event_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['inviteResolve'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function inviteResolveAsync(
        mixed $code,
        ?bool $with_counts = null,
        ?string $guild_scheduled_event_id = null,
        string $contentType = self::contentTypes['inviteResolve'][0]
    ): PromiseInterface
    {
        return $this->inviteResolveAsyncWithHttpInfo($code, $with_counts, $guild_scheduled_event_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inviteResolveAsyncWithHttpInfo
     *
     * @param  mixed $code (required)
     * @param  bool|null $with_counts (optional)
     * @param  string|null $guild_scheduled_event_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['inviteResolve'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function inviteResolveAsyncWithHttpInfo(
        $code,
        $with_counts = null,
        $guild_scheduled_event_id = null,
        string $contentType = self::contentTypes['inviteResolve'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ListChannelInvites200ResponseInner';
        $request = $this->inviteResolveRequest($code, $with_counts, $guild_scheduled_event_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inviteResolve'
     *
     * @param  mixed $code (required)
     * @param  bool|null $with_counts (optional)
     * @param  string|null $guild_scheduled_event_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['inviteResolve'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function inviteResolveRequest(
        $code,
        $with_counts = null,
        $guild_scheduled_event_id = null,
        string $contentType = self::contentTypes['inviteResolve'][0]
    ): Request
    {

        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $code when calling inviteResolve'
            );
        }
        if (strlen($code) > 152133) {
            throw new InvalidArgumentException('invalid length for "$code" when calling DefaultAPI.inviteResolve, must be smaller than or equal to 152133.');
        }
        

        if ($guild_scheduled_event_id !== null && !preg_match("/^(0|[1-9][0-9]*)$/", $guild_scheduled_event_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_scheduled_event_id\" when calling DefaultAPI.inviteResolve, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/invites/{code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_counts,
            'with_counts', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $guild_scheduled_event_id,
            'guild_scheduled_event_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inviteRevoke
     *
     * @param  mixed $code code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['inviteRevoke'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListChannelInvites200ResponseInner|\OpenAPI\Client\Model\ErrorResponse
     */
    public function inviteRevoke(
        mixed $code,
        string $contentType = self::contentTypes['inviteRevoke'][0]
    ): \OpenAPI\Client\Model\ListChannelInvites200ResponseInner
    {
        list($response) = $this->inviteRevokeWithHttpInfo($code, $contentType);
        return $response;
    }

    /**
     * Operation inviteRevokeWithHttpInfo
     *
     * @param  mixed $code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['inviteRevoke'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListChannelInvites200ResponseInner|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function inviteRevokeWithHttpInfo(
        mixed $code,
        string $contentType = self::contentTypes['inviteRevoke'][0]
    ): array
    {
        $request = $this->inviteRevokeRequest($code, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListChannelInvites200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListChannelInvites200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListChannelInvites200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ListChannelInvites200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListChannelInvites200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation inviteRevokeAsync
     *
     * @param  mixed $code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['inviteRevoke'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function inviteRevokeAsync(
        mixed $code,
        string $contentType = self::contentTypes['inviteRevoke'][0]
    ): PromiseInterface
    {
        return $this->inviteRevokeAsyncWithHttpInfo($code, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inviteRevokeAsyncWithHttpInfo
     *
     * @param  mixed $code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['inviteRevoke'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function inviteRevokeAsyncWithHttpInfo(
        $code,
        string $contentType = self::contentTypes['inviteRevoke'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ListChannelInvites200ResponseInner';
        $request = $this->inviteRevokeRequest($code, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inviteRevoke'
     *
     * @param  mixed $code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['inviteRevoke'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function inviteRevokeRequest(
        $code,
        string $contentType = self::contentTypes['inviteRevoke'][0]
    ): Request
    {

        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $code when calling inviteRevoke'
            );
        }
        if (strlen($code) > 152133) {
            throw new InvalidArgumentException('invalid length for "$code" when calling DefaultAPI.inviteRevoke, must be smaller than or equal to 152133.');
        }
        

        $resourcePath = '/invites/{code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation joinThread
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['joinThread'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function joinThread(
        string $channel_id,
        string $contentType = self::contentTypes['joinThread'][0]
    ): void
    {
        $this->joinThreadWithHttpInfo($channel_id, $contentType);
    }

    /**
     * Operation joinThreadWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['joinThread'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function joinThreadWithHttpInfo(
        string $channel_id,
        string $contentType = self::contentTypes['joinThread'][0]
    ): array
    {
        $request = $this->joinThreadRequest($channel_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation joinThreadAsync
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['joinThread'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function joinThreadAsync(
        string $channel_id,
        string $contentType = self::contentTypes['joinThread'][0]
    ): PromiseInterface
    {
        return $this->joinThreadAsyncWithHttpInfo($channel_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation joinThreadAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['joinThread'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function joinThreadAsyncWithHttpInfo(
        $channel_id,
        string $contentType = self::contentTypes['joinThread'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->joinThreadRequest($channel_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'joinThread'
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['joinThread'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function joinThreadRequest(
        $channel_id,
        string $contentType = self::contentTypes['joinThread'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling joinThread'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.joinThread, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/channels/{channel_id}/thread-members/@me';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation leaveGuild
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveGuild'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function leaveGuild(
        string $guild_id,
        string $contentType = self::contentTypes['leaveGuild'][0]
    ): void
    {
        $this->leaveGuildWithHttpInfo($guild_id, $contentType);
    }

    /**
     * Operation leaveGuildWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveGuild'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function leaveGuildWithHttpInfo(
        string $guild_id,
        string $contentType = self::contentTypes['leaveGuild'][0]
    ): array
    {
        $request = $this->leaveGuildRequest($guild_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation leaveGuildAsync
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveGuild'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function leaveGuildAsync(
        string $guild_id,
        string $contentType = self::contentTypes['leaveGuild'][0]
    ): PromiseInterface
    {
        return $this->leaveGuildAsyncWithHttpInfo($guild_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation leaveGuildAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveGuild'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function leaveGuildAsyncWithHttpInfo(
        $guild_id,
        string $contentType = self::contentTypes['leaveGuild'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->leaveGuildRequest($guild_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'leaveGuild'
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveGuild'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function leaveGuildRequest(
        $guild_id,
        string $contentType = self::contentTypes['leaveGuild'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling leaveGuild'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.leaveGuild, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/users/@me/guilds/{guild_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation leaveThread
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveThread'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function leaveThread(
        string $channel_id,
        string $contentType = self::contentTypes['leaveThread'][0]
    ): void
    {
        $this->leaveThreadWithHttpInfo($channel_id, $contentType);
    }

    /**
     * Operation leaveThreadWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveThread'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function leaveThreadWithHttpInfo(
        string $channel_id,
        string $contentType = self::contentTypes['leaveThread'][0]
    ): array
    {
        $request = $this->leaveThreadRequest($channel_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation leaveThreadAsync
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveThread'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function leaveThreadAsync(
        string $channel_id,
        string $contentType = self::contentTypes['leaveThread'][0]
    ): PromiseInterface
    {
        return $this->leaveThreadAsyncWithHttpInfo($channel_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation leaveThreadAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveThread'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function leaveThreadAsyncWithHttpInfo(
        $channel_id,
        string $contentType = self::contentTypes['leaveThread'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->leaveThreadRequest($channel_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'leaveThread'
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['leaveThread'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function leaveThreadRequest(
        $channel_id,
        string $contentType = self::contentTypes['leaveThread'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling leaveThread'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.leaveThread, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/channels/{channel_id}/thread-members/@me';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listApplicationCommands
     *
     * @param  string $application_id application_id (required)
     * @param  bool|null $with_localizations with_localizations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listApplicationCommands'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApplicationCommandResponse[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listApplicationCommands(
        string $application_id,
        ?bool $with_localizations = null,
        string $contentType = self::contentTypes['listApplicationCommands'][0]
    ): array
    {
        list($response) = $this->listApplicationCommandsWithHttpInfo($application_id, $with_localizations, $contentType);
        return $response;
    }

    /**
     * Operation listApplicationCommandsWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  bool|null $with_localizations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listApplicationCommands'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApplicationCommandResponse[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listApplicationCommandsWithHttpInfo(
        string $application_id,
        ?bool $with_localizations = null,
        string $contentType = self::contentTypes['listApplicationCommands'][0]
    ): array
    {
        $request = $this->listApplicationCommandsRequest($application_id, $with_localizations, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ApplicationCommandResponse[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ApplicationCommandResponse[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApplicationCommandResponse[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ApplicationCommandResponse[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApplicationCommandResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listApplicationCommandsAsync
     *
     * @param  string $application_id (required)
     * @param  bool|null $with_localizations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listApplicationCommands'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listApplicationCommandsAsync(
        string $application_id,
        ?bool $with_localizations = null,
        string $contentType = self::contentTypes['listApplicationCommands'][0]
    ): PromiseInterface
    {
        return $this->listApplicationCommandsAsyncWithHttpInfo($application_id, $with_localizations, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listApplicationCommandsAsyncWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  bool|null $with_localizations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listApplicationCommands'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listApplicationCommandsAsyncWithHttpInfo(
        $application_id,
        $with_localizations = null,
        string $contentType = self::contentTypes['listApplicationCommands'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ApplicationCommandResponse[]';
        $request = $this->listApplicationCommandsRequest($application_id, $with_localizations, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listApplicationCommands'
     *
     * @param  string $application_id (required)
     * @param  bool|null $with_localizations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listApplicationCommands'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listApplicationCommandsRequest(
        $application_id,
        $with_localizations = null,
        string $contentType = self::contentTypes['listApplicationCommands'][0]
    ): Request
    {

        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_id when calling listApplicationCommands'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $application_id)) {
            throw new InvalidArgumentException("invalid value for \"application_id\" when calling DefaultAPI.listApplicationCommands, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        


        $resourcePath = '/applications/{application_id}/commands';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_localizations,
            'with_localizations', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'application_id' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listAutoModerationRules
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAutoModerationRules'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListAutoModerationRules200ResponseInner[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listAutoModerationRules(
        string $guild_id,
        string $contentType = self::contentTypes['listAutoModerationRules'][0]
    ): array
    {
        list($response) = $this->listAutoModerationRulesWithHttpInfo($guild_id, $contentType);
        return $response;
    }

    /**
     * Operation listAutoModerationRulesWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAutoModerationRules'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListAutoModerationRules200ResponseInner[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listAutoModerationRulesWithHttpInfo(
        string $guild_id,
        string $contentType = self::contentTypes['listAutoModerationRules'][0]
    ): array
    {
        $request = $this->listAutoModerationRulesRequest($guild_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListAutoModerationRules200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListAutoModerationRules200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListAutoModerationRules200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ListAutoModerationRules200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListAutoModerationRules200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listAutoModerationRulesAsync
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAutoModerationRules'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listAutoModerationRulesAsync(
        string $guild_id,
        string $contentType = self::contentTypes['listAutoModerationRules'][0]
    ): PromiseInterface
    {
        return $this->listAutoModerationRulesAsyncWithHttpInfo($guild_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listAutoModerationRulesAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAutoModerationRules'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listAutoModerationRulesAsyncWithHttpInfo(
        $guild_id,
        string $contentType = self::contentTypes['listAutoModerationRules'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ListAutoModerationRules200ResponseInner[]';
        $request = $this->listAutoModerationRulesRequest($guild_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listAutoModerationRules'
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listAutoModerationRules'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listAutoModerationRulesRequest(
        $guild_id,
        string $contentType = self::contentTypes['listAutoModerationRules'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling listAutoModerationRules'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.listAutoModerationRules, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/auto-moderation/rules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listChannelInvites
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listChannelInvites'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListChannelInvites200ResponseInner[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listChannelInvites(
        string $channel_id,
        string $contentType = self::contentTypes['listChannelInvites'][0]
    ): array
    {
        list($response) = $this->listChannelInvitesWithHttpInfo($channel_id, $contentType);
        return $response;
    }

    /**
     * Operation listChannelInvitesWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listChannelInvites'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListChannelInvites200ResponseInner[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listChannelInvitesWithHttpInfo(
        string $channel_id,
        string $contentType = self::contentTypes['listChannelInvites'][0]
    ): array
    {
        $request = $this->listChannelInvitesRequest($channel_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListChannelInvites200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListChannelInvites200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListChannelInvites200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ListChannelInvites200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListChannelInvites200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listChannelInvitesAsync
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listChannelInvites'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listChannelInvitesAsync(
        string $channel_id,
        string $contentType = self::contentTypes['listChannelInvites'][0]
    ): PromiseInterface
    {
        return $this->listChannelInvitesAsyncWithHttpInfo($channel_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listChannelInvitesAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listChannelInvites'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listChannelInvitesAsyncWithHttpInfo(
        $channel_id,
        string $contentType = self::contentTypes['listChannelInvites'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ListChannelInvites200ResponseInner[]';
        $request = $this->listChannelInvitesRequest($channel_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listChannelInvites'
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listChannelInvites'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listChannelInvitesRequest(
        $channel_id,
        string $contentType = self::contentTypes['listChannelInvites'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling listChannelInvites'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.listChannelInvites, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/channels/{channel_id}/invites';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listChannelWebhooks
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listChannelWebhooks'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listChannelWebhooks(
        string $channel_id,
        string $contentType = self::contentTypes['listChannelWebhooks'][0]
    ): array
    {
        list($response) = $this->listChannelWebhooksWithHttpInfo($channel_id, $contentType);
        return $response;
    }

    /**
     * Operation listChannelWebhooksWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listChannelWebhooks'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listChannelWebhooksWithHttpInfo(
        string $channel_id,
        string $contentType = self::contentTypes['listChannelWebhooks'][0]
    ): array
    {
        $request = $this->listChannelWebhooksRequest($channel_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listChannelWebhooksAsync
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listChannelWebhooks'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listChannelWebhooksAsync(
        string $channel_id,
        string $contentType = self::contentTypes['listChannelWebhooks'][0]
    ): PromiseInterface
    {
        return $this->listChannelWebhooksAsyncWithHttpInfo($channel_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listChannelWebhooksAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listChannelWebhooks'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listChannelWebhooksAsyncWithHttpInfo(
        $channel_id,
        string $contentType = self::contentTypes['listChannelWebhooks'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner[]';
        $request = $this->listChannelWebhooksRequest($channel_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listChannelWebhooks'
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listChannelWebhooks'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listChannelWebhooksRequest(
        $channel_id,
        string $contentType = self::contentTypes['listChannelWebhooks'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling listChannelWebhooks'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.listChannelWebhooks, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/channels/{channel_id}/webhooks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listGuildApplicationCommandPermissions
     *
     * @param  string $application_id application_id (required)
     * @param  string $guild_id guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildApplicationCommandPermissions'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\CommandPermissionsResponse[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listGuildApplicationCommandPermissions(
        string $application_id,
        string $guild_id,
        string $contentType = self::contentTypes['listGuildApplicationCommandPermissions'][0]
    ): array
    {
        list($response) = $this->listGuildApplicationCommandPermissionsWithHttpInfo($application_id, $guild_id, $contentType);
        return $response;
    }

    /**
     * Operation listGuildApplicationCommandPermissionsWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildApplicationCommandPermissions'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CommandPermissionsResponse[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listGuildApplicationCommandPermissionsWithHttpInfo(
        string $application_id,
        string $guild_id,
        string $contentType = self::contentTypes['listGuildApplicationCommandPermissions'][0]
    ): array
    {
        $request = $this->listGuildApplicationCommandPermissionsRequest($application_id, $guild_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CommandPermissionsResponse[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CommandPermissionsResponse[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CommandPermissionsResponse[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\CommandPermissionsResponse[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CommandPermissionsResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listGuildApplicationCommandPermissionsAsync
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildApplicationCommandPermissions'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildApplicationCommandPermissionsAsync(
        string $application_id,
        string $guild_id,
        string $contentType = self::contentTypes['listGuildApplicationCommandPermissions'][0]
    ): PromiseInterface
    {
        return $this->listGuildApplicationCommandPermissionsAsyncWithHttpInfo($application_id, $guild_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listGuildApplicationCommandPermissionsAsyncWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildApplicationCommandPermissions'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildApplicationCommandPermissionsAsyncWithHttpInfo(
        $application_id,
        $guild_id,
        string $contentType = self::contentTypes['listGuildApplicationCommandPermissions'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\CommandPermissionsResponse[]';
        $request = $this->listGuildApplicationCommandPermissionsRequest($application_id, $guild_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listGuildApplicationCommandPermissions'
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildApplicationCommandPermissions'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listGuildApplicationCommandPermissionsRequest(
        $application_id,
        $guild_id,
        string $contentType = self::contentTypes['listGuildApplicationCommandPermissions'][0]
    ): Request
    {

        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_id when calling listGuildApplicationCommandPermissions'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $application_id)) {
            throw new InvalidArgumentException("invalid value for \"application_id\" when calling DefaultAPI.listGuildApplicationCommandPermissions, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling listGuildApplicationCommandPermissions'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.listGuildApplicationCommandPermissions, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/applications/{application_id}/guilds/{guild_id}/commands/permissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'application_id' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listGuildApplicationCommands
     *
     * @param  string $application_id application_id (required)
     * @param  string $guild_id guild_id (required)
     * @param  bool|null $with_localizations with_localizations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildApplicationCommands'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApplicationCommandResponse[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listGuildApplicationCommands(
        string $application_id,
        string $guild_id,
        ?bool $with_localizations = null,
        string $contentType = self::contentTypes['listGuildApplicationCommands'][0]
    ): array
    {
        list($response) = $this->listGuildApplicationCommandsWithHttpInfo($application_id, $guild_id, $with_localizations, $contentType);
        return $response;
    }

    /**
     * Operation listGuildApplicationCommandsWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  bool|null $with_localizations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildApplicationCommands'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApplicationCommandResponse[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listGuildApplicationCommandsWithHttpInfo(
        string $application_id,
        string $guild_id,
        ?bool $with_localizations = null,
        string $contentType = self::contentTypes['listGuildApplicationCommands'][0]
    ): array
    {
        $request = $this->listGuildApplicationCommandsRequest($application_id, $guild_id, $with_localizations, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ApplicationCommandResponse[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ApplicationCommandResponse[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApplicationCommandResponse[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ApplicationCommandResponse[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApplicationCommandResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listGuildApplicationCommandsAsync
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  bool|null $with_localizations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildApplicationCommands'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildApplicationCommandsAsync(
        string $application_id,
        string $guild_id,
        ?bool $with_localizations = null,
        string $contentType = self::contentTypes['listGuildApplicationCommands'][0]
    ): PromiseInterface
    {
        return $this->listGuildApplicationCommandsAsyncWithHttpInfo($application_id, $guild_id, $with_localizations, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listGuildApplicationCommandsAsyncWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  bool|null $with_localizations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildApplicationCommands'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildApplicationCommandsAsyncWithHttpInfo(
        $application_id,
        $guild_id,
        $with_localizations = null,
        string $contentType = self::contentTypes['listGuildApplicationCommands'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ApplicationCommandResponse[]';
        $request = $this->listGuildApplicationCommandsRequest($application_id, $guild_id, $with_localizations, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listGuildApplicationCommands'
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  bool|null $with_localizations (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildApplicationCommands'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listGuildApplicationCommandsRequest(
        $application_id,
        $guild_id,
        $with_localizations = null,
        string $contentType = self::contentTypes['listGuildApplicationCommands'][0]
    ): Request
    {

        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_id when calling listGuildApplicationCommands'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $application_id)) {
            throw new InvalidArgumentException("invalid value for \"application_id\" when calling DefaultAPI.listGuildApplicationCommands, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling listGuildApplicationCommands'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.listGuildApplicationCommands, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        


        $resourcePath = '/applications/{application_id}/guilds/{guild_id}/commands';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_localizations,
            'with_localizations', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'application_id' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listGuildAuditLogEntries
     *
     * @param  string $guild_id guild_id (required)
     * @param  string|null $user_id user_id (optional)
     * @param  int|null $action_type action_type (optional)
     * @param  string|null $before before (optional)
     * @param  string|null $after after (optional)
     * @param  int|null $limit limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildAuditLogEntries'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildAuditLogResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listGuildAuditLogEntries(
        string $guild_id,
        ?string $user_id = null,
        ?int $action_type = null,
        ?string $before = null,
        ?string $after = null,
        ?int $limit = null,
        string $contentType = self::contentTypes['listGuildAuditLogEntries'][0]
    ): \OpenAPI\Client\Model\GuildAuditLogResponse
    {
        list($response) = $this->listGuildAuditLogEntriesWithHttpInfo($guild_id, $user_id, $action_type, $before, $after, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listGuildAuditLogEntriesWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string|null $user_id (optional)
     * @param  int|null $action_type (optional)
     * @param  string|null $before (optional)
     * @param  string|null $after (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildAuditLogEntries'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildAuditLogResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listGuildAuditLogEntriesWithHttpInfo(
        string $guild_id,
        ?string $user_id = null,
        ?int $action_type = null,
        ?string $before = null,
        ?string $after = null,
        ?int $limit = null,
        string $contentType = self::contentTypes['listGuildAuditLogEntries'][0]
    ): array
    {
        $request = $this->listGuildAuditLogEntriesRequest($guild_id, $user_id, $action_type, $before, $after, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildAuditLogResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildAuditLogResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildAuditLogResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildAuditLogResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildAuditLogResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listGuildAuditLogEntriesAsync
     *
     * @param  string $guild_id (required)
     * @param  string|null $user_id (optional)
     * @param  int|null $action_type (optional)
     * @param  string|null $before (optional)
     * @param  string|null $after (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildAuditLogEntries'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildAuditLogEntriesAsync(
        string $guild_id,
        ?string $user_id = null,
        ?int $action_type = null,
        ?string $before = null,
        ?string $after = null,
        ?int $limit = null,
        string $contentType = self::contentTypes['listGuildAuditLogEntries'][0]
    ): PromiseInterface
    {
        return $this->listGuildAuditLogEntriesAsyncWithHttpInfo($guild_id, $user_id, $action_type, $before, $after, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listGuildAuditLogEntriesAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string|null $user_id (optional)
     * @param  int|null $action_type (optional)
     * @param  string|null $before (optional)
     * @param  string|null $after (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildAuditLogEntries'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildAuditLogEntriesAsyncWithHttpInfo(
        $guild_id,
        $user_id = null,
        $action_type = null,
        $before = null,
        $after = null,
        $limit = null,
        string $contentType = self::contentTypes['listGuildAuditLogEntries'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildAuditLogResponse';
        $request = $this->listGuildAuditLogEntriesRequest($guild_id, $user_id, $action_type, $before, $after, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listGuildAuditLogEntries'
     *
     * @param  string $guild_id (required)
     * @param  string|null $user_id (optional)
     * @param  int|null $action_type (optional)
     * @param  string|null $before (optional)
     * @param  string|null $after (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildAuditLogEntries'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listGuildAuditLogEntriesRequest(
        $guild_id,
        $user_id = null,
        $action_type = null,
        $before = null,
        $after = null,
        $limit = null,
        string $contentType = self::contentTypes['listGuildAuditLogEntries'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling listGuildAuditLogEntries'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.listGuildAuditLogEntries, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        if ($user_id !== null && !preg_match("/^(0|[1-9][0-9]*)$/", $user_id)) {
            throw new InvalidArgumentException("invalid value for \"user_id\" when calling DefaultAPI.listGuildAuditLogEntries, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        if ($before !== null && !preg_match("/^(0|[1-9][0-9]*)$/", $before)) {
            throw new InvalidArgumentException("invalid value for \"before\" when calling DefaultAPI.listGuildAuditLogEntries, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        if ($after !== null && !preg_match("/^(0|[1-9][0-9]*)$/", $after)) {
            throw new InvalidArgumentException("invalid value for \"after\" when calling DefaultAPI.listGuildAuditLogEntries, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        if ($limit !== null && $limit > 100) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling DefaultAPI.listGuildAuditLogEntries, must be smaller than or equal to 100.');
        }
        if ($limit !== null && $limit < 1) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling DefaultAPI.listGuildAuditLogEntries, must be bigger than or equal to 1.');
        }
        

        $resourcePath = '/guilds/{guild_id}/audit-logs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id,
            'user_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $action_type,
            'action_type', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $before,
            'before', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $after,
            'after', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listGuildBans
     *
     * @param  string $guild_id guild_id (required)
     * @param  int|null $limit limit (optional)
     * @param  string|null $before before (optional)
     * @param  string|null $after after (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildBans'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildBanResponse[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listGuildBans(
        string $guild_id,
        ?int $limit = null,
        ?string $before = null,
        ?string $after = null,
        string $contentType = self::contentTypes['listGuildBans'][0]
    ): array
    {
        list($response) = $this->listGuildBansWithHttpInfo($guild_id, $limit, $before, $after, $contentType);
        return $response;
    }

    /**
     * Operation listGuildBansWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  int|null $limit (optional)
     * @param  string|null $before (optional)
     * @param  string|null $after (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildBans'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildBanResponse[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listGuildBansWithHttpInfo(
        string $guild_id,
        ?int $limit = null,
        ?string $before = null,
        ?string $after = null,
        string $contentType = self::contentTypes['listGuildBans'][0]
    ): array
    {
        $request = $this->listGuildBansRequest($guild_id, $limit, $before, $after, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildBanResponse[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildBanResponse[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildBanResponse[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildBanResponse[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildBanResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listGuildBansAsync
     *
     * @param  string $guild_id (required)
     * @param  int|null $limit (optional)
     * @param  string|null $before (optional)
     * @param  string|null $after (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildBans'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildBansAsync(
        string $guild_id,
        ?int $limit = null,
        ?string $before = null,
        ?string $after = null,
        string $contentType = self::contentTypes['listGuildBans'][0]
    ): PromiseInterface
    {
        return $this->listGuildBansAsyncWithHttpInfo($guild_id, $limit, $before, $after, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listGuildBansAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  int|null $limit (optional)
     * @param  string|null $before (optional)
     * @param  string|null $after (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildBans'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildBansAsyncWithHttpInfo(
        $guild_id,
        $limit = null,
        $before = null,
        $after = null,
        string $contentType = self::contentTypes['listGuildBans'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildBanResponse[]';
        $request = $this->listGuildBansRequest($guild_id, $limit, $before, $after, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listGuildBans'
     *
     * @param  string $guild_id (required)
     * @param  int|null $limit (optional)
     * @param  string|null $before (optional)
     * @param  string|null $after (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildBans'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listGuildBansRequest(
        $guild_id,
        $limit = null,
        $before = null,
        $after = null,
        string $contentType = self::contentTypes['listGuildBans'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling listGuildBans'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.listGuildBans, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        if ($limit !== null && $limit > 1000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling DefaultAPI.listGuildBans, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling DefaultAPI.listGuildBans, must be bigger than or equal to 1.');
        }
        
        if ($before !== null && !preg_match("/^(0|[1-9][0-9]*)$/", $before)) {
            throw new InvalidArgumentException("invalid value for \"before\" when calling DefaultAPI.listGuildBans, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        if ($after !== null && !preg_match("/^(0|[1-9][0-9]*)$/", $after)) {
            throw new InvalidArgumentException("invalid value for \"after\" when calling DefaultAPI.listGuildBans, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/bans';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $before,
            'before', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $after,
            'after', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listGuildChannels
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildChannels'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListGuildChannels200ResponseInner[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listGuildChannels(
        string $guild_id,
        string $contentType = self::contentTypes['listGuildChannels'][0]
    ): array
    {
        list($response) = $this->listGuildChannelsWithHttpInfo($guild_id, $contentType);
        return $response;
    }

    /**
     * Operation listGuildChannelsWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildChannels'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListGuildChannels200ResponseInner[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listGuildChannelsWithHttpInfo(
        string $guild_id,
        string $contentType = self::contentTypes['listGuildChannels'][0]
    ): array
    {
        $request = $this->listGuildChannelsRequest($guild_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListGuildChannels200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListGuildChannels200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListGuildChannels200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ListGuildChannels200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListGuildChannels200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listGuildChannelsAsync
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildChannels'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildChannelsAsync(
        string $guild_id,
        string $contentType = self::contentTypes['listGuildChannels'][0]
    ): PromiseInterface
    {
        return $this->listGuildChannelsAsyncWithHttpInfo($guild_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listGuildChannelsAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildChannels'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildChannelsAsyncWithHttpInfo(
        $guild_id,
        string $contentType = self::contentTypes['listGuildChannels'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ListGuildChannels200ResponseInner[]';
        $request = $this->listGuildChannelsRequest($guild_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listGuildChannels'
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildChannels'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listGuildChannelsRequest(
        $guild_id,
        string $contentType = self::contentTypes['listGuildChannels'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling listGuildChannels'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.listGuildChannels, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/channels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listGuildEmojis
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildEmojis'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmojiResponse[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listGuildEmojis(
        string $guild_id,
        string $contentType = self::contentTypes['listGuildEmojis'][0]
    ): array
    {
        list($response) = $this->listGuildEmojisWithHttpInfo($guild_id, $contentType);
        return $response;
    }

    /**
     * Operation listGuildEmojisWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildEmojis'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmojiResponse[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listGuildEmojisWithHttpInfo(
        string $guild_id,
        string $contentType = self::contentTypes['listGuildEmojis'][0]
    ): array
    {
        $request = $this->listGuildEmojisRequest($guild_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EmojiResponse[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmojiResponse[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmojiResponse[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\EmojiResponse[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmojiResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listGuildEmojisAsync
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildEmojis'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildEmojisAsync(
        string $guild_id,
        string $contentType = self::contentTypes['listGuildEmojis'][0]
    ): PromiseInterface
    {
        return $this->listGuildEmojisAsyncWithHttpInfo($guild_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listGuildEmojisAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildEmojis'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildEmojisAsyncWithHttpInfo(
        $guild_id,
        string $contentType = self::contentTypes['listGuildEmojis'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\EmojiResponse[]';
        $request = $this->listGuildEmojisRequest($guild_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listGuildEmojis'
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildEmojis'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listGuildEmojisRequest(
        $guild_id,
        string $contentType = self::contentTypes['listGuildEmojis'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling listGuildEmojis'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.listGuildEmojis, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/emojis';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listGuildIntegrations
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildIntegrations'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListGuildIntegrations200ResponseInner[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listGuildIntegrations(
        string $guild_id,
        string $contentType = self::contentTypes['listGuildIntegrations'][0]
    ): array
    {
        list($response) = $this->listGuildIntegrationsWithHttpInfo($guild_id, $contentType);
        return $response;
    }

    /**
     * Operation listGuildIntegrationsWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildIntegrations'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListGuildIntegrations200ResponseInner[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listGuildIntegrationsWithHttpInfo(
        string $guild_id,
        string $contentType = self::contentTypes['listGuildIntegrations'][0]
    ): array
    {
        $request = $this->listGuildIntegrationsRequest($guild_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListGuildIntegrations200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListGuildIntegrations200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListGuildIntegrations200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ListGuildIntegrations200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListGuildIntegrations200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listGuildIntegrationsAsync
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildIntegrations'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildIntegrationsAsync(
        string $guild_id,
        string $contentType = self::contentTypes['listGuildIntegrations'][0]
    ): PromiseInterface
    {
        return $this->listGuildIntegrationsAsyncWithHttpInfo($guild_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listGuildIntegrationsAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildIntegrations'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildIntegrationsAsyncWithHttpInfo(
        $guild_id,
        string $contentType = self::contentTypes['listGuildIntegrations'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ListGuildIntegrations200ResponseInner[]';
        $request = $this->listGuildIntegrationsRequest($guild_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listGuildIntegrations'
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildIntegrations'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listGuildIntegrationsRequest(
        $guild_id,
        string $contentType = self::contentTypes['listGuildIntegrations'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling listGuildIntegrations'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.listGuildIntegrations, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/integrations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listGuildInvites
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildInvites'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListChannelInvites200ResponseInner[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listGuildInvites(
        string $guild_id,
        string $contentType = self::contentTypes['listGuildInvites'][0]
    ): array
    {
        list($response) = $this->listGuildInvitesWithHttpInfo($guild_id, $contentType);
        return $response;
    }

    /**
     * Operation listGuildInvitesWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildInvites'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListChannelInvites200ResponseInner[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listGuildInvitesWithHttpInfo(
        string $guild_id,
        string $contentType = self::contentTypes['listGuildInvites'][0]
    ): array
    {
        $request = $this->listGuildInvitesRequest($guild_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListChannelInvites200ResponseInner[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListChannelInvites200ResponseInner[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListChannelInvites200ResponseInner[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ListChannelInvites200ResponseInner[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListChannelInvites200ResponseInner[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listGuildInvitesAsync
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildInvites'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildInvitesAsync(
        string $guild_id,
        string $contentType = self::contentTypes['listGuildInvites'][0]
    ): PromiseInterface
    {
        return $this->listGuildInvitesAsyncWithHttpInfo($guild_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listGuildInvitesAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildInvites'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildInvitesAsyncWithHttpInfo(
        $guild_id,
        string $contentType = self::contentTypes['listGuildInvites'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ListChannelInvites200ResponseInner[]';
        $request = $this->listGuildInvitesRequest($guild_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listGuildInvites'
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildInvites'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listGuildInvitesRequest(
        $guild_id,
        string $contentType = self::contentTypes['listGuildInvites'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling listGuildInvites'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.listGuildInvites, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/invites';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listGuildMembers
     *
     * @param  string $guild_id guild_id (required)
     * @param  int|null $limit limit (optional)
     * @param  int|null $after after (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildMembers'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildMemberResponse[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listGuildMembers(
        string $guild_id,
        ?int $limit = null,
        ?int $after = null,
        string $contentType = self::contentTypes['listGuildMembers'][0]
    ): array
    {
        list($response) = $this->listGuildMembersWithHttpInfo($guild_id, $limit, $after, $contentType);
        return $response;
    }

    /**
     * Operation listGuildMembersWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  int|null $limit (optional)
     * @param  int|null $after (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildMembers'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildMemberResponse[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listGuildMembersWithHttpInfo(
        string $guild_id,
        ?int $limit = null,
        ?int $after = null,
        string $contentType = self::contentTypes['listGuildMembers'][0]
    ): array
    {
        $request = $this->listGuildMembersRequest($guild_id, $limit, $after, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildMemberResponse[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildMemberResponse[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildMemberResponse[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildMemberResponse[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildMemberResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listGuildMembersAsync
     *
     * @param  string $guild_id (required)
     * @param  int|null $limit (optional)
     * @param  int|null $after (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildMembers'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildMembersAsync(
        string $guild_id,
        ?int $limit = null,
        ?int $after = null,
        string $contentType = self::contentTypes['listGuildMembers'][0]
    ): PromiseInterface
    {
        return $this->listGuildMembersAsyncWithHttpInfo($guild_id, $limit, $after, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listGuildMembersAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  int|null $limit (optional)
     * @param  int|null $after (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildMembers'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildMembersAsyncWithHttpInfo(
        $guild_id,
        $limit = null,
        $after = null,
        string $contentType = self::contentTypes['listGuildMembers'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildMemberResponse[]';
        $request = $this->listGuildMembersRequest($guild_id, $limit, $after, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listGuildMembers'
     *
     * @param  string $guild_id (required)
     * @param  int|null $limit (optional)
     * @param  int|null $after (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildMembers'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listGuildMembersRequest(
        $guild_id,
        $limit = null,
        $after = null,
        string $contentType = self::contentTypes['listGuildMembers'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling listGuildMembers'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.listGuildMembers, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        if ($limit !== null && $limit > 1000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling DefaultAPI.listGuildMembers, must be smaller than or equal to 1000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling DefaultAPI.listGuildMembers, must be bigger than or equal to 1.');
        }
        
        if ($after !== null && $after < 0) {
            throw new InvalidArgumentException('invalid value for "$after" when calling DefaultAPI.listGuildMembers, must be bigger than or equal to 0.');
        }
        

        $resourcePath = '/guilds/{guild_id}/members';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $after,
            'after', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listGuildRoles
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildRoles'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildRoleResponse[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listGuildRoles(
        string $guild_id,
        string $contentType = self::contentTypes['listGuildRoles'][0]
    ): array
    {
        list($response) = $this->listGuildRolesWithHttpInfo($guild_id, $contentType);
        return $response;
    }

    /**
     * Operation listGuildRolesWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildRoles'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildRoleResponse[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listGuildRolesWithHttpInfo(
        string $guild_id,
        string $contentType = self::contentTypes['listGuildRoles'][0]
    ): array
    {
        $request = $this->listGuildRolesRequest($guild_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildRoleResponse[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildRoleResponse[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildRoleResponse[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildRoleResponse[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildRoleResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listGuildRolesAsync
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildRoles'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildRolesAsync(
        string $guild_id,
        string $contentType = self::contentTypes['listGuildRoles'][0]
    ): PromiseInterface
    {
        return $this->listGuildRolesAsyncWithHttpInfo($guild_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listGuildRolesAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildRoles'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildRolesAsyncWithHttpInfo(
        $guild_id,
        string $contentType = self::contentTypes['listGuildRoles'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildRoleResponse[]';
        $request = $this->listGuildRolesRequest($guild_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listGuildRoles'
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildRoles'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listGuildRolesRequest(
        $guild_id,
        string $contentType = self::contentTypes['listGuildRoles'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling listGuildRoles'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.listGuildRoles, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/roles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listGuildScheduledEventUsers
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $guild_scheduled_event_id guild_scheduled_event_id (required)
     * @param  bool|null $with_member with_member (optional)
     * @param  int|null $limit limit (optional)
     * @param  string|null $before before (optional)
     * @param  string|null $after after (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildScheduledEventUsers'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ScheduledEventUserResponse[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listGuildScheduledEventUsers(
        string $guild_id,
        string $guild_scheduled_event_id,
        ?bool $with_member = null,
        ?int $limit = null,
        ?string $before = null,
        ?string $after = null,
        string $contentType = self::contentTypes['listGuildScheduledEventUsers'][0]
    ): array
    {
        list($response) = $this->listGuildScheduledEventUsersWithHttpInfo($guild_id, $guild_scheduled_event_id, $with_member, $limit, $before, $after, $contentType);
        return $response;
    }

    /**
     * Operation listGuildScheduledEventUsersWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $guild_scheduled_event_id (required)
     * @param  bool|null $with_member (optional)
     * @param  int|null $limit (optional)
     * @param  string|null $before (optional)
     * @param  string|null $after (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildScheduledEventUsers'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ScheduledEventUserResponse[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listGuildScheduledEventUsersWithHttpInfo(
        string $guild_id,
        string $guild_scheduled_event_id,
        ?bool $with_member = null,
        ?int $limit = null,
        ?string $before = null,
        ?string $after = null,
        string $contentType = self::contentTypes['listGuildScheduledEventUsers'][0]
    ): array
    {
        $request = $this->listGuildScheduledEventUsersRequest($guild_id, $guild_scheduled_event_id, $with_member, $limit, $before, $after, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ScheduledEventUserResponse[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ScheduledEventUserResponse[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ScheduledEventUserResponse[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ScheduledEventUserResponse[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ScheduledEventUserResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listGuildScheduledEventUsersAsync
     *
     * @param  string $guild_id (required)
     * @param  string $guild_scheduled_event_id (required)
     * @param  bool|null $with_member (optional)
     * @param  int|null $limit (optional)
     * @param  string|null $before (optional)
     * @param  string|null $after (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildScheduledEventUsers'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildScheduledEventUsersAsync(
        string $guild_id,
        string $guild_scheduled_event_id,
        ?bool $with_member = null,
        ?int $limit = null,
        ?string $before = null,
        ?string $after = null,
        string $contentType = self::contentTypes['listGuildScheduledEventUsers'][0]
    ): PromiseInterface
    {
        return $this->listGuildScheduledEventUsersAsyncWithHttpInfo($guild_id, $guild_scheduled_event_id, $with_member, $limit, $before, $after, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listGuildScheduledEventUsersAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $guild_scheduled_event_id (required)
     * @param  bool|null $with_member (optional)
     * @param  int|null $limit (optional)
     * @param  string|null $before (optional)
     * @param  string|null $after (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildScheduledEventUsers'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildScheduledEventUsersAsyncWithHttpInfo(
        $guild_id,
        $guild_scheduled_event_id,
        $with_member = null,
        $limit = null,
        $before = null,
        $after = null,
        string $contentType = self::contentTypes['listGuildScheduledEventUsers'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ScheduledEventUserResponse[]';
        $request = $this->listGuildScheduledEventUsersRequest($guild_id, $guild_scheduled_event_id, $with_member, $limit, $before, $after, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listGuildScheduledEventUsers'
     *
     * @param  string $guild_id (required)
     * @param  string $guild_scheduled_event_id (required)
     * @param  bool|null $with_member (optional)
     * @param  int|null $limit (optional)
     * @param  string|null $before (optional)
     * @param  string|null $after (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildScheduledEventUsers'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listGuildScheduledEventUsersRequest(
        $guild_id,
        $guild_scheduled_event_id,
        $with_member = null,
        $limit = null,
        $before = null,
        $after = null,
        string $contentType = self::contentTypes['listGuildScheduledEventUsers'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling listGuildScheduledEventUsers'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.listGuildScheduledEventUsers, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'guild_scheduled_event_id' is set
        if ($guild_scheduled_event_id === null || (is_array($guild_scheduled_event_id) && count($guild_scheduled_event_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_scheduled_event_id when calling listGuildScheduledEventUsers'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_scheduled_event_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_scheduled_event_id\" when calling DefaultAPI.listGuildScheduledEventUsers, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        if ($limit !== null && $limit > 100) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling DefaultAPI.listGuildScheduledEventUsers, must be smaller than or equal to 100.');
        }
        if ($limit !== null && $limit < 1) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling DefaultAPI.listGuildScheduledEventUsers, must be bigger than or equal to 1.');
        }
        
        if ($before !== null && !preg_match("/^(0|[1-9][0-9]*)$/", $before)) {
            throw new InvalidArgumentException("invalid value for \"before\" when calling DefaultAPI.listGuildScheduledEventUsers, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        if ($after !== null && !preg_match("/^(0|[1-9][0-9]*)$/", $after)) {
            throw new InvalidArgumentException("invalid value for \"after\" when calling DefaultAPI.listGuildScheduledEventUsers, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/scheduled-events/{guild_scheduled_event_id}/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_member,
            'with_member', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $before,
            'before', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $after,
            'after', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($guild_scheduled_event_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_scheduled_event_id' . '}',
                ObjectSerializer::toPathValue($guild_scheduled_event_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listGuildScheduledEvents
     *
     * @param  string $guild_id guild_id (required)
     * @param  bool|null $with_user_count with_user_count (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildScheduledEvents'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetGuildScheduledEvent200Response[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listGuildScheduledEvents(
        string $guild_id,
        ?bool $with_user_count = null,
        string $contentType = self::contentTypes['listGuildScheduledEvents'][0]
    ): array
    {
        list($response) = $this->listGuildScheduledEventsWithHttpInfo($guild_id, $with_user_count, $contentType);
        return $response;
    }

    /**
     * Operation listGuildScheduledEventsWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  bool|null $with_user_count (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildScheduledEvents'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetGuildScheduledEvent200Response[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listGuildScheduledEventsWithHttpInfo(
        string $guild_id,
        ?bool $with_user_count = null,
        string $contentType = self::contentTypes['listGuildScheduledEvents'][0]
    ): array
    {
        $request = $this->listGuildScheduledEventsRequest($guild_id, $with_user_count, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetGuildScheduledEvent200Response[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetGuildScheduledEvent200Response[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetGuildScheduledEvent200Response[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GetGuildScheduledEvent200Response[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetGuildScheduledEvent200Response[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listGuildScheduledEventsAsync
     *
     * @param  string $guild_id (required)
     * @param  bool|null $with_user_count (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildScheduledEvents'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildScheduledEventsAsync(
        string $guild_id,
        ?bool $with_user_count = null,
        string $contentType = self::contentTypes['listGuildScheduledEvents'][0]
    ): PromiseInterface
    {
        return $this->listGuildScheduledEventsAsyncWithHttpInfo($guild_id, $with_user_count, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listGuildScheduledEventsAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  bool|null $with_user_count (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildScheduledEvents'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildScheduledEventsAsyncWithHttpInfo(
        $guild_id,
        $with_user_count = null,
        string $contentType = self::contentTypes['listGuildScheduledEvents'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GetGuildScheduledEvent200Response[]';
        $request = $this->listGuildScheduledEventsRequest($guild_id, $with_user_count, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listGuildScheduledEvents'
     *
     * @param  string $guild_id (required)
     * @param  bool|null $with_user_count (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildScheduledEvents'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listGuildScheduledEventsRequest(
        $guild_id,
        $with_user_count = null,
        string $contentType = self::contentTypes['listGuildScheduledEvents'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling listGuildScheduledEvents'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.listGuildScheduledEvents, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        


        $resourcePath = '/guilds/{guild_id}/scheduled-events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_user_count,
            'with_user_count', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listGuildStickers
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildStickers'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildStickerResponse[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listGuildStickers(
        string $guild_id,
        string $contentType = self::contentTypes['listGuildStickers'][0]
    ): array
    {
        list($response) = $this->listGuildStickersWithHttpInfo($guild_id, $contentType);
        return $response;
    }

    /**
     * Operation listGuildStickersWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildStickers'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildStickerResponse[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listGuildStickersWithHttpInfo(
        string $guild_id,
        string $contentType = self::contentTypes['listGuildStickers'][0]
    ): array
    {
        $request = $this->listGuildStickersRequest($guild_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildStickerResponse[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildStickerResponse[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildStickerResponse[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildStickerResponse[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildStickerResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listGuildStickersAsync
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildStickers'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildStickersAsync(
        string $guild_id,
        string $contentType = self::contentTypes['listGuildStickers'][0]
    ): PromiseInterface
    {
        return $this->listGuildStickersAsyncWithHttpInfo($guild_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listGuildStickersAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildStickers'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildStickersAsyncWithHttpInfo(
        $guild_id,
        string $contentType = self::contentTypes['listGuildStickers'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildStickerResponse[]';
        $request = $this->listGuildStickersRequest($guild_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listGuildStickers'
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildStickers'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listGuildStickersRequest(
        $guild_id,
        string $contentType = self::contentTypes['listGuildStickers'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling listGuildStickers'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.listGuildStickers, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/stickers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listGuildTemplates
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildTemplates'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildTemplateResponse[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listGuildTemplates(
        string $guild_id,
        string $contentType = self::contentTypes['listGuildTemplates'][0]
    ): array
    {
        list($response) = $this->listGuildTemplatesWithHttpInfo($guild_id, $contentType);
        return $response;
    }

    /**
     * Operation listGuildTemplatesWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildTemplates'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildTemplateResponse[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listGuildTemplatesWithHttpInfo(
        string $guild_id,
        string $contentType = self::contentTypes['listGuildTemplates'][0]
    ): array
    {
        $request = $this->listGuildTemplatesRequest($guild_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildTemplateResponse[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildTemplateResponse[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildTemplateResponse[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildTemplateResponse[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildTemplateResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listGuildTemplatesAsync
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildTemplates'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildTemplatesAsync(
        string $guild_id,
        string $contentType = self::contentTypes['listGuildTemplates'][0]
    ): PromiseInterface
    {
        return $this->listGuildTemplatesAsyncWithHttpInfo($guild_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listGuildTemplatesAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildTemplates'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildTemplatesAsyncWithHttpInfo(
        $guild_id,
        string $contentType = self::contentTypes['listGuildTemplates'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildTemplateResponse[]';
        $request = $this->listGuildTemplatesRequest($guild_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listGuildTemplates'
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildTemplates'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listGuildTemplatesRequest(
        $guild_id,
        string $contentType = self::contentTypes['listGuildTemplates'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling listGuildTemplates'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.listGuildTemplates, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listGuildVoiceRegions
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildVoiceRegions'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\VoiceRegionResponse[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listGuildVoiceRegions(
        string $guild_id,
        string $contentType = self::contentTypes['listGuildVoiceRegions'][0]
    ): array
    {
        list($response) = $this->listGuildVoiceRegionsWithHttpInfo($guild_id, $contentType);
        return $response;
    }

    /**
     * Operation listGuildVoiceRegionsWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildVoiceRegions'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VoiceRegionResponse[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listGuildVoiceRegionsWithHttpInfo(
        string $guild_id,
        string $contentType = self::contentTypes['listGuildVoiceRegions'][0]
    ): array
    {
        $request = $this->listGuildVoiceRegionsRequest($guild_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\VoiceRegionResponse[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VoiceRegionResponse[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VoiceRegionResponse[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\VoiceRegionResponse[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VoiceRegionResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listGuildVoiceRegionsAsync
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildVoiceRegions'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildVoiceRegionsAsync(
        string $guild_id,
        string $contentType = self::contentTypes['listGuildVoiceRegions'][0]
    ): PromiseInterface
    {
        return $this->listGuildVoiceRegionsAsyncWithHttpInfo($guild_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listGuildVoiceRegionsAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildVoiceRegions'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listGuildVoiceRegionsAsyncWithHttpInfo(
        $guild_id,
        string $contentType = self::contentTypes['listGuildVoiceRegions'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\VoiceRegionResponse[]';
        $request = $this->listGuildVoiceRegionsRequest($guild_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listGuildVoiceRegions'
     *
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listGuildVoiceRegions'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listGuildVoiceRegionsRequest(
        $guild_id,
        string $contentType = self::contentTypes['listGuildVoiceRegions'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling listGuildVoiceRegions'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.listGuildVoiceRegions, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/regions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMessageReactionsByEmoji
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $message_id message_id (required)
     * @param  mixed $emoji_name emoji_name (required)
     * @param  string|null $after after (optional)
     * @param  int|null $limit limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMessageReactionsByEmoji'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\UserResponse[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listMessageReactionsByEmoji(
        string $channel_id,
        string $message_id,
        mixed $emoji_name,
        ?string $after = null,
        ?int $limit = null,
        string $contentType = self::contentTypes['listMessageReactionsByEmoji'][0]
    ): array
    {
        list($response) = $this->listMessageReactionsByEmojiWithHttpInfo($channel_id, $message_id, $emoji_name, $after, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listMessageReactionsByEmojiWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  mixed $emoji_name (required)
     * @param  string|null $after (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMessageReactionsByEmoji'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\UserResponse[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listMessageReactionsByEmojiWithHttpInfo(
        string $channel_id,
        string $message_id,
        mixed $emoji_name,
        ?string $after = null,
        ?int $limit = null,
        string $contentType = self::contentTypes['listMessageReactionsByEmoji'][0]
    ): array
    {
        $request = $this->listMessageReactionsByEmojiRequest($channel_id, $message_id, $emoji_name, $after, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\UserResponse[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\UserResponse[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\UserResponse[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\UserResponse[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\UserResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listMessageReactionsByEmojiAsync
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  mixed $emoji_name (required)
     * @param  string|null $after (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMessageReactionsByEmoji'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listMessageReactionsByEmojiAsync(
        string $channel_id,
        string $message_id,
        mixed $emoji_name,
        ?string $after = null,
        ?int $limit = null,
        string $contentType = self::contentTypes['listMessageReactionsByEmoji'][0]
    ): PromiseInterface
    {
        return $this->listMessageReactionsByEmojiAsyncWithHttpInfo($channel_id, $message_id, $emoji_name, $after, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMessageReactionsByEmojiAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  mixed $emoji_name (required)
     * @param  string|null $after (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMessageReactionsByEmoji'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listMessageReactionsByEmojiAsyncWithHttpInfo(
        $channel_id,
        $message_id,
        $emoji_name,
        $after = null,
        $limit = null,
        string $contentType = self::contentTypes['listMessageReactionsByEmoji'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\UserResponse[]';
        $request = $this->listMessageReactionsByEmojiRequest($channel_id, $message_id, $emoji_name, $after, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMessageReactionsByEmoji'
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  mixed $emoji_name (required)
     * @param  string|null $after (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMessageReactionsByEmoji'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listMessageReactionsByEmojiRequest(
        $channel_id,
        $message_id,
        $emoji_name,
        $after = null,
        $limit = null,
        string $contentType = self::contentTypes['listMessageReactionsByEmoji'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling listMessageReactionsByEmoji'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.listMessageReactionsByEmoji, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $message_id when calling listMessageReactionsByEmoji'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $message_id)) {
            throw new InvalidArgumentException("invalid value for \"message_id\" when calling DefaultAPI.listMessageReactionsByEmoji, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'emoji_name' is set
        if ($emoji_name === null || (is_array($emoji_name) && count($emoji_name) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $emoji_name when calling listMessageReactionsByEmoji'
            );
        }
        if (strlen($emoji_name) > 152133) {
            throw new InvalidArgumentException('invalid length for "$emoji_name" when calling DefaultAPI.listMessageReactionsByEmoji, must be smaller than or equal to 152133.');
        }
        
        if ($after !== null && !preg_match("/^(0|[1-9][0-9]*)$/", $after)) {
            throw new InvalidArgumentException("invalid value for \"after\" when calling DefaultAPI.listMessageReactionsByEmoji, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        if ($limit !== null && $limit > 100) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling DefaultAPI.listMessageReactionsByEmoji, must be smaller than or equal to 100.');
        }
        if ($limit !== null && $limit < 1) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling DefaultAPI.listMessageReactionsByEmoji, must be bigger than or equal to 1.');
        }
        

        $resourcePath = '/channels/{channel_id}/messages/{message_id}/reactions/{emoji_name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $after,
            'after', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'message_id' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }
        // path params
        if ($emoji_name !== null) {
            $resourcePath = str_replace(
                '{' . 'emoji_name' . '}',
                ObjectSerializer::toPathValue($emoji_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMessages
     *
     * @param  string $channel_id channel_id (required)
     * @param  string|null $around around (optional)
     * @param  string|null $before before (optional)
     * @param  string|null $after after (optional)
     * @param  int|null $limit limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMessages'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\MessageResponse[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listMessages(
        string $channel_id,
        ?string $around = null,
        ?string $before = null,
        ?string $after = null,
        ?int $limit = null,
        string $contentType = self::contentTypes['listMessages'][0]
    ): array
    {
        list($response) = $this->listMessagesWithHttpInfo($channel_id, $around, $before, $after, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listMessagesWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string|null $around (optional)
     * @param  string|null $before (optional)
     * @param  string|null $after (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMessages'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MessageResponse[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listMessagesWithHttpInfo(
        string $channel_id,
        ?string $around = null,
        ?string $before = null,
        ?string $after = null,
        ?int $limit = null,
        string $contentType = self::contentTypes['listMessages'][0]
    ): array
    {
        $request = $this->listMessagesRequest($channel_id, $around, $before, $after, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\MessageResponse[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\MessageResponse[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MessageResponse[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\MessageResponse[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MessageResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listMessagesAsync
     *
     * @param  string $channel_id (required)
     * @param  string|null $around (optional)
     * @param  string|null $before (optional)
     * @param  string|null $after (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMessages'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listMessagesAsync(
        string $channel_id,
        ?string $around = null,
        ?string $before = null,
        ?string $after = null,
        ?int $limit = null,
        string $contentType = self::contentTypes['listMessages'][0]
    ): PromiseInterface
    {
        return $this->listMessagesAsyncWithHttpInfo($channel_id, $around, $before, $after, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMessagesAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string|null $around (optional)
     * @param  string|null $before (optional)
     * @param  string|null $after (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMessages'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listMessagesAsyncWithHttpInfo(
        $channel_id,
        $around = null,
        $before = null,
        $after = null,
        $limit = null,
        string $contentType = self::contentTypes['listMessages'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\MessageResponse[]';
        $request = $this->listMessagesRequest($channel_id, $around, $before, $after, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMessages'
     *
     * @param  string $channel_id (required)
     * @param  string|null $around (optional)
     * @param  string|null $before (optional)
     * @param  string|null $after (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMessages'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listMessagesRequest(
        $channel_id,
        $around = null,
        $before = null,
        $after = null,
        $limit = null,
        string $contentType = self::contentTypes['listMessages'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling listMessages'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.listMessages, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        if ($around !== null && !preg_match("/^(0|[1-9][0-9]*)$/", $around)) {
            throw new InvalidArgumentException("invalid value for \"around\" when calling DefaultAPI.listMessages, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        if ($before !== null && !preg_match("/^(0|[1-9][0-9]*)$/", $before)) {
            throw new InvalidArgumentException("invalid value for \"before\" when calling DefaultAPI.listMessages, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        if ($after !== null && !preg_match("/^(0|[1-9][0-9]*)$/", $after)) {
            throw new InvalidArgumentException("invalid value for \"after\" when calling DefaultAPI.listMessages, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        if ($limit !== null && $limit > 100) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling DefaultAPI.listMessages, must be smaller than or equal to 100.');
        }
        if ($limit !== null && $limit < 1) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling DefaultAPI.listMessages, must be bigger than or equal to 1.');
        }
        

        $resourcePath = '/channels/{channel_id}/messages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $around,
            'around', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $before,
            'before', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $after,
            'after', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMyConnections
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMyConnections'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ConnectedAccountResponse[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listMyConnections(
        string $contentType = self::contentTypes['listMyConnections'][0]
    ): array
    {
        list($response) = $this->listMyConnectionsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation listMyConnectionsWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMyConnections'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ConnectedAccountResponse[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listMyConnectionsWithHttpInfo(
        string $contentType = self::contentTypes['listMyConnections'][0]
    ): array
    {
        $request = $this->listMyConnectionsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ConnectedAccountResponse[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ConnectedAccountResponse[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ConnectedAccountResponse[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ConnectedAccountResponse[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ConnectedAccountResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listMyConnectionsAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMyConnections'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listMyConnectionsAsync(
        string $contentType = self::contentTypes['listMyConnections'][0]
    ): PromiseInterface
    {
        return $this->listMyConnectionsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMyConnectionsAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMyConnections'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listMyConnectionsAsyncWithHttpInfo(
        string $contentType = self::contentTypes['listMyConnections'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ConnectedAccountResponse[]';
        $request = $this->listMyConnectionsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMyConnections'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMyConnections'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listMyConnectionsRequest(
        string $contentType = self::contentTypes['listMyConnections'][0]
    ): Request
    {


        $resourcePath = '/users/@me/connections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMyGuilds
     *
     * @param  string|null $before before (optional)
     * @param  string|null $after after (optional)
     * @param  int|null $limit limit (optional)
     * @param  bool|null $with_counts with_counts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMyGuilds'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\MyGuildResponse[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listMyGuilds(
        ?string $before = null,
        ?string $after = null,
        ?int $limit = null,
        ?bool $with_counts = null,
        string $contentType = self::contentTypes['listMyGuilds'][0]
    ): array
    {
        list($response) = $this->listMyGuildsWithHttpInfo($before, $after, $limit, $with_counts, $contentType);
        return $response;
    }

    /**
     * Operation listMyGuildsWithHttpInfo
     *
     * @param  string|null $before (optional)
     * @param  string|null $after (optional)
     * @param  int|null $limit (optional)
     * @param  bool|null $with_counts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMyGuilds'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MyGuildResponse[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listMyGuildsWithHttpInfo(
        ?string $before = null,
        ?string $after = null,
        ?int $limit = null,
        ?bool $with_counts = null,
        string $contentType = self::contentTypes['listMyGuilds'][0]
    ): array
    {
        $request = $this->listMyGuildsRequest($before, $after, $limit, $with_counts, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\MyGuildResponse[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\MyGuildResponse[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MyGuildResponse[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\MyGuildResponse[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MyGuildResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listMyGuildsAsync
     *
     * @param  string|null $before (optional)
     * @param  string|null $after (optional)
     * @param  int|null $limit (optional)
     * @param  bool|null $with_counts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMyGuilds'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listMyGuildsAsync(
        ?string $before = null,
        ?string $after = null,
        ?int $limit = null,
        ?bool $with_counts = null,
        string $contentType = self::contentTypes['listMyGuilds'][0]
    ): PromiseInterface
    {
        return $this->listMyGuildsAsyncWithHttpInfo($before, $after, $limit, $with_counts, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMyGuildsAsyncWithHttpInfo
     *
     * @param  string|null $before (optional)
     * @param  string|null $after (optional)
     * @param  int|null $limit (optional)
     * @param  bool|null $with_counts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMyGuilds'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listMyGuildsAsyncWithHttpInfo(
        $before = null,
        $after = null,
        $limit = null,
        $with_counts = null,
        string $contentType = self::contentTypes['listMyGuilds'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\MyGuildResponse[]';
        $request = $this->listMyGuildsRequest($before, $after, $limit, $with_counts, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMyGuilds'
     *
     * @param  string|null $before (optional)
     * @param  string|null $after (optional)
     * @param  int|null $limit (optional)
     * @param  bool|null $with_counts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMyGuilds'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listMyGuildsRequest(
        $before = null,
        $after = null,
        $limit = null,
        $with_counts = null,
        string $contentType = self::contentTypes['listMyGuilds'][0]
    ): Request
    {

        if ($before !== null && !preg_match("/^(0|[1-9][0-9]*)$/", $before)) {
            throw new InvalidArgumentException("invalid value for \"before\" when calling DefaultAPI.listMyGuilds, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        if ($after !== null && !preg_match("/^(0|[1-9][0-9]*)$/", $after)) {
            throw new InvalidArgumentException("invalid value for \"after\" when calling DefaultAPI.listMyGuilds, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        if ($limit !== null && $limit > 200) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling DefaultAPI.listMyGuilds, must be smaller than or equal to 200.');
        }
        if ($limit !== null && $limit < 1) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling DefaultAPI.listMyGuilds, must be bigger than or equal to 1.');
        }
        


        $resourcePath = '/users/@me/guilds';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $before,
            'before', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $after,
            'after', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_counts,
            'with_counts', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMyPrivateArchivedThreads
     *
     * @param  string $channel_id channel_id (required)
     * @param  string|null $before before (optional)
     * @param  int|null $limit limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMyPrivateArchivedThreads'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ThreadsResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listMyPrivateArchivedThreads(
        string $channel_id,
        ?string $before = null,
        ?int $limit = null,
        string $contentType = self::contentTypes['listMyPrivateArchivedThreads'][0]
    ): \OpenAPI\Client\Model\ThreadsResponse
    {
        list($response) = $this->listMyPrivateArchivedThreadsWithHttpInfo($channel_id, $before, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listMyPrivateArchivedThreadsWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string|null $before (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMyPrivateArchivedThreads'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ThreadsResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listMyPrivateArchivedThreadsWithHttpInfo(
        string $channel_id,
        ?string $before = null,
        ?int $limit = null,
        string $contentType = self::contentTypes['listMyPrivateArchivedThreads'][0]
    ): array
    {
        $request = $this->listMyPrivateArchivedThreadsRequest($channel_id, $before, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ThreadsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ThreadsResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ThreadsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ThreadsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ThreadsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listMyPrivateArchivedThreadsAsync
     *
     * @param  string $channel_id (required)
     * @param  string|null $before (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMyPrivateArchivedThreads'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listMyPrivateArchivedThreadsAsync(
        string $channel_id,
        ?string $before = null,
        ?int $limit = null,
        string $contentType = self::contentTypes['listMyPrivateArchivedThreads'][0]
    ): PromiseInterface
    {
        return $this->listMyPrivateArchivedThreadsAsyncWithHttpInfo($channel_id, $before, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMyPrivateArchivedThreadsAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string|null $before (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMyPrivateArchivedThreads'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listMyPrivateArchivedThreadsAsyncWithHttpInfo(
        $channel_id,
        $before = null,
        $limit = null,
        string $contentType = self::contentTypes['listMyPrivateArchivedThreads'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ThreadsResponse';
        $request = $this->listMyPrivateArchivedThreadsRequest($channel_id, $before, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMyPrivateArchivedThreads'
     *
     * @param  string $channel_id (required)
     * @param  string|null $before (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMyPrivateArchivedThreads'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listMyPrivateArchivedThreadsRequest(
        $channel_id,
        $before = null,
        $limit = null,
        string $contentType = self::contentTypes['listMyPrivateArchivedThreads'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling listMyPrivateArchivedThreads'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.listMyPrivateArchivedThreads, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        if ($before !== null && !preg_match("/^(0|[1-9][0-9]*)$/", $before)) {
            throw new InvalidArgumentException("invalid value for \"before\" when calling DefaultAPI.listMyPrivateArchivedThreads, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        if ($limit !== null && $limit > 100) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling DefaultAPI.listMyPrivateArchivedThreads, must be smaller than or equal to 100.');
        }
        if ($limit !== null && $limit < 2) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling DefaultAPI.listMyPrivateArchivedThreads, must be bigger than or equal to 2.');
        }
        

        $resourcePath = '/channels/{channel_id}/users/@me/threads/archived/private';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $before,
            'before', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listPinnedMessages
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPinnedMessages'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\MessageResponse[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listPinnedMessages(
        string $channel_id,
        string $contentType = self::contentTypes['listPinnedMessages'][0]
    ): array
    {
        list($response) = $this->listPinnedMessagesWithHttpInfo($channel_id, $contentType);
        return $response;
    }

    /**
     * Operation listPinnedMessagesWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPinnedMessages'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MessageResponse[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listPinnedMessagesWithHttpInfo(
        string $channel_id,
        string $contentType = self::contentTypes['listPinnedMessages'][0]
    ): array
    {
        $request = $this->listPinnedMessagesRequest($channel_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\MessageResponse[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\MessageResponse[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MessageResponse[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\MessageResponse[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MessageResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listPinnedMessagesAsync
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPinnedMessages'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listPinnedMessagesAsync(
        string $channel_id,
        string $contentType = self::contentTypes['listPinnedMessages'][0]
    ): PromiseInterface
    {
        return $this->listPinnedMessagesAsyncWithHttpInfo($channel_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listPinnedMessagesAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPinnedMessages'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listPinnedMessagesAsyncWithHttpInfo(
        $channel_id,
        string $contentType = self::contentTypes['listPinnedMessages'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\MessageResponse[]';
        $request = $this->listPinnedMessagesRequest($channel_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listPinnedMessages'
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPinnedMessages'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listPinnedMessagesRequest(
        $channel_id,
        string $contentType = self::contentTypes['listPinnedMessages'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling listPinnedMessages'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.listPinnedMessages, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/channels/{channel_id}/pins';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listPrivateArchivedThreads
     *
     * @param  string $channel_id channel_id (required)
     * @param  \DateTime|null $before before (optional)
     * @param  int|null $limit limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPrivateArchivedThreads'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ThreadsResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listPrivateArchivedThreads(
        string $channel_id,
        ?\DateTime $before = null,
        ?int $limit = null,
        string $contentType = self::contentTypes['listPrivateArchivedThreads'][0]
    ): \OpenAPI\Client\Model\ThreadsResponse
    {
        list($response) = $this->listPrivateArchivedThreadsWithHttpInfo($channel_id, $before, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listPrivateArchivedThreadsWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  \DateTime|null $before (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPrivateArchivedThreads'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ThreadsResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listPrivateArchivedThreadsWithHttpInfo(
        string $channel_id,
        ?\DateTime $before = null,
        ?int $limit = null,
        string $contentType = self::contentTypes['listPrivateArchivedThreads'][0]
    ): array
    {
        $request = $this->listPrivateArchivedThreadsRequest($channel_id, $before, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ThreadsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ThreadsResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ThreadsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ThreadsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ThreadsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listPrivateArchivedThreadsAsync
     *
     * @param  string $channel_id (required)
     * @param  \DateTime|null $before (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPrivateArchivedThreads'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listPrivateArchivedThreadsAsync(
        string $channel_id,
        ?\DateTime $before = null,
        ?int $limit = null,
        string $contentType = self::contentTypes['listPrivateArchivedThreads'][0]
    ): PromiseInterface
    {
        return $this->listPrivateArchivedThreadsAsyncWithHttpInfo($channel_id, $before, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listPrivateArchivedThreadsAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  \DateTime|null $before (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPrivateArchivedThreads'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listPrivateArchivedThreadsAsyncWithHttpInfo(
        $channel_id,
        $before = null,
        $limit = null,
        string $contentType = self::contentTypes['listPrivateArchivedThreads'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ThreadsResponse';
        $request = $this->listPrivateArchivedThreadsRequest($channel_id, $before, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listPrivateArchivedThreads'
     *
     * @param  string $channel_id (required)
     * @param  \DateTime|null $before (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPrivateArchivedThreads'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listPrivateArchivedThreadsRequest(
        $channel_id,
        $before = null,
        $limit = null,
        string $contentType = self::contentTypes['listPrivateArchivedThreads'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling listPrivateArchivedThreads'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.listPrivateArchivedThreads, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        if ($limit !== null && $limit > 100) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling DefaultAPI.listPrivateArchivedThreads, must be smaller than or equal to 100.');
        }
        if ($limit !== null && $limit < 2) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling DefaultAPI.listPrivateArchivedThreads, must be bigger than or equal to 2.');
        }
        

        $resourcePath = '/channels/{channel_id}/threads/archived/private';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $before,
            'before', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listPublicArchivedThreads
     *
     * @param  string $channel_id channel_id (required)
     * @param  \DateTime|null $before before (optional)
     * @param  int|null $limit limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPublicArchivedThreads'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ThreadsResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listPublicArchivedThreads(
        string $channel_id,
        ?\DateTime $before = null,
        ?int $limit = null,
        string $contentType = self::contentTypes['listPublicArchivedThreads'][0]
    ): \OpenAPI\Client\Model\ThreadsResponse
    {
        list($response) = $this->listPublicArchivedThreadsWithHttpInfo($channel_id, $before, $limit, $contentType);
        return $response;
    }

    /**
     * Operation listPublicArchivedThreadsWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  \DateTime|null $before (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPublicArchivedThreads'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ThreadsResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listPublicArchivedThreadsWithHttpInfo(
        string $channel_id,
        ?\DateTime $before = null,
        ?int $limit = null,
        string $contentType = self::contentTypes['listPublicArchivedThreads'][0]
    ): array
    {
        $request = $this->listPublicArchivedThreadsRequest($channel_id, $before, $limit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ThreadsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ThreadsResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ThreadsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ThreadsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ThreadsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listPublicArchivedThreadsAsync
     *
     * @param  string $channel_id (required)
     * @param  \DateTime|null $before (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPublicArchivedThreads'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listPublicArchivedThreadsAsync(
        string $channel_id,
        ?\DateTime $before = null,
        ?int $limit = null,
        string $contentType = self::contentTypes['listPublicArchivedThreads'][0]
    ): PromiseInterface
    {
        return $this->listPublicArchivedThreadsAsyncWithHttpInfo($channel_id, $before, $limit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listPublicArchivedThreadsAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  \DateTime|null $before (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPublicArchivedThreads'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listPublicArchivedThreadsAsyncWithHttpInfo(
        $channel_id,
        $before = null,
        $limit = null,
        string $contentType = self::contentTypes['listPublicArchivedThreads'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ThreadsResponse';
        $request = $this->listPublicArchivedThreadsRequest($channel_id, $before, $limit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listPublicArchivedThreads'
     *
     * @param  string $channel_id (required)
     * @param  \DateTime|null $before (optional)
     * @param  int|null $limit (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listPublicArchivedThreads'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listPublicArchivedThreadsRequest(
        $channel_id,
        $before = null,
        $limit = null,
        string $contentType = self::contentTypes['listPublicArchivedThreads'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling listPublicArchivedThreads'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.listPublicArchivedThreads, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        if ($limit !== null && $limit > 100) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling DefaultAPI.listPublicArchivedThreads, must be smaller than or equal to 100.');
        }
        if ($limit !== null && $limit < 2) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling DefaultAPI.listPublicArchivedThreads, must be bigger than or equal to 2.');
        }
        

        $resourcePath = '/channels/{channel_id}/threads/archived/public';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $before,
            'before', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listStickerPacks
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStickerPacks'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\StickerPackCollectionResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listStickerPacks(
        string $contentType = self::contentTypes['listStickerPacks'][0]
    ): \OpenAPI\Client\Model\StickerPackCollectionResponse
    {
        list($response) = $this->listStickerPacksWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation listStickerPacksWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStickerPacks'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\StickerPackCollectionResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listStickerPacksWithHttpInfo(
        string $contentType = self::contentTypes['listStickerPacks'][0]
    ): array
    {
        $request = $this->listStickerPacksRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\StickerPackCollectionResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\StickerPackCollectionResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\StickerPackCollectionResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\StickerPackCollectionResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StickerPackCollectionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listStickerPacksAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStickerPacks'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listStickerPacksAsync(
        string $contentType = self::contentTypes['listStickerPacks'][0]
    ): PromiseInterface
    {
        return $this->listStickerPacksAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listStickerPacksAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStickerPacks'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listStickerPacksAsyncWithHttpInfo(
        string $contentType = self::contentTypes['listStickerPacks'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\StickerPackCollectionResponse';
        $request = $this->listStickerPacksRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listStickerPacks'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStickerPacks'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listStickerPacksRequest(
        string $contentType = self::contentTypes['listStickerPacks'][0]
    ): Request
    {


        $resourcePath = '/sticker-packs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listThreadMembers
     *
     * @param  string $channel_id channel_id (required)
     * @param  bool|null $with_member with_member (optional)
     * @param  int|null $limit limit (optional)
     * @param  string|null $after after (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listThreadMembers'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ThreadMemberResponse[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listThreadMembers(
        string $channel_id,
        ?bool $with_member = null,
        ?int $limit = null,
        ?string $after = null,
        string $contentType = self::contentTypes['listThreadMembers'][0]
    ): array
    {
        list($response) = $this->listThreadMembersWithHttpInfo($channel_id, $with_member, $limit, $after, $contentType);
        return $response;
    }

    /**
     * Operation listThreadMembersWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  bool|null $with_member (optional)
     * @param  int|null $limit (optional)
     * @param  string|null $after (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listThreadMembers'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ThreadMemberResponse[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listThreadMembersWithHttpInfo(
        string $channel_id,
        ?bool $with_member = null,
        ?int $limit = null,
        ?string $after = null,
        string $contentType = self::contentTypes['listThreadMembers'][0]
    ): array
    {
        $request = $this->listThreadMembersRequest($channel_id, $with_member, $limit, $after, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ThreadMemberResponse[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ThreadMemberResponse[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ThreadMemberResponse[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ThreadMemberResponse[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ThreadMemberResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listThreadMembersAsync
     *
     * @param  string $channel_id (required)
     * @param  bool|null $with_member (optional)
     * @param  int|null $limit (optional)
     * @param  string|null $after (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listThreadMembers'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listThreadMembersAsync(
        string $channel_id,
        ?bool $with_member = null,
        ?int $limit = null,
        ?string $after = null,
        string $contentType = self::contentTypes['listThreadMembers'][0]
    ): PromiseInterface
    {
        return $this->listThreadMembersAsyncWithHttpInfo($channel_id, $with_member, $limit, $after, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listThreadMembersAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  bool|null $with_member (optional)
     * @param  int|null $limit (optional)
     * @param  string|null $after (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listThreadMembers'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listThreadMembersAsyncWithHttpInfo(
        $channel_id,
        $with_member = null,
        $limit = null,
        $after = null,
        string $contentType = self::contentTypes['listThreadMembers'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ThreadMemberResponse[]';
        $request = $this->listThreadMembersRequest($channel_id, $with_member, $limit, $after, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listThreadMembers'
     *
     * @param  string $channel_id (required)
     * @param  bool|null $with_member (optional)
     * @param  int|null $limit (optional)
     * @param  string|null $after (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listThreadMembers'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listThreadMembersRequest(
        $channel_id,
        $with_member = null,
        $limit = null,
        $after = null,
        string $contentType = self::contentTypes['listThreadMembers'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling listThreadMembers'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.listThreadMembers, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        if ($limit !== null && $limit > 100) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling DefaultAPI.listThreadMembers, must be smaller than or equal to 100.');
        }
        if ($limit !== null && $limit < 1) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling DefaultAPI.listThreadMembers, must be bigger than or equal to 1.');
        }
        
        if ($after !== null && !preg_match("/^(0|[1-9][0-9]*)$/", $after)) {
            throw new InvalidArgumentException("invalid value for \"after\" when calling DefaultAPI.listThreadMembers, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/channels/{channel_id}/thread-members';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_member,
            'with_member', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $after,
            'after', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listVoiceRegions
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listVoiceRegions'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\VoiceRegionResponse[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function listVoiceRegions(
        string $contentType = self::contentTypes['listVoiceRegions'][0]
    ): array
    {
        list($response) = $this->listVoiceRegionsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation listVoiceRegionsWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listVoiceRegions'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\VoiceRegionResponse[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listVoiceRegionsWithHttpInfo(
        string $contentType = self::contentTypes['listVoiceRegions'][0]
    ): array
    {
        $request = $this->listVoiceRegionsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\VoiceRegionResponse[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\VoiceRegionResponse[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\VoiceRegionResponse[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\VoiceRegionResponse[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\VoiceRegionResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation listVoiceRegionsAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listVoiceRegions'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listVoiceRegionsAsync(
        string $contentType = self::contentTypes['listVoiceRegions'][0]
    ): PromiseInterface
    {
        return $this->listVoiceRegionsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listVoiceRegionsAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listVoiceRegions'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function listVoiceRegionsAsyncWithHttpInfo(
        string $contentType = self::contentTypes['listVoiceRegions'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\VoiceRegionResponse[]';
        $request = $this->listVoiceRegionsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listVoiceRegions'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listVoiceRegions'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listVoiceRegionsRequest(
        string $contentType = self::contentTypes['listVoiceRegions'][0]
    ): Request
    {


        $resourcePath = '/voice/regions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pinMessage
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $message_id message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pinMessage'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function pinMessage(
        string $channel_id,
        string $message_id,
        string $contentType = self::contentTypes['pinMessage'][0]
    ): void
    {
        $this->pinMessageWithHttpInfo($channel_id, $message_id, $contentType);
    }

    /**
     * Operation pinMessageWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pinMessage'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function pinMessageWithHttpInfo(
        string $channel_id,
        string $message_id,
        string $contentType = self::contentTypes['pinMessage'][0]
    ): array
    {
        $request = $this->pinMessageRequest($channel_id, $message_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation pinMessageAsync
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pinMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function pinMessageAsync(
        string $channel_id,
        string $message_id,
        string $contentType = self::contentTypes['pinMessage'][0]
    ): PromiseInterface
    {
        return $this->pinMessageAsyncWithHttpInfo($channel_id, $message_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pinMessageAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pinMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function pinMessageAsyncWithHttpInfo(
        $channel_id,
        $message_id,
        string $contentType = self::contentTypes['pinMessage'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->pinMessageRequest($channel_id, $message_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pinMessage'
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pinMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function pinMessageRequest(
        $channel_id,
        $message_id,
        string $contentType = self::contentTypes['pinMessage'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling pinMessage'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.pinMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $message_id when calling pinMessage'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $message_id)) {
            throw new InvalidArgumentException("invalid value for \"message_id\" when calling DefaultAPI.pinMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/channels/{channel_id}/pins/{message_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'message_id' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation previewPruneGuild
     *
     * @param  string $guild_id guild_id (required)
     * @param  int|null $days days (optional)
     * @param  string|null $include_roles include_roles (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['previewPruneGuild'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildPruneResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function previewPruneGuild(
        string $guild_id,
        ?int $days = null,
        ?string $include_roles = null,
        string $contentType = self::contentTypes['previewPruneGuild'][0]
    ): \OpenAPI\Client\Model\GuildPruneResponse
    {
        list($response) = $this->previewPruneGuildWithHttpInfo($guild_id, $days, $include_roles, $contentType);
        return $response;
    }

    /**
     * Operation previewPruneGuildWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  int|null $days (optional)
     * @param  string|null $include_roles (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['previewPruneGuild'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildPruneResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function previewPruneGuildWithHttpInfo(
        string $guild_id,
        ?int $days = null,
        ?string $include_roles = null,
        string $contentType = self::contentTypes['previewPruneGuild'][0]
    ): array
    {
        $request = $this->previewPruneGuildRequest($guild_id, $days, $include_roles, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildPruneResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildPruneResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildPruneResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildPruneResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildPruneResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation previewPruneGuildAsync
     *
     * @param  string $guild_id (required)
     * @param  int|null $days (optional)
     * @param  string|null $include_roles (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['previewPruneGuild'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function previewPruneGuildAsync(
        string $guild_id,
        ?int $days = null,
        ?string $include_roles = null,
        string $contentType = self::contentTypes['previewPruneGuild'][0]
    ): PromiseInterface
    {
        return $this->previewPruneGuildAsyncWithHttpInfo($guild_id, $days, $include_roles, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation previewPruneGuildAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  int|null $days (optional)
     * @param  string|null $include_roles (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['previewPruneGuild'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function previewPruneGuildAsyncWithHttpInfo(
        $guild_id,
        $days = null,
        $include_roles = null,
        string $contentType = self::contentTypes['previewPruneGuild'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildPruneResponse';
        $request = $this->previewPruneGuildRequest($guild_id, $days, $include_roles, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'previewPruneGuild'
     *
     * @param  string $guild_id (required)
     * @param  int|null $days (optional)
     * @param  string|null $include_roles (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['previewPruneGuild'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function previewPruneGuildRequest(
        $guild_id,
        $days = null,
        $include_roles = null,
        string $contentType = self::contentTypes['previewPruneGuild'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling previewPruneGuild'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.previewPruneGuild, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        if ($days !== null && $days > 30) {
            throw new InvalidArgumentException('invalid value for "$days" when calling DefaultAPI.previewPruneGuild, must be smaller than or equal to 30.');
        }
        if ($days !== null && $days < 1) {
            throw new InvalidArgumentException('invalid value for "$days" when calling DefaultAPI.previewPruneGuild, must be bigger than or equal to 1.');
        }
        


        $resourcePath = '/guilds/{guild_id}/prune';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $days,
            'days', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_roles,
            'include_roles', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pruneGuild
     *
     * @param  string $guild_id guild_id (required)
     * @param  \OpenAPI\Client\Model\PruneGuildRequest $prune_guild_request prune_guild_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pruneGuild'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildPruneResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function pruneGuild(
        string $guild_id,
        \OpenAPI\Client\Model\PruneGuildRequest $prune_guild_request,
        string $contentType = self::contentTypes['pruneGuild'][0]
    ): \OpenAPI\Client\Model\GuildPruneResponse
    {
        list($response) = $this->pruneGuildWithHttpInfo($guild_id, $prune_guild_request, $contentType);
        return $response;
    }

    /**
     * Operation pruneGuildWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\PruneGuildRequest $prune_guild_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pruneGuild'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildPruneResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function pruneGuildWithHttpInfo(
        string $guild_id,
        \OpenAPI\Client\Model\PruneGuildRequest $prune_guild_request,
        string $contentType = self::contentTypes['pruneGuild'][0]
    ): array
    {
        $request = $this->pruneGuildRequest($guild_id, $prune_guild_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildPruneResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildPruneResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildPruneResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildPruneResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildPruneResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation pruneGuildAsync
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\PruneGuildRequest $prune_guild_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pruneGuild'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function pruneGuildAsync(
        string $guild_id,
        \OpenAPI\Client\Model\PruneGuildRequest $prune_guild_request,
        string $contentType = self::contentTypes['pruneGuild'][0]
    ): PromiseInterface
    {
        return $this->pruneGuildAsyncWithHttpInfo($guild_id, $prune_guild_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pruneGuildAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\PruneGuildRequest $prune_guild_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pruneGuild'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function pruneGuildAsyncWithHttpInfo(
        $guild_id,
        $prune_guild_request,
        string $contentType = self::contentTypes['pruneGuild'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildPruneResponse';
        $request = $this->pruneGuildRequest($guild_id, $prune_guild_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pruneGuild'
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\PruneGuildRequest $prune_guild_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pruneGuild'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function pruneGuildRequest(
        $guild_id,
        $prune_guild_request,
        string $contentType = self::contentTypes['pruneGuild'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling pruneGuild'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.pruneGuild, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'prune_guild_request' is set
        if ($prune_guild_request === null || (is_array($prune_guild_request) && count($prune_guild_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $prune_guild_request when calling pruneGuild'
            );
        }


        $resourcePath = '/guilds/{guild_id}/prune';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($prune_guild_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($prune_guild_request));
            } else {
                $httpBody = $prune_guild_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putGuildsOnboarding
     *
     * @param  string $guild_id guild_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildOnboardingRequest $update_guild_onboarding_request update_guild_onboarding_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putGuildsOnboarding'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildOnboardingResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function putGuildsOnboarding(
        string $guild_id,
        \OpenAPI\Client\Model\UpdateGuildOnboardingRequest $update_guild_onboarding_request,
        string $contentType = self::contentTypes['putGuildsOnboarding'][0]
    ): \OpenAPI\Client\Model\GuildOnboardingResponse
    {
        list($response) = $this->putGuildsOnboardingWithHttpInfo($guild_id, $update_guild_onboarding_request, $contentType);
        return $response;
    }

    /**
     * Operation putGuildsOnboardingWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildOnboardingRequest $update_guild_onboarding_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putGuildsOnboarding'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildOnboardingResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function putGuildsOnboardingWithHttpInfo(
        string $guild_id,
        \OpenAPI\Client\Model\UpdateGuildOnboardingRequest $update_guild_onboarding_request,
        string $contentType = self::contentTypes['putGuildsOnboarding'][0]
    ): array
    {
        $request = $this->putGuildsOnboardingRequest($guild_id, $update_guild_onboarding_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildOnboardingResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildOnboardingResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildOnboardingResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildOnboardingResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildOnboardingResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation putGuildsOnboardingAsync
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildOnboardingRequest $update_guild_onboarding_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putGuildsOnboarding'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function putGuildsOnboardingAsync(
        string $guild_id,
        \OpenAPI\Client\Model\UpdateGuildOnboardingRequest $update_guild_onboarding_request,
        string $contentType = self::contentTypes['putGuildsOnboarding'][0]
    ): PromiseInterface
    {
        return $this->putGuildsOnboardingAsyncWithHttpInfo($guild_id, $update_guild_onboarding_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putGuildsOnboardingAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildOnboardingRequest $update_guild_onboarding_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putGuildsOnboarding'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function putGuildsOnboardingAsyncWithHttpInfo(
        $guild_id,
        $update_guild_onboarding_request,
        string $contentType = self::contentTypes['putGuildsOnboarding'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildOnboardingResponse';
        $request = $this->putGuildsOnboardingRequest($guild_id, $update_guild_onboarding_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putGuildsOnboarding'
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildOnboardingRequest $update_guild_onboarding_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putGuildsOnboarding'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putGuildsOnboardingRequest(
        $guild_id,
        $update_guild_onboarding_request,
        string $contentType = self::contentTypes['putGuildsOnboarding'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling putGuildsOnboarding'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.putGuildsOnboarding, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'update_guild_onboarding_request' is set
        if ($update_guild_onboarding_request === null || (is_array($update_guild_onboarding_request) && count($update_guild_onboarding_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $update_guild_onboarding_request when calling putGuildsOnboarding'
            );
        }


        $resourcePath = '/guilds/{guild_id}/onboarding';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_guild_onboarding_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_guild_onboarding_request));
            } else {
                $httpBody = $update_guild_onboarding_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchGuildMembers
     *
     * @param  int $limit limit (required)
     * @param  string $query query (required)
     * @param  string $guild_id guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchGuildMembers'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildMemberResponse[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function searchGuildMembers(
        int $limit,
        string $query,
        string $guild_id,
        string $contentType = self::contentTypes['searchGuildMembers'][0]
    ): array
    {
        list($response) = $this->searchGuildMembersWithHttpInfo($limit, $query, $guild_id, $contentType);
        return $response;
    }

    /**
     * Operation searchGuildMembersWithHttpInfo
     *
     * @param  int $limit (required)
     * @param  string $query (required)
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchGuildMembers'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildMemberResponse[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchGuildMembersWithHttpInfo(
        int $limit,
        string $query,
        string $guild_id,
        string $contentType = self::contentTypes['searchGuildMembers'][0]
    ): array
    {
        $request = $this->searchGuildMembersRequest($limit, $query, $guild_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildMemberResponse[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildMemberResponse[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildMemberResponse[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildMemberResponse[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildMemberResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation searchGuildMembersAsync
     *
     * @param  int $limit (required)
     * @param  string $query (required)
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchGuildMembers'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function searchGuildMembersAsync(
        int $limit,
        string $query,
        string $guild_id,
        string $contentType = self::contentTypes['searchGuildMembers'][0]
    ): PromiseInterface
    {
        return $this->searchGuildMembersAsyncWithHttpInfo($limit, $query, $guild_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchGuildMembersAsyncWithHttpInfo
     *
     * @param  int $limit (required)
     * @param  string $query (required)
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchGuildMembers'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function searchGuildMembersAsyncWithHttpInfo(
        $limit,
        $query,
        $guild_id,
        string $contentType = self::contentTypes['searchGuildMembers'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildMemberResponse[]';
        $request = $this->searchGuildMembersRequest($limit, $query, $guild_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchGuildMembers'
     *
     * @param  int $limit (required)
     * @param  string $query (required)
     * @param  string $guild_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchGuildMembers'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchGuildMembersRequest(
        $limit,
        $query,
        $guild_id,
        string $contentType = self::contentTypes['searchGuildMembers'][0]
    ): Request
    {

        // verify the required parameter 'limit' is set
        if ($limit === null || (is_array($limit) && count($limit) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $limit when calling searchGuildMembers'
            );
        }
        if ($limit > 1000) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling DefaultAPI.searchGuildMembers, must be smaller than or equal to 1000.');
        }
        if ($limit < 1) {
            throw new InvalidArgumentException('invalid value for "$limit" when calling DefaultAPI.searchGuildMembers, must be bigger than or equal to 1.');
        }
        
        // verify the required parameter 'query' is set
        if ($query === null || (is_array($query) && count($query) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $query when calling searchGuildMembers'
            );
        }
        if (strlen($query) > 100) {
            throw new InvalidArgumentException('invalid length for "$query" when calling DefaultAPI.searchGuildMembers, must be smaller than or equal to 100.');
        }
        if (strlen($query) < 1) {
            throw new InvalidArgumentException('invalid length for "$query" when calling DefaultAPI.searchGuildMembers, must be bigger than or equal to 1.');
        }
        
        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling searchGuildMembers'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.searchGuildMembers, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/members/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $query,
            'query', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setChannelPermissionOverwrite
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $overwrite_id overwrite_id (required)
     * @param  \OpenAPI\Client\Model\SetChannelPermissionOverwriteRequest $set_channel_permission_overwrite_request set_channel_permission_overwrite_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setChannelPermissionOverwrite'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function setChannelPermissionOverwrite(
        string $channel_id,
        string $overwrite_id,
        \OpenAPI\Client\Model\SetChannelPermissionOverwriteRequest $set_channel_permission_overwrite_request,
        string $contentType = self::contentTypes['setChannelPermissionOverwrite'][0]
    ): void
    {
        $this->setChannelPermissionOverwriteWithHttpInfo($channel_id, $overwrite_id, $set_channel_permission_overwrite_request, $contentType);
    }

    /**
     * Operation setChannelPermissionOverwriteWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $overwrite_id (required)
     * @param  \OpenAPI\Client\Model\SetChannelPermissionOverwriteRequest $set_channel_permission_overwrite_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setChannelPermissionOverwrite'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setChannelPermissionOverwriteWithHttpInfo(
        string $channel_id,
        string $overwrite_id,
        \OpenAPI\Client\Model\SetChannelPermissionOverwriteRequest $set_channel_permission_overwrite_request,
        string $contentType = self::contentTypes['setChannelPermissionOverwrite'][0]
    ): array
    {
        $request = $this->setChannelPermissionOverwriteRequest($channel_id, $overwrite_id, $set_channel_permission_overwrite_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation setChannelPermissionOverwriteAsync
     *
     * @param  string $channel_id (required)
     * @param  string $overwrite_id (required)
     * @param  \OpenAPI\Client\Model\SetChannelPermissionOverwriteRequest $set_channel_permission_overwrite_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setChannelPermissionOverwrite'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function setChannelPermissionOverwriteAsync(
        string $channel_id,
        string $overwrite_id,
        \OpenAPI\Client\Model\SetChannelPermissionOverwriteRequest $set_channel_permission_overwrite_request,
        string $contentType = self::contentTypes['setChannelPermissionOverwrite'][0]
    ): PromiseInterface
    {
        return $this->setChannelPermissionOverwriteAsyncWithHttpInfo($channel_id, $overwrite_id, $set_channel_permission_overwrite_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setChannelPermissionOverwriteAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $overwrite_id (required)
     * @param  \OpenAPI\Client\Model\SetChannelPermissionOverwriteRequest $set_channel_permission_overwrite_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setChannelPermissionOverwrite'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function setChannelPermissionOverwriteAsyncWithHttpInfo(
        $channel_id,
        $overwrite_id,
        $set_channel_permission_overwrite_request,
        string $contentType = self::contentTypes['setChannelPermissionOverwrite'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->setChannelPermissionOverwriteRequest($channel_id, $overwrite_id, $set_channel_permission_overwrite_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setChannelPermissionOverwrite'
     *
     * @param  string $channel_id (required)
     * @param  string $overwrite_id (required)
     * @param  \OpenAPI\Client\Model\SetChannelPermissionOverwriteRequest $set_channel_permission_overwrite_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setChannelPermissionOverwrite'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setChannelPermissionOverwriteRequest(
        $channel_id,
        $overwrite_id,
        $set_channel_permission_overwrite_request,
        string $contentType = self::contentTypes['setChannelPermissionOverwrite'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling setChannelPermissionOverwrite'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.setChannelPermissionOverwrite, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'overwrite_id' is set
        if ($overwrite_id === null || (is_array($overwrite_id) && count($overwrite_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $overwrite_id when calling setChannelPermissionOverwrite'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $overwrite_id)) {
            throw new InvalidArgumentException("invalid value for \"overwrite_id\" when calling DefaultAPI.setChannelPermissionOverwrite, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'set_channel_permission_overwrite_request' is set
        if ($set_channel_permission_overwrite_request === null || (is_array($set_channel_permission_overwrite_request) && count($set_channel_permission_overwrite_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $set_channel_permission_overwrite_request when calling setChannelPermissionOverwrite'
            );
        }


        $resourcePath = '/channels/{channel_id}/permissions/{overwrite_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }
        // path params
        if ($overwrite_id !== null) {
            $resourcePath = str_replace(
                '{' . 'overwrite_id' . '}',
                ObjectSerializer::toPathValue($overwrite_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($set_channel_permission_overwrite_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($set_channel_permission_overwrite_request));
            } else {
                $httpBody = $set_channel_permission_overwrite_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setGuildApplicationCommandPermissions
     *
     * @param  string $application_id application_id (required)
     * @param  string $guild_id guild_id (required)
     * @param  string $command_id command_id (required)
     * @param  \OpenAPI\Client\Model\SetGuildApplicationCommandPermissionsRequest $set_guild_application_command_permissions_request set_guild_application_command_permissions_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setGuildApplicationCommandPermissions'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\CommandPermissionsResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function setGuildApplicationCommandPermissions(
        string $application_id,
        string $guild_id,
        string $command_id,
        \OpenAPI\Client\Model\SetGuildApplicationCommandPermissionsRequest $set_guild_application_command_permissions_request,
        string $contentType = self::contentTypes['setGuildApplicationCommandPermissions'][0]
    ): \OpenAPI\Client\Model\CommandPermissionsResponse
    {
        list($response) = $this->setGuildApplicationCommandPermissionsWithHttpInfo($application_id, $guild_id, $command_id, $set_guild_application_command_permissions_request, $contentType);
        return $response;
    }

    /**
     * Operation setGuildApplicationCommandPermissionsWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  string $command_id (required)
     * @param  \OpenAPI\Client\Model\SetGuildApplicationCommandPermissionsRequest $set_guild_application_command_permissions_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setGuildApplicationCommandPermissions'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CommandPermissionsResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function setGuildApplicationCommandPermissionsWithHttpInfo(
        string $application_id,
        string $guild_id,
        string $command_id,
        \OpenAPI\Client\Model\SetGuildApplicationCommandPermissionsRequest $set_guild_application_command_permissions_request,
        string $contentType = self::contentTypes['setGuildApplicationCommandPermissions'][0]
    ): array
    {
        $request = $this->setGuildApplicationCommandPermissionsRequest($application_id, $guild_id, $command_id, $set_guild_application_command_permissions_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CommandPermissionsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CommandPermissionsResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CommandPermissionsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\CommandPermissionsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CommandPermissionsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation setGuildApplicationCommandPermissionsAsync
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  string $command_id (required)
     * @param  \OpenAPI\Client\Model\SetGuildApplicationCommandPermissionsRequest $set_guild_application_command_permissions_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setGuildApplicationCommandPermissions'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function setGuildApplicationCommandPermissionsAsync(
        string $application_id,
        string $guild_id,
        string $command_id,
        \OpenAPI\Client\Model\SetGuildApplicationCommandPermissionsRequest $set_guild_application_command_permissions_request,
        string $contentType = self::contentTypes['setGuildApplicationCommandPermissions'][0]
    ): PromiseInterface
    {
        return $this->setGuildApplicationCommandPermissionsAsyncWithHttpInfo($application_id, $guild_id, $command_id, $set_guild_application_command_permissions_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setGuildApplicationCommandPermissionsAsyncWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  string $command_id (required)
     * @param  \OpenAPI\Client\Model\SetGuildApplicationCommandPermissionsRequest $set_guild_application_command_permissions_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setGuildApplicationCommandPermissions'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function setGuildApplicationCommandPermissionsAsyncWithHttpInfo(
        $application_id,
        $guild_id,
        $command_id,
        $set_guild_application_command_permissions_request,
        string $contentType = self::contentTypes['setGuildApplicationCommandPermissions'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\CommandPermissionsResponse';
        $request = $this->setGuildApplicationCommandPermissionsRequest($application_id, $guild_id, $command_id, $set_guild_application_command_permissions_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setGuildApplicationCommandPermissions'
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  string $command_id (required)
     * @param  \OpenAPI\Client\Model\SetGuildApplicationCommandPermissionsRequest $set_guild_application_command_permissions_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setGuildApplicationCommandPermissions'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setGuildApplicationCommandPermissionsRequest(
        $application_id,
        $guild_id,
        $command_id,
        $set_guild_application_command_permissions_request,
        string $contentType = self::contentTypes['setGuildApplicationCommandPermissions'][0]
    ): Request
    {

        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_id when calling setGuildApplicationCommandPermissions'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $application_id)) {
            throw new InvalidArgumentException("invalid value for \"application_id\" when calling DefaultAPI.setGuildApplicationCommandPermissions, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling setGuildApplicationCommandPermissions'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.setGuildApplicationCommandPermissions, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'command_id' is set
        if ($command_id === null || (is_array($command_id) && count($command_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $command_id when calling setGuildApplicationCommandPermissions'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $command_id)) {
            throw new InvalidArgumentException("invalid value for \"command_id\" when calling DefaultAPI.setGuildApplicationCommandPermissions, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'set_guild_application_command_permissions_request' is set
        if ($set_guild_application_command_permissions_request === null || (is_array($set_guild_application_command_permissions_request) && count($set_guild_application_command_permissions_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $set_guild_application_command_permissions_request when calling setGuildApplicationCommandPermissions'
            );
        }


        $resourcePath = '/applications/{application_id}/guilds/{guild_id}/commands/{command_id}/permissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'application_id' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($command_id !== null) {
            $resourcePath = str_replace(
                '{' . 'command_id' . '}',
                ObjectSerializer::toPathValue($command_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($set_guild_application_command_permissions_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($set_guild_application_command_permissions_request));
            } else {
                $httpBody = $set_guild_application_command_permissions_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setGuildMfaLevel
     *
     * @param  string $guild_id guild_id (required)
     * @param  \OpenAPI\Client\Model\SetGuildMfaLevelRequest $set_guild_mfa_level_request set_guild_mfa_level_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setGuildMfaLevel'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildMFALevelResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function setGuildMfaLevel(
        string $guild_id,
        \OpenAPI\Client\Model\SetGuildMfaLevelRequest $set_guild_mfa_level_request,
        string $contentType = self::contentTypes['setGuildMfaLevel'][0]
    ): \OpenAPI\Client\Model\GuildMFALevelResponse
    {
        list($response) = $this->setGuildMfaLevelWithHttpInfo($guild_id, $set_guild_mfa_level_request, $contentType);
        return $response;
    }

    /**
     * Operation setGuildMfaLevelWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\SetGuildMfaLevelRequest $set_guild_mfa_level_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setGuildMfaLevel'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildMFALevelResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function setGuildMfaLevelWithHttpInfo(
        string $guild_id,
        \OpenAPI\Client\Model\SetGuildMfaLevelRequest $set_guild_mfa_level_request,
        string $contentType = self::contentTypes['setGuildMfaLevel'][0]
    ): array
    {
        $request = $this->setGuildMfaLevelRequest($guild_id, $set_guild_mfa_level_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildMFALevelResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildMFALevelResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildMFALevelResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildMFALevelResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildMFALevelResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation setGuildMfaLevelAsync
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\SetGuildMfaLevelRequest $set_guild_mfa_level_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setGuildMfaLevel'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function setGuildMfaLevelAsync(
        string $guild_id,
        \OpenAPI\Client\Model\SetGuildMfaLevelRequest $set_guild_mfa_level_request,
        string $contentType = self::contentTypes['setGuildMfaLevel'][0]
    ): PromiseInterface
    {
        return $this->setGuildMfaLevelAsyncWithHttpInfo($guild_id, $set_guild_mfa_level_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setGuildMfaLevelAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\SetGuildMfaLevelRequest $set_guild_mfa_level_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setGuildMfaLevel'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function setGuildMfaLevelAsyncWithHttpInfo(
        $guild_id,
        $set_guild_mfa_level_request,
        string $contentType = self::contentTypes['setGuildMfaLevel'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildMFALevelResponse';
        $request = $this->setGuildMfaLevelRequest($guild_id, $set_guild_mfa_level_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setGuildMfaLevel'
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\SetGuildMfaLevelRequest $set_guild_mfa_level_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setGuildMfaLevel'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setGuildMfaLevelRequest(
        $guild_id,
        $set_guild_mfa_level_request,
        string $contentType = self::contentTypes['setGuildMfaLevel'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling setGuildMfaLevel'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.setGuildMfaLevel, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'set_guild_mfa_level_request' is set
        if ($set_guild_mfa_level_request === null || (is_array($set_guild_mfa_level_request) && count($set_guild_mfa_level_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $set_guild_mfa_level_request when calling setGuildMfaLevel'
            );
        }


        $resourcePath = '/guilds/{guild_id}/mfa';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($set_guild_mfa_level_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($set_guild_mfa_level_request));
            } else {
                $httpBody = $set_guild_mfa_level_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation syncGuildTemplate
     *
     * @param  string $guild_id guild_id (required)
     * @param  mixed $code code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncGuildTemplate'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildTemplateResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function syncGuildTemplate(
        string $guild_id,
        mixed $code,
        string $contentType = self::contentTypes['syncGuildTemplate'][0]
    ): \OpenAPI\Client\Model\GuildTemplateResponse
    {
        list($response) = $this->syncGuildTemplateWithHttpInfo($guild_id, $code, $contentType);
        return $response;
    }

    /**
     * Operation syncGuildTemplateWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  mixed $code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncGuildTemplate'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildTemplateResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function syncGuildTemplateWithHttpInfo(
        string $guild_id,
        mixed $code,
        string $contentType = self::contentTypes['syncGuildTemplate'][0]
    ): array
    {
        $request = $this->syncGuildTemplateRequest($guild_id, $code, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildTemplateResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildTemplateResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildTemplateResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildTemplateResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildTemplateResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation syncGuildTemplateAsync
     *
     * @param  string $guild_id (required)
     * @param  mixed $code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncGuildTemplate'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function syncGuildTemplateAsync(
        string $guild_id,
        mixed $code,
        string $contentType = self::contentTypes['syncGuildTemplate'][0]
    ): PromiseInterface
    {
        return $this->syncGuildTemplateAsyncWithHttpInfo($guild_id, $code, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation syncGuildTemplateAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  mixed $code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncGuildTemplate'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function syncGuildTemplateAsyncWithHttpInfo(
        $guild_id,
        $code,
        string $contentType = self::contentTypes['syncGuildTemplate'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildTemplateResponse';
        $request = $this->syncGuildTemplateRequest($guild_id, $code, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'syncGuildTemplate'
     *
     * @param  string $guild_id (required)
     * @param  mixed $code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncGuildTemplate'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function syncGuildTemplateRequest(
        $guild_id,
        $code,
        string $contentType = self::contentTypes['syncGuildTemplate'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling syncGuildTemplate'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.syncGuildTemplate, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $code when calling syncGuildTemplate'
            );
        }
        if (strlen($code) > 152133) {
            throw new InvalidArgumentException('invalid length for "$code" when calling DefaultAPI.syncGuildTemplate, must be smaller than or equal to 152133.');
        }
        

        $resourcePath = '/guilds/{guild_id}/templates/{code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation triggerTypingIndicator
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['triggerTypingIndicator'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\ErrorResponse
     */
    public function triggerTypingIndicator(
        string $channel_id,
        string $contentType = self::contentTypes['triggerTypingIndicator'][0]
    ): object
    {
        list($response) = $this->triggerTypingIndicatorWithHttpInfo($channel_id, $contentType);
        return $response;
    }

    /**
     * Operation triggerTypingIndicatorWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['triggerTypingIndicator'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function triggerTypingIndicatorWithHttpInfo(
        string $channel_id,
        string $contentType = self::contentTypes['triggerTypingIndicator'][0]
    ): array
    {
        $request = $this->triggerTypingIndicatorRequest($channel_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation triggerTypingIndicatorAsync
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['triggerTypingIndicator'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function triggerTypingIndicatorAsync(
        string $channel_id,
        string $contentType = self::contentTypes['triggerTypingIndicator'][0]
    ): PromiseInterface
    {
        return $this->triggerTypingIndicatorAsyncWithHttpInfo($channel_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation triggerTypingIndicatorAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['triggerTypingIndicator'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function triggerTypingIndicatorAsyncWithHttpInfo(
        $channel_id,
        string $contentType = self::contentTypes['triggerTypingIndicator'][0]
    ): PromiseInterface
    {
        $returnType = 'object';
        $request = $this->triggerTypingIndicatorRequest($channel_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'triggerTypingIndicator'
     *
     * @param  string $channel_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['triggerTypingIndicator'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function triggerTypingIndicatorRequest(
        $channel_id,
        string $contentType = self::contentTypes['triggerTypingIndicator'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling triggerTypingIndicator'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.triggerTypingIndicator, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/channels/{channel_id}/typing';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unbanUserFromGuild
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $user_id user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unbanUserFromGuild'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function unbanUserFromGuild(
        string $guild_id,
        string $user_id,
        string $contentType = self::contentTypes['unbanUserFromGuild'][0]
    ): void
    {
        $this->unbanUserFromGuildWithHttpInfo($guild_id, $user_id, $contentType);
    }

    /**
     * Operation unbanUserFromGuildWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unbanUserFromGuild'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function unbanUserFromGuildWithHttpInfo(
        string $guild_id,
        string $user_id,
        string $contentType = self::contentTypes['unbanUserFromGuild'][0]
    ): array
    {
        $request = $this->unbanUserFromGuildRequest($guild_id, $user_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation unbanUserFromGuildAsync
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unbanUserFromGuild'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function unbanUserFromGuildAsync(
        string $guild_id,
        string $user_id,
        string $contentType = self::contentTypes['unbanUserFromGuild'][0]
    ): PromiseInterface
    {
        return $this->unbanUserFromGuildAsyncWithHttpInfo($guild_id, $user_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unbanUserFromGuildAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unbanUserFromGuild'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function unbanUserFromGuildAsyncWithHttpInfo(
        $guild_id,
        $user_id,
        string $contentType = self::contentTypes['unbanUserFromGuild'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->unbanUserFromGuildRequest($guild_id, $user_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unbanUserFromGuild'
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unbanUserFromGuild'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unbanUserFromGuildRequest(
        $guild_id,
        $user_id,
        string $contentType = self::contentTypes['unbanUserFromGuild'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling unbanUserFromGuild'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.unbanUserFromGuild, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $user_id when calling unbanUserFromGuild'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $user_id)) {
            throw new InvalidArgumentException("invalid value for \"user_id\" when calling DefaultAPI.unbanUserFromGuild, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/guilds/{guild_id}/bans/{user_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unpinMessage
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $message_id message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unpinMessage'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function unpinMessage(
        string $channel_id,
        string $message_id,
        string $contentType = self::contentTypes['unpinMessage'][0]
    ): void
    {
        $this->unpinMessageWithHttpInfo($channel_id, $message_id, $contentType);
    }

    /**
     * Operation unpinMessageWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unpinMessage'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function unpinMessageWithHttpInfo(
        string $channel_id,
        string $message_id,
        string $contentType = self::contentTypes['unpinMessage'][0]
    ): array
    {
        $request = $this->unpinMessageRequest($channel_id, $message_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation unpinMessageAsync
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unpinMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function unpinMessageAsync(
        string $channel_id,
        string $message_id,
        string $contentType = self::contentTypes['unpinMessage'][0]
    ): PromiseInterface
    {
        return $this->unpinMessageAsyncWithHttpInfo($channel_id, $message_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unpinMessageAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unpinMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function unpinMessageAsyncWithHttpInfo(
        $channel_id,
        $message_id,
        string $contentType = self::contentTypes['unpinMessage'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->unpinMessageRequest($channel_id, $message_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unpinMessage'
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unpinMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unpinMessageRequest(
        $channel_id,
        $message_id,
        string $contentType = self::contentTypes['unpinMessage'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling unpinMessage'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.unpinMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $message_id when calling unpinMessage'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $message_id)) {
            throw new InvalidArgumentException("invalid value for \"message_id\" when calling DefaultAPI.unpinMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/channels/{channel_id}/pins/{message_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'message_id' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateApplication
     *
     * @param  string $application_id application_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationFormPartial $application_form_partial application_form_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateApplication'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\PrivateApplicationResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function updateApplication(
        string $application_id,
        \OpenAPI\Client\Model\ApplicationFormPartial $application_form_partial,
        string $contentType = self::contentTypes['updateApplication'][0]
    ): \OpenAPI\Client\Model\PrivateApplicationResponse
    {
        list($response) = $this->updateApplicationWithHttpInfo($application_id, $application_form_partial, $contentType);
        return $response;
    }

    /**
     * Operation updateApplicationWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationFormPartial $application_form_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateApplication'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PrivateApplicationResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateApplicationWithHttpInfo(
        string $application_id,
        \OpenAPI\Client\Model\ApplicationFormPartial $application_form_partial,
        string $contentType = self::contentTypes['updateApplication'][0]
    ): array
    {
        $request = $this->updateApplicationRequest($application_id, $application_form_partial, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PrivateApplicationResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PrivateApplicationResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PrivateApplicationResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\PrivateApplicationResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PrivateApplicationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation updateApplicationAsync
     *
     * @param  string $application_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationFormPartial $application_form_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateApplication'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateApplicationAsync(
        string $application_id,
        \OpenAPI\Client\Model\ApplicationFormPartial $application_form_partial,
        string $contentType = self::contentTypes['updateApplication'][0]
    ): PromiseInterface
    {
        return $this->updateApplicationAsyncWithHttpInfo($application_id, $application_form_partial, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateApplicationAsyncWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationFormPartial $application_form_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateApplication'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateApplicationAsyncWithHttpInfo(
        $application_id,
        $application_form_partial,
        string $contentType = self::contentTypes['updateApplication'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\PrivateApplicationResponse';
        $request = $this->updateApplicationRequest($application_id, $application_form_partial, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateApplication'
     *
     * @param  string $application_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationFormPartial $application_form_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateApplication'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateApplicationRequest(
        $application_id,
        $application_form_partial,
        string $contentType = self::contentTypes['updateApplication'][0]
    ): Request
    {

        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_id when calling updateApplication'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $application_id)) {
            throw new InvalidArgumentException("invalid value for \"application_id\" when calling DefaultAPI.updateApplication, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'application_form_partial' is set
        if ($application_form_partial === null || (is_array($application_form_partial) && count($application_form_partial) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_form_partial when calling updateApplication'
            );
        }


        $resourcePath = '/applications/{application_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'application_id' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($application_form_partial)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($application_form_partial));
            } else {
                $httpBody = $application_form_partial;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateApplicationCommand
     *
     * @param  string $application_id application_id (required)
     * @param  string $command_id command_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandPatchRequestPartial $application_command_patch_request_partial application_command_patch_request_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateApplicationCommand'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApplicationCommandResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function updateApplicationCommand(
        string $application_id,
        string $command_id,
        \OpenAPI\Client\Model\ApplicationCommandPatchRequestPartial $application_command_patch_request_partial,
        string $contentType = self::contentTypes['updateApplicationCommand'][0]
    ): \OpenAPI\Client\Model\ApplicationCommandResponse
    {
        list($response) = $this->updateApplicationCommandWithHttpInfo($application_id, $command_id, $application_command_patch_request_partial, $contentType);
        return $response;
    }

    /**
     * Operation updateApplicationCommandWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $command_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandPatchRequestPartial $application_command_patch_request_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateApplicationCommand'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApplicationCommandResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateApplicationCommandWithHttpInfo(
        string $application_id,
        string $command_id,
        \OpenAPI\Client\Model\ApplicationCommandPatchRequestPartial $application_command_patch_request_partial,
        string $contentType = self::contentTypes['updateApplicationCommand'][0]
    ): array
    {
        $request = $this->updateApplicationCommandRequest($application_id, $command_id, $application_command_patch_request_partial, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ApplicationCommandResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ApplicationCommandResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApplicationCommandResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ApplicationCommandResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApplicationCommandResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation updateApplicationCommandAsync
     *
     * @param  string $application_id (required)
     * @param  string $command_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandPatchRequestPartial $application_command_patch_request_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateApplicationCommand'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateApplicationCommandAsync(
        string $application_id,
        string $command_id,
        \OpenAPI\Client\Model\ApplicationCommandPatchRequestPartial $application_command_patch_request_partial,
        string $contentType = self::contentTypes['updateApplicationCommand'][0]
    ): PromiseInterface
    {
        return $this->updateApplicationCommandAsyncWithHttpInfo($application_id, $command_id, $application_command_patch_request_partial, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateApplicationCommandAsyncWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $command_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandPatchRequestPartial $application_command_patch_request_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateApplicationCommand'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateApplicationCommandAsyncWithHttpInfo(
        $application_id,
        $command_id,
        $application_command_patch_request_partial,
        string $contentType = self::contentTypes['updateApplicationCommand'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ApplicationCommandResponse';
        $request = $this->updateApplicationCommandRequest($application_id, $command_id, $application_command_patch_request_partial, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateApplicationCommand'
     *
     * @param  string $application_id (required)
     * @param  string $command_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandPatchRequestPartial $application_command_patch_request_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateApplicationCommand'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateApplicationCommandRequest(
        $application_id,
        $command_id,
        $application_command_patch_request_partial,
        string $contentType = self::contentTypes['updateApplicationCommand'][0]
    ): Request
    {

        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_id when calling updateApplicationCommand'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $application_id)) {
            throw new InvalidArgumentException("invalid value for \"application_id\" when calling DefaultAPI.updateApplicationCommand, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'command_id' is set
        if ($command_id === null || (is_array($command_id) && count($command_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $command_id when calling updateApplicationCommand'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $command_id)) {
            throw new InvalidArgumentException("invalid value for \"command_id\" when calling DefaultAPI.updateApplicationCommand, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'application_command_patch_request_partial' is set
        if ($application_command_patch_request_partial === null || (is_array($application_command_patch_request_partial) && count($application_command_patch_request_partial) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_command_patch_request_partial when calling updateApplicationCommand'
            );
        }


        $resourcePath = '/applications/{application_id}/commands/{command_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'application_id' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($command_id !== null) {
            $resourcePath = str_replace(
                '{' . 'command_id' . '}',
                ObjectSerializer::toPathValue($command_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($application_command_patch_request_partial)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($application_command_patch_request_partial));
            } else {
                $httpBody = $application_command_patch_request_partial;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateApplicationRoleConnectionsMetadata
     *
     * @param  string $application_id application_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationRoleConnectionsMetadataItemRequest[] $application_role_connections_metadata_item_request application_role_connections_metadata_item_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateApplicationRoleConnectionsMetadata'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApplicationRoleConnectionsMetadataItemResponse[]|\OpenAPI\Client\Model\ErrorResponse
     */
    public function updateApplicationRoleConnectionsMetadata(
        string $application_id,
        array $application_role_connections_metadata_item_request,
        string $contentType = self::contentTypes['updateApplicationRoleConnectionsMetadata'][0]
    ): array
    {
        list($response) = $this->updateApplicationRoleConnectionsMetadataWithHttpInfo($application_id, $application_role_connections_metadata_item_request, $contentType);
        return $response;
    }

    /**
     * Operation updateApplicationRoleConnectionsMetadataWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationRoleConnectionsMetadataItemRequest[] $application_role_connections_metadata_item_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateApplicationRoleConnectionsMetadata'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApplicationRoleConnectionsMetadataItemResponse[]|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateApplicationRoleConnectionsMetadataWithHttpInfo(
        string $application_id,
        array $application_role_connections_metadata_item_request,
        string $contentType = self::contentTypes['updateApplicationRoleConnectionsMetadata'][0]
    ): array
    {
        $request = $this->updateApplicationRoleConnectionsMetadataRequest($application_id, $application_role_connections_metadata_item_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ApplicationRoleConnectionsMetadataItemResponse[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ApplicationRoleConnectionsMetadataItemResponse[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApplicationRoleConnectionsMetadataItemResponse[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ApplicationRoleConnectionsMetadataItemResponse[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApplicationRoleConnectionsMetadataItemResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation updateApplicationRoleConnectionsMetadataAsync
     *
     * @param  string $application_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationRoleConnectionsMetadataItemRequest[] $application_role_connections_metadata_item_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateApplicationRoleConnectionsMetadata'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateApplicationRoleConnectionsMetadataAsync(
        string $application_id,
        array $application_role_connections_metadata_item_request,
        string $contentType = self::contentTypes['updateApplicationRoleConnectionsMetadata'][0]
    ): PromiseInterface
    {
        return $this->updateApplicationRoleConnectionsMetadataAsyncWithHttpInfo($application_id, $application_role_connections_metadata_item_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateApplicationRoleConnectionsMetadataAsyncWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationRoleConnectionsMetadataItemRequest[] $application_role_connections_metadata_item_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateApplicationRoleConnectionsMetadata'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateApplicationRoleConnectionsMetadataAsyncWithHttpInfo(
        $application_id,
        $application_role_connections_metadata_item_request,
        string $contentType = self::contentTypes['updateApplicationRoleConnectionsMetadata'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ApplicationRoleConnectionsMetadataItemResponse[]';
        $request = $this->updateApplicationRoleConnectionsMetadataRequest($application_id, $application_role_connections_metadata_item_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateApplicationRoleConnectionsMetadata'
     *
     * @param  string $application_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationRoleConnectionsMetadataItemRequest[] $application_role_connections_metadata_item_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateApplicationRoleConnectionsMetadata'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateApplicationRoleConnectionsMetadataRequest(
        $application_id,
        $application_role_connections_metadata_item_request,
        string $contentType = self::contentTypes['updateApplicationRoleConnectionsMetadata'][0]
    ): Request
    {

        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_id when calling updateApplicationRoleConnectionsMetadata'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $application_id)) {
            throw new InvalidArgumentException("invalid value for \"application_id\" when calling DefaultAPI.updateApplicationRoleConnectionsMetadata, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'application_role_connections_metadata_item_request' is set
        if ($application_role_connections_metadata_item_request === null || (is_array($application_role_connections_metadata_item_request) && count($application_role_connections_metadata_item_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_role_connections_metadata_item_request when calling updateApplicationRoleConnectionsMetadata'
            );
        }


        $resourcePath = '/applications/{application_id}/role-connections/metadata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'application_id' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($application_role_connections_metadata_item_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($application_role_connections_metadata_item_request));
            } else {
                $httpBody = $application_role_connections_metadata_item_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateApplicationUserRoleConnection
     *
     * @param  string $application_id application_id (required)
     * @param  \OpenAPI\Client\Model\UpdateApplicationUserRoleConnectionRequest $update_application_user_role_connection_request update_application_user_role_connection_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateApplicationUserRoleConnection'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApplicationUserRoleConnectionResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function updateApplicationUserRoleConnection(
        string $application_id,
        \OpenAPI\Client\Model\UpdateApplicationUserRoleConnectionRequest $update_application_user_role_connection_request,
        string $contentType = self::contentTypes['updateApplicationUserRoleConnection'][0]
    ): \OpenAPI\Client\Model\ApplicationUserRoleConnectionResponse
    {
        list($response) = $this->updateApplicationUserRoleConnectionWithHttpInfo($application_id, $update_application_user_role_connection_request, $contentType);
        return $response;
    }

    /**
     * Operation updateApplicationUserRoleConnectionWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  \OpenAPI\Client\Model\UpdateApplicationUserRoleConnectionRequest $update_application_user_role_connection_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateApplicationUserRoleConnection'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApplicationUserRoleConnectionResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateApplicationUserRoleConnectionWithHttpInfo(
        string $application_id,
        \OpenAPI\Client\Model\UpdateApplicationUserRoleConnectionRequest $update_application_user_role_connection_request,
        string $contentType = self::contentTypes['updateApplicationUserRoleConnection'][0]
    ): array
    {
        $request = $this->updateApplicationUserRoleConnectionRequest($application_id, $update_application_user_role_connection_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ApplicationUserRoleConnectionResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ApplicationUserRoleConnectionResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApplicationUserRoleConnectionResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ApplicationUserRoleConnectionResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApplicationUserRoleConnectionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation updateApplicationUserRoleConnectionAsync
     *
     * @param  string $application_id (required)
     * @param  \OpenAPI\Client\Model\UpdateApplicationUserRoleConnectionRequest $update_application_user_role_connection_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateApplicationUserRoleConnection'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateApplicationUserRoleConnectionAsync(
        string $application_id,
        \OpenAPI\Client\Model\UpdateApplicationUserRoleConnectionRequest $update_application_user_role_connection_request,
        string $contentType = self::contentTypes['updateApplicationUserRoleConnection'][0]
    ): PromiseInterface
    {
        return $this->updateApplicationUserRoleConnectionAsyncWithHttpInfo($application_id, $update_application_user_role_connection_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateApplicationUserRoleConnectionAsyncWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  \OpenAPI\Client\Model\UpdateApplicationUserRoleConnectionRequest $update_application_user_role_connection_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateApplicationUserRoleConnection'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateApplicationUserRoleConnectionAsyncWithHttpInfo(
        $application_id,
        $update_application_user_role_connection_request,
        string $contentType = self::contentTypes['updateApplicationUserRoleConnection'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ApplicationUserRoleConnectionResponse';
        $request = $this->updateApplicationUserRoleConnectionRequest($application_id, $update_application_user_role_connection_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateApplicationUserRoleConnection'
     *
     * @param  string $application_id (required)
     * @param  \OpenAPI\Client\Model\UpdateApplicationUserRoleConnectionRequest $update_application_user_role_connection_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateApplicationUserRoleConnection'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateApplicationUserRoleConnectionRequest(
        $application_id,
        $update_application_user_role_connection_request,
        string $contentType = self::contentTypes['updateApplicationUserRoleConnection'][0]
    ): Request
    {

        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_id when calling updateApplicationUserRoleConnection'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $application_id)) {
            throw new InvalidArgumentException("invalid value for \"application_id\" when calling DefaultAPI.updateApplicationUserRoleConnection, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'update_application_user_role_connection_request' is set
        if ($update_application_user_role_connection_request === null || (is_array($update_application_user_role_connection_request) && count($update_application_user_role_connection_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $update_application_user_role_connection_request when calling updateApplicationUserRoleConnection'
            );
        }


        $resourcePath = '/users/@me/applications/{application_id}/role-connection';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'application_id' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_application_user_role_connection_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_application_user_role_connection_request));
            } else {
                $httpBody = $update_application_user_role_connection_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAutoModerationRule
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $rule_id rule_id (required)
     * @param  \OpenAPI\Client\Model\UpdateAutoModerationRuleRequest $update_auto_moderation_rule_request update_auto_moderation_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAutoModerationRule'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetAutoModerationRule200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function updateAutoModerationRule(
        string $guild_id,
        string $rule_id,
        \OpenAPI\Client\Model\UpdateAutoModerationRuleRequest $update_auto_moderation_rule_request,
        string $contentType = self::contentTypes['updateAutoModerationRule'][0]
    ): \OpenAPI\Client\Model\GetAutoModerationRule200Response
    {
        list($response) = $this->updateAutoModerationRuleWithHttpInfo($guild_id, $rule_id, $update_auto_moderation_rule_request, $contentType);
        return $response;
    }

    /**
     * Operation updateAutoModerationRuleWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $rule_id (required)
     * @param  \OpenAPI\Client\Model\UpdateAutoModerationRuleRequest $update_auto_moderation_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAutoModerationRule'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetAutoModerationRule200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAutoModerationRuleWithHttpInfo(
        string $guild_id,
        string $rule_id,
        \OpenAPI\Client\Model\UpdateAutoModerationRuleRequest $update_auto_moderation_rule_request,
        string $contentType = self::contentTypes['updateAutoModerationRule'][0]
    ): array
    {
        $request = $this->updateAutoModerationRuleRequest($guild_id, $rule_id, $update_auto_moderation_rule_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetAutoModerationRule200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetAutoModerationRule200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetAutoModerationRule200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GetAutoModerationRule200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetAutoModerationRule200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation updateAutoModerationRuleAsync
     *
     * @param  string $guild_id (required)
     * @param  string $rule_id (required)
     * @param  \OpenAPI\Client\Model\UpdateAutoModerationRuleRequest $update_auto_moderation_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAutoModerationRule'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateAutoModerationRuleAsync(
        string $guild_id,
        string $rule_id,
        \OpenAPI\Client\Model\UpdateAutoModerationRuleRequest $update_auto_moderation_rule_request,
        string $contentType = self::contentTypes['updateAutoModerationRule'][0]
    ): PromiseInterface
    {
        return $this->updateAutoModerationRuleAsyncWithHttpInfo($guild_id, $rule_id, $update_auto_moderation_rule_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAutoModerationRuleAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $rule_id (required)
     * @param  \OpenAPI\Client\Model\UpdateAutoModerationRuleRequest $update_auto_moderation_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAutoModerationRule'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateAutoModerationRuleAsyncWithHttpInfo(
        $guild_id,
        $rule_id,
        $update_auto_moderation_rule_request,
        string $contentType = self::contentTypes['updateAutoModerationRule'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GetAutoModerationRule200Response';
        $request = $this->updateAutoModerationRuleRequest($guild_id, $rule_id, $update_auto_moderation_rule_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAutoModerationRule'
     *
     * @param  string $guild_id (required)
     * @param  string $rule_id (required)
     * @param  \OpenAPI\Client\Model\UpdateAutoModerationRuleRequest $update_auto_moderation_rule_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateAutoModerationRule'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateAutoModerationRuleRequest(
        $guild_id,
        $rule_id,
        $update_auto_moderation_rule_request,
        string $contentType = self::contentTypes['updateAutoModerationRule'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling updateAutoModerationRule'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.updateAutoModerationRule, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'rule_id' is set
        if ($rule_id === null || (is_array($rule_id) && count($rule_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $rule_id when calling updateAutoModerationRule'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $rule_id)) {
            throw new InvalidArgumentException("invalid value for \"rule_id\" when calling DefaultAPI.updateAutoModerationRule, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'update_auto_moderation_rule_request' is set
        if ($update_auto_moderation_rule_request === null || (is_array($update_auto_moderation_rule_request) && count($update_auto_moderation_rule_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $update_auto_moderation_rule_request when calling updateAutoModerationRule'
            );
        }


        $resourcePath = '/guilds/{guild_id}/auto-moderation/rules/{rule_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($rule_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rule_id' . '}',
                ObjectSerializer::toPathValue($rule_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_auto_moderation_rule_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_auto_moderation_rule_request));
            } else {
                $httpBody = $update_auto_moderation_rule_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateChannel
     *
     * @param  string $channel_id channel_id (required)
     * @param  \OpenAPI\Client\Model\UpdateChannelRequest $update_channel_request update_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateChannel'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListGuildChannels200ResponseInner|\OpenAPI\Client\Model\ErrorResponse
     */
    public function updateChannel(
        string $channel_id,
        \OpenAPI\Client\Model\UpdateChannelRequest $update_channel_request,
        string $contentType = self::contentTypes['updateChannel'][0]
    ): \OpenAPI\Client\Model\ListGuildChannels200ResponseInner
    {
        list($response) = $this->updateChannelWithHttpInfo($channel_id, $update_channel_request, $contentType);
        return $response;
    }

    /**
     * Operation updateChannelWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\UpdateChannelRequest $update_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateChannel'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListGuildChannels200ResponseInner|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateChannelWithHttpInfo(
        string $channel_id,
        \OpenAPI\Client\Model\UpdateChannelRequest $update_channel_request,
        string $contentType = self::contentTypes['updateChannel'][0]
    ): array
    {
        $request = $this->updateChannelRequest($channel_id, $update_channel_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListGuildChannels200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListGuildChannels200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListGuildChannels200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ListGuildChannels200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListGuildChannels200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation updateChannelAsync
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\UpdateChannelRequest $update_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateChannel'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateChannelAsync(
        string $channel_id,
        \OpenAPI\Client\Model\UpdateChannelRequest $update_channel_request,
        string $contentType = self::contentTypes['updateChannel'][0]
    ): PromiseInterface
    {
        return $this->updateChannelAsyncWithHttpInfo($channel_id, $update_channel_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateChannelAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\UpdateChannelRequest $update_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateChannel'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateChannelAsyncWithHttpInfo(
        $channel_id,
        $update_channel_request,
        string $contentType = self::contentTypes['updateChannel'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ListGuildChannels200ResponseInner';
        $request = $this->updateChannelRequest($channel_id, $update_channel_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateChannel'
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\UpdateChannelRequest $update_channel_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateChannel'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateChannelRequest(
        $channel_id,
        $update_channel_request,
        string $contentType = self::contentTypes['updateChannel'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling updateChannel'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.updateChannel, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'update_channel_request' is set
        if ($update_channel_request === null || (is_array($update_channel_request) && count($update_channel_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $update_channel_request when calling updateChannel'
            );
        }


        $resourcePath = '/channels/{channel_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_channel_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_channel_request));
            } else {
                $httpBody = $update_channel_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateGuild
     *
     * @param  string $guild_id guild_id (required)
     * @param  \OpenAPI\Client\Model\GuildPatchRequestPartial $guild_patch_request_partial guild_patch_request_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuild'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function updateGuild(
        string $guild_id,
        \OpenAPI\Client\Model\GuildPatchRequestPartial $guild_patch_request_partial,
        string $contentType = self::contentTypes['updateGuild'][0]
    ): \OpenAPI\Client\Model\GuildResponse
    {
        list($response) = $this->updateGuildWithHttpInfo($guild_id, $guild_patch_request_partial, $contentType);
        return $response;
    }

    /**
     * Operation updateGuildWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\GuildPatchRequestPartial $guild_patch_request_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuild'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateGuildWithHttpInfo(
        string $guild_id,
        \OpenAPI\Client\Model\GuildPatchRequestPartial $guild_patch_request_partial,
        string $contentType = self::contentTypes['updateGuild'][0]
    ): array
    {
        $request = $this->updateGuildRequest($guild_id, $guild_patch_request_partial, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation updateGuildAsync
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\GuildPatchRequestPartial $guild_patch_request_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuild'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateGuildAsync(
        string $guild_id,
        \OpenAPI\Client\Model\GuildPatchRequestPartial $guild_patch_request_partial,
        string $contentType = self::contentTypes['updateGuild'][0]
    ): PromiseInterface
    {
        return $this->updateGuildAsyncWithHttpInfo($guild_id, $guild_patch_request_partial, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateGuildAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\GuildPatchRequestPartial $guild_patch_request_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuild'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateGuildAsyncWithHttpInfo(
        $guild_id,
        $guild_patch_request_partial,
        string $contentType = self::contentTypes['updateGuild'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildResponse';
        $request = $this->updateGuildRequest($guild_id, $guild_patch_request_partial, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateGuild'
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\GuildPatchRequestPartial $guild_patch_request_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuild'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateGuildRequest(
        $guild_id,
        $guild_patch_request_partial,
        string $contentType = self::contentTypes['updateGuild'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling updateGuild'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.updateGuild, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'guild_patch_request_partial' is set
        if ($guild_patch_request_partial === null || (is_array($guild_patch_request_partial) && count($guild_patch_request_partial) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_patch_request_partial when calling updateGuild'
            );
        }


        $resourcePath = '/guilds/{guild_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($guild_patch_request_partial)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($guild_patch_request_partial));
            } else {
                $httpBody = $guild_patch_request_partial;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateGuildApplicationCommand
     *
     * @param  string $application_id application_id (required)
     * @param  string $guild_id guild_id (required)
     * @param  string $command_id command_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandPatchRequestPartial $application_command_patch_request_partial application_command_patch_request_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildApplicationCommand'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ApplicationCommandResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function updateGuildApplicationCommand(
        string $application_id,
        string $guild_id,
        string $command_id,
        \OpenAPI\Client\Model\ApplicationCommandPatchRequestPartial $application_command_patch_request_partial,
        string $contentType = self::contentTypes['updateGuildApplicationCommand'][0]
    ): \OpenAPI\Client\Model\ApplicationCommandResponse
    {
        list($response) = $this->updateGuildApplicationCommandWithHttpInfo($application_id, $guild_id, $command_id, $application_command_patch_request_partial, $contentType);
        return $response;
    }

    /**
     * Operation updateGuildApplicationCommandWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  string $command_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandPatchRequestPartial $application_command_patch_request_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildApplicationCommand'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ApplicationCommandResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateGuildApplicationCommandWithHttpInfo(
        string $application_id,
        string $guild_id,
        string $command_id,
        \OpenAPI\Client\Model\ApplicationCommandPatchRequestPartial $application_command_patch_request_partial,
        string $contentType = self::contentTypes['updateGuildApplicationCommand'][0]
    ): array
    {
        $request = $this->updateGuildApplicationCommandRequest($application_id, $guild_id, $command_id, $application_command_patch_request_partial, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ApplicationCommandResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ApplicationCommandResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ApplicationCommandResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ApplicationCommandResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ApplicationCommandResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation updateGuildApplicationCommandAsync
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  string $command_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandPatchRequestPartial $application_command_patch_request_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildApplicationCommand'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateGuildApplicationCommandAsync(
        string $application_id,
        string $guild_id,
        string $command_id,
        \OpenAPI\Client\Model\ApplicationCommandPatchRequestPartial $application_command_patch_request_partial,
        string $contentType = self::contentTypes['updateGuildApplicationCommand'][0]
    ): PromiseInterface
    {
        return $this->updateGuildApplicationCommandAsyncWithHttpInfo($application_id, $guild_id, $command_id, $application_command_patch_request_partial, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateGuildApplicationCommandAsyncWithHttpInfo
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  string $command_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandPatchRequestPartial $application_command_patch_request_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildApplicationCommand'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateGuildApplicationCommandAsyncWithHttpInfo(
        $application_id,
        $guild_id,
        $command_id,
        $application_command_patch_request_partial,
        string $contentType = self::contentTypes['updateGuildApplicationCommand'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ApplicationCommandResponse';
        $request = $this->updateGuildApplicationCommandRequest($application_id, $guild_id, $command_id, $application_command_patch_request_partial, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateGuildApplicationCommand'
     *
     * @param  string $application_id (required)
     * @param  string $guild_id (required)
     * @param  string $command_id (required)
     * @param  \OpenAPI\Client\Model\ApplicationCommandPatchRequestPartial $application_command_patch_request_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildApplicationCommand'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateGuildApplicationCommandRequest(
        $application_id,
        $guild_id,
        $command_id,
        $application_command_patch_request_partial,
        string $contentType = self::contentTypes['updateGuildApplicationCommand'][0]
    ): Request
    {

        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_id when calling updateGuildApplicationCommand'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $application_id)) {
            throw new InvalidArgumentException("invalid value for \"application_id\" when calling DefaultAPI.updateGuildApplicationCommand, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling updateGuildApplicationCommand'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.updateGuildApplicationCommand, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'command_id' is set
        if ($command_id === null || (is_array($command_id) && count($command_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $command_id when calling updateGuildApplicationCommand'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $command_id)) {
            throw new InvalidArgumentException("invalid value for \"command_id\" when calling DefaultAPI.updateGuildApplicationCommand, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'application_command_patch_request_partial' is set
        if ($application_command_patch_request_partial === null || (is_array($application_command_patch_request_partial) && count($application_command_patch_request_partial) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_command_patch_request_partial when calling updateGuildApplicationCommand'
            );
        }


        $resourcePath = '/applications/{application_id}/guilds/{guild_id}/commands/{command_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'application_id' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }
        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($command_id !== null) {
            $resourcePath = str_replace(
                '{' . 'command_id' . '}',
                ObjectSerializer::toPathValue($command_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($application_command_patch_request_partial)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($application_command_patch_request_partial));
            } else {
                $httpBody = $application_command_patch_request_partial;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateGuildEmoji
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $emoji_id emoji_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildEmojiRequest $update_guild_emoji_request update_guild_emoji_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildEmoji'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmojiResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function updateGuildEmoji(
        string $guild_id,
        string $emoji_id,
        \OpenAPI\Client\Model\UpdateGuildEmojiRequest $update_guild_emoji_request,
        string $contentType = self::contentTypes['updateGuildEmoji'][0]
    ): \OpenAPI\Client\Model\EmojiResponse
    {
        list($response) = $this->updateGuildEmojiWithHttpInfo($guild_id, $emoji_id, $update_guild_emoji_request, $contentType);
        return $response;
    }

    /**
     * Operation updateGuildEmojiWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $emoji_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildEmojiRequest $update_guild_emoji_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildEmoji'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmojiResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateGuildEmojiWithHttpInfo(
        string $guild_id,
        string $emoji_id,
        \OpenAPI\Client\Model\UpdateGuildEmojiRequest $update_guild_emoji_request,
        string $contentType = self::contentTypes['updateGuildEmoji'][0]
    ): array
    {
        $request = $this->updateGuildEmojiRequest($guild_id, $emoji_id, $update_guild_emoji_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\EmojiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\EmojiResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\EmojiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\EmojiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmojiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation updateGuildEmojiAsync
     *
     * @param  string $guild_id (required)
     * @param  string $emoji_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildEmojiRequest $update_guild_emoji_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildEmoji'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateGuildEmojiAsync(
        string $guild_id,
        string $emoji_id,
        \OpenAPI\Client\Model\UpdateGuildEmojiRequest $update_guild_emoji_request,
        string $contentType = self::contentTypes['updateGuildEmoji'][0]
    ): PromiseInterface
    {
        return $this->updateGuildEmojiAsyncWithHttpInfo($guild_id, $emoji_id, $update_guild_emoji_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateGuildEmojiAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $emoji_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildEmojiRequest $update_guild_emoji_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildEmoji'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateGuildEmojiAsyncWithHttpInfo(
        $guild_id,
        $emoji_id,
        $update_guild_emoji_request,
        string $contentType = self::contentTypes['updateGuildEmoji'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\EmojiResponse';
        $request = $this->updateGuildEmojiRequest($guild_id, $emoji_id, $update_guild_emoji_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateGuildEmoji'
     *
     * @param  string $guild_id (required)
     * @param  string $emoji_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildEmojiRequest $update_guild_emoji_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildEmoji'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateGuildEmojiRequest(
        $guild_id,
        $emoji_id,
        $update_guild_emoji_request,
        string $contentType = self::contentTypes['updateGuildEmoji'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling updateGuildEmoji'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.updateGuildEmoji, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'emoji_id' is set
        if ($emoji_id === null || (is_array($emoji_id) && count($emoji_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $emoji_id when calling updateGuildEmoji'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $emoji_id)) {
            throw new InvalidArgumentException("invalid value for \"emoji_id\" when calling DefaultAPI.updateGuildEmoji, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'update_guild_emoji_request' is set
        if ($update_guild_emoji_request === null || (is_array($update_guild_emoji_request) && count($update_guild_emoji_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $update_guild_emoji_request when calling updateGuildEmoji'
            );
        }


        $resourcePath = '/guilds/{guild_id}/emojis/{emoji_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($emoji_id !== null) {
            $resourcePath = str_replace(
                '{' . 'emoji_id' . '}',
                ObjectSerializer::toPathValue($emoji_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_guild_emoji_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_guild_emoji_request));
            } else {
                $httpBody = $update_guild_emoji_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateGuildMember
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $user_id user_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildMemberRequest $update_guild_member_request update_guild_member_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildMember'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildMemberResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function updateGuildMember(
        string $guild_id,
        string $user_id,
        \OpenAPI\Client\Model\UpdateGuildMemberRequest $update_guild_member_request,
        string $contentType = self::contentTypes['updateGuildMember'][0]
    ): \OpenAPI\Client\Model\GuildMemberResponse
    {
        list($response) = $this->updateGuildMemberWithHttpInfo($guild_id, $user_id, $update_guild_member_request, $contentType);
        return $response;
    }

    /**
     * Operation updateGuildMemberWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildMemberRequest $update_guild_member_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildMember'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildMemberResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateGuildMemberWithHttpInfo(
        string $guild_id,
        string $user_id,
        \OpenAPI\Client\Model\UpdateGuildMemberRequest $update_guild_member_request,
        string $contentType = self::contentTypes['updateGuildMember'][0]
    ): array
    {
        $request = $this->updateGuildMemberRequest($guild_id, $user_id, $update_guild_member_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildMemberResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildMemberResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildMemberResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildMemberResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildMemberResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation updateGuildMemberAsync
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildMemberRequest $update_guild_member_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildMember'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateGuildMemberAsync(
        string $guild_id,
        string $user_id,
        \OpenAPI\Client\Model\UpdateGuildMemberRequest $update_guild_member_request,
        string $contentType = self::contentTypes['updateGuildMember'][0]
    ): PromiseInterface
    {
        return $this->updateGuildMemberAsyncWithHttpInfo($guild_id, $user_id, $update_guild_member_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateGuildMemberAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildMemberRequest $update_guild_member_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildMember'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateGuildMemberAsyncWithHttpInfo(
        $guild_id,
        $user_id,
        $update_guild_member_request,
        string $contentType = self::contentTypes['updateGuildMember'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildMemberResponse';
        $request = $this->updateGuildMemberRequest($guild_id, $user_id, $update_guild_member_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateGuildMember'
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildMemberRequest $update_guild_member_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildMember'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateGuildMemberRequest(
        $guild_id,
        $user_id,
        $update_guild_member_request,
        string $contentType = self::contentTypes['updateGuildMember'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling updateGuildMember'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.updateGuildMember, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $user_id when calling updateGuildMember'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $user_id)) {
            throw new InvalidArgumentException("invalid value for \"user_id\" when calling DefaultAPI.updateGuildMember, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'update_guild_member_request' is set
        if ($update_guild_member_request === null || (is_array($update_guild_member_request) && count($update_guild_member_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $update_guild_member_request when calling updateGuildMember'
            );
        }


        $resourcePath = '/guilds/{guild_id}/members/{user_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_guild_member_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_guild_member_request));
            } else {
                $httpBody = $update_guild_member_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateGuildRole
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $role_id role_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildRoleRequest $update_guild_role_request update_guild_role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildRole'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildRoleResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function updateGuildRole(
        string $guild_id,
        string $role_id,
        \OpenAPI\Client\Model\UpdateGuildRoleRequest $update_guild_role_request,
        string $contentType = self::contentTypes['updateGuildRole'][0]
    ): \OpenAPI\Client\Model\GuildRoleResponse
    {
        list($response) = $this->updateGuildRoleWithHttpInfo($guild_id, $role_id, $update_guild_role_request, $contentType);
        return $response;
    }

    /**
     * Operation updateGuildRoleWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $role_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildRoleRequest $update_guild_role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildRole'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildRoleResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateGuildRoleWithHttpInfo(
        string $guild_id,
        string $role_id,
        \OpenAPI\Client\Model\UpdateGuildRoleRequest $update_guild_role_request,
        string $contentType = self::contentTypes['updateGuildRole'][0]
    ): array
    {
        $request = $this->updateGuildRoleRequest($guild_id, $role_id, $update_guild_role_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildRoleResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildRoleResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildRoleResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildRoleResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildRoleResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation updateGuildRoleAsync
     *
     * @param  string $guild_id (required)
     * @param  string $role_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildRoleRequest $update_guild_role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildRole'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateGuildRoleAsync(
        string $guild_id,
        string $role_id,
        \OpenAPI\Client\Model\UpdateGuildRoleRequest $update_guild_role_request,
        string $contentType = self::contentTypes['updateGuildRole'][0]
    ): PromiseInterface
    {
        return $this->updateGuildRoleAsyncWithHttpInfo($guild_id, $role_id, $update_guild_role_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateGuildRoleAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $role_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildRoleRequest $update_guild_role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildRole'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateGuildRoleAsyncWithHttpInfo(
        $guild_id,
        $role_id,
        $update_guild_role_request,
        string $contentType = self::contentTypes['updateGuildRole'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildRoleResponse';
        $request = $this->updateGuildRoleRequest($guild_id, $role_id, $update_guild_role_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateGuildRole'
     *
     * @param  string $guild_id (required)
     * @param  string $role_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildRoleRequest $update_guild_role_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildRole'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateGuildRoleRequest(
        $guild_id,
        $role_id,
        $update_guild_role_request,
        string $contentType = self::contentTypes['updateGuildRole'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling updateGuildRole'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.updateGuildRole, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'role_id' is set
        if ($role_id === null || (is_array($role_id) && count($role_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $role_id when calling updateGuildRole'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $role_id)) {
            throw new InvalidArgumentException("invalid value for \"role_id\" when calling DefaultAPI.updateGuildRole, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'update_guild_role_request' is set
        if ($update_guild_role_request === null || (is_array($update_guild_role_request) && count($update_guild_role_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $update_guild_role_request when calling updateGuildRole'
            );
        }


        $resourcePath = '/guilds/{guild_id}/roles/{role_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($role_id !== null) {
            $resourcePath = str_replace(
                '{' . 'role_id' . '}',
                ObjectSerializer::toPathValue($role_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_guild_role_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_guild_role_request));
            } else {
                $httpBody = $update_guild_role_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateGuildScheduledEvent
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $guild_scheduled_event_id guild_scheduled_event_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildScheduledEventRequest $update_guild_scheduled_event_request update_guild_scheduled_event_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildScheduledEvent'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetGuildScheduledEvent200Response|\OpenAPI\Client\Model\ErrorResponse
     */
    public function updateGuildScheduledEvent(
        string $guild_id,
        string $guild_scheduled_event_id,
        \OpenAPI\Client\Model\UpdateGuildScheduledEventRequest $update_guild_scheduled_event_request,
        string $contentType = self::contentTypes['updateGuildScheduledEvent'][0]
    ): \OpenAPI\Client\Model\GetGuildScheduledEvent200Response
    {
        list($response) = $this->updateGuildScheduledEventWithHttpInfo($guild_id, $guild_scheduled_event_id, $update_guild_scheduled_event_request, $contentType);
        return $response;
    }

    /**
     * Operation updateGuildScheduledEventWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $guild_scheduled_event_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildScheduledEventRequest $update_guild_scheduled_event_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildScheduledEvent'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetGuildScheduledEvent200Response|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateGuildScheduledEventWithHttpInfo(
        string $guild_id,
        string $guild_scheduled_event_id,
        \OpenAPI\Client\Model\UpdateGuildScheduledEventRequest $update_guild_scheduled_event_request,
        string $contentType = self::contentTypes['updateGuildScheduledEvent'][0]
    ): array
    {
        $request = $this->updateGuildScheduledEventRequest($guild_id, $guild_scheduled_event_id, $update_guild_scheduled_event_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetGuildScheduledEvent200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetGuildScheduledEvent200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetGuildScheduledEvent200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GetGuildScheduledEvent200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetGuildScheduledEvent200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation updateGuildScheduledEventAsync
     *
     * @param  string $guild_id (required)
     * @param  string $guild_scheduled_event_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildScheduledEventRequest $update_guild_scheduled_event_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildScheduledEvent'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateGuildScheduledEventAsync(
        string $guild_id,
        string $guild_scheduled_event_id,
        \OpenAPI\Client\Model\UpdateGuildScheduledEventRequest $update_guild_scheduled_event_request,
        string $contentType = self::contentTypes['updateGuildScheduledEvent'][0]
    ): PromiseInterface
    {
        return $this->updateGuildScheduledEventAsyncWithHttpInfo($guild_id, $guild_scheduled_event_id, $update_guild_scheduled_event_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateGuildScheduledEventAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $guild_scheduled_event_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildScheduledEventRequest $update_guild_scheduled_event_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildScheduledEvent'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateGuildScheduledEventAsyncWithHttpInfo(
        $guild_id,
        $guild_scheduled_event_id,
        $update_guild_scheduled_event_request,
        string $contentType = self::contentTypes['updateGuildScheduledEvent'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GetGuildScheduledEvent200Response';
        $request = $this->updateGuildScheduledEventRequest($guild_id, $guild_scheduled_event_id, $update_guild_scheduled_event_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateGuildScheduledEvent'
     *
     * @param  string $guild_id (required)
     * @param  string $guild_scheduled_event_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildScheduledEventRequest $update_guild_scheduled_event_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildScheduledEvent'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateGuildScheduledEventRequest(
        $guild_id,
        $guild_scheduled_event_id,
        $update_guild_scheduled_event_request,
        string $contentType = self::contentTypes['updateGuildScheduledEvent'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling updateGuildScheduledEvent'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.updateGuildScheduledEvent, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'guild_scheduled_event_id' is set
        if ($guild_scheduled_event_id === null || (is_array($guild_scheduled_event_id) && count($guild_scheduled_event_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_scheduled_event_id when calling updateGuildScheduledEvent'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_scheduled_event_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_scheduled_event_id\" when calling DefaultAPI.updateGuildScheduledEvent, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'update_guild_scheduled_event_request' is set
        if ($update_guild_scheduled_event_request === null || (is_array($update_guild_scheduled_event_request) && count($update_guild_scheduled_event_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $update_guild_scheduled_event_request when calling updateGuildScheduledEvent'
            );
        }


        $resourcePath = '/guilds/{guild_id}/scheduled-events/{guild_scheduled_event_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($guild_scheduled_event_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_scheduled_event_id' . '}',
                ObjectSerializer::toPathValue($guild_scheduled_event_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_guild_scheduled_event_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_guild_scheduled_event_request));
            } else {
                $httpBody = $update_guild_scheduled_event_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateGuildSticker
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $sticker_id sticker_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildStickerRequest $update_guild_sticker_request update_guild_sticker_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildSticker'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildStickerResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function updateGuildSticker(
        string $guild_id,
        string $sticker_id,
        \OpenAPI\Client\Model\UpdateGuildStickerRequest $update_guild_sticker_request,
        string $contentType = self::contentTypes['updateGuildSticker'][0]
    ): \OpenAPI\Client\Model\GuildStickerResponse
    {
        list($response) = $this->updateGuildStickerWithHttpInfo($guild_id, $sticker_id, $update_guild_sticker_request, $contentType);
        return $response;
    }

    /**
     * Operation updateGuildStickerWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $sticker_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildStickerRequest $update_guild_sticker_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildSticker'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildStickerResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateGuildStickerWithHttpInfo(
        string $guild_id,
        string $sticker_id,
        \OpenAPI\Client\Model\UpdateGuildStickerRequest $update_guild_sticker_request,
        string $contentType = self::contentTypes['updateGuildSticker'][0]
    ): array
    {
        $request = $this->updateGuildStickerRequest($guild_id, $sticker_id, $update_guild_sticker_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildStickerResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildStickerResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildStickerResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildStickerResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildStickerResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation updateGuildStickerAsync
     *
     * @param  string $guild_id (required)
     * @param  string $sticker_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildStickerRequest $update_guild_sticker_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildSticker'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateGuildStickerAsync(
        string $guild_id,
        string $sticker_id,
        \OpenAPI\Client\Model\UpdateGuildStickerRequest $update_guild_sticker_request,
        string $contentType = self::contentTypes['updateGuildSticker'][0]
    ): PromiseInterface
    {
        return $this->updateGuildStickerAsyncWithHttpInfo($guild_id, $sticker_id, $update_guild_sticker_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateGuildStickerAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $sticker_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildStickerRequest $update_guild_sticker_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildSticker'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateGuildStickerAsyncWithHttpInfo(
        $guild_id,
        $sticker_id,
        $update_guild_sticker_request,
        string $contentType = self::contentTypes['updateGuildSticker'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildStickerResponse';
        $request = $this->updateGuildStickerRequest($guild_id, $sticker_id, $update_guild_sticker_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateGuildSticker'
     *
     * @param  string $guild_id (required)
     * @param  string $sticker_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildStickerRequest $update_guild_sticker_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildSticker'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateGuildStickerRequest(
        $guild_id,
        $sticker_id,
        $update_guild_sticker_request,
        string $contentType = self::contentTypes['updateGuildSticker'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling updateGuildSticker'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.updateGuildSticker, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'sticker_id' is set
        if ($sticker_id === null || (is_array($sticker_id) && count($sticker_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sticker_id when calling updateGuildSticker'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $sticker_id)) {
            throw new InvalidArgumentException("invalid value for \"sticker_id\" when calling DefaultAPI.updateGuildSticker, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'update_guild_sticker_request' is set
        if ($update_guild_sticker_request === null || (is_array($update_guild_sticker_request) && count($update_guild_sticker_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $update_guild_sticker_request when calling updateGuildSticker'
            );
        }


        $resourcePath = '/guilds/{guild_id}/stickers/{sticker_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($sticker_id !== null) {
            $resourcePath = str_replace(
                '{' . 'sticker_id' . '}',
                ObjectSerializer::toPathValue($sticker_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_guild_sticker_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_guild_sticker_request));
            } else {
                $httpBody = $update_guild_sticker_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateGuildTemplate
     *
     * @param  string $guild_id guild_id (required)
     * @param  mixed $code code (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildTemplateRequest $update_guild_template_request update_guild_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildTemplate'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildTemplateResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function updateGuildTemplate(
        string $guild_id,
        mixed $code,
        \OpenAPI\Client\Model\UpdateGuildTemplateRequest $update_guild_template_request,
        string $contentType = self::contentTypes['updateGuildTemplate'][0]
    ): \OpenAPI\Client\Model\GuildTemplateResponse
    {
        list($response) = $this->updateGuildTemplateWithHttpInfo($guild_id, $code, $update_guild_template_request, $contentType);
        return $response;
    }

    /**
     * Operation updateGuildTemplateWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  mixed $code (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildTemplateRequest $update_guild_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildTemplate'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildTemplateResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateGuildTemplateWithHttpInfo(
        string $guild_id,
        mixed $code,
        \OpenAPI\Client\Model\UpdateGuildTemplateRequest $update_guild_template_request,
        string $contentType = self::contentTypes['updateGuildTemplate'][0]
    ): array
    {
        $request = $this->updateGuildTemplateRequest($guild_id, $code, $update_guild_template_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildTemplateResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildTemplateResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildTemplateResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildTemplateResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildTemplateResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation updateGuildTemplateAsync
     *
     * @param  string $guild_id (required)
     * @param  mixed $code (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildTemplateRequest $update_guild_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildTemplate'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateGuildTemplateAsync(
        string $guild_id,
        mixed $code,
        \OpenAPI\Client\Model\UpdateGuildTemplateRequest $update_guild_template_request,
        string $contentType = self::contentTypes['updateGuildTemplate'][0]
    ): PromiseInterface
    {
        return $this->updateGuildTemplateAsyncWithHttpInfo($guild_id, $code, $update_guild_template_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateGuildTemplateAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  mixed $code (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildTemplateRequest $update_guild_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildTemplate'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateGuildTemplateAsyncWithHttpInfo(
        $guild_id,
        $code,
        $update_guild_template_request,
        string $contentType = self::contentTypes['updateGuildTemplate'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildTemplateResponse';
        $request = $this->updateGuildTemplateRequest($guild_id, $code, $update_guild_template_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateGuildTemplate'
     *
     * @param  string $guild_id (required)
     * @param  mixed $code (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildTemplateRequest $update_guild_template_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildTemplate'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateGuildTemplateRequest(
        $guild_id,
        $code,
        $update_guild_template_request,
        string $contentType = self::contentTypes['updateGuildTemplate'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling updateGuildTemplate'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.updateGuildTemplate, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $code when calling updateGuildTemplate'
            );
        }
        if (strlen($code) > 152133) {
            throw new InvalidArgumentException('invalid length for "$code" when calling DefaultAPI.updateGuildTemplate, must be smaller than or equal to 152133.');
        }
        
        // verify the required parameter 'update_guild_template_request' is set
        if ($update_guild_template_request === null || (is_array($update_guild_template_request) && count($update_guild_template_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $update_guild_template_request when calling updateGuildTemplate'
            );
        }


        $resourcePath = '/guilds/{guild_id}/templates/{code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_guild_template_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_guild_template_request));
            } else {
                $httpBody = $update_guild_template_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateGuildWelcomeScreen
     *
     * @param  string $guild_id guild_id (required)
     * @param  \OpenAPI\Client\Model\WelcomeScreenPatchRequestPartial $welcome_screen_patch_request_partial welcome_screen_patch_request_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildWelcomeScreen'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\GuildWelcomeScreenResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function updateGuildWelcomeScreen(
        string $guild_id,
        \OpenAPI\Client\Model\WelcomeScreenPatchRequestPartial $welcome_screen_patch_request_partial,
        string $contentType = self::contentTypes['updateGuildWelcomeScreen'][0]
    ): \OpenAPI\Client\Model\GuildWelcomeScreenResponse
    {
        list($response) = $this->updateGuildWelcomeScreenWithHttpInfo($guild_id, $welcome_screen_patch_request_partial, $contentType);
        return $response;
    }

    /**
     * Operation updateGuildWelcomeScreenWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\WelcomeScreenPatchRequestPartial $welcome_screen_patch_request_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildWelcomeScreen'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GuildWelcomeScreenResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateGuildWelcomeScreenWithHttpInfo(
        string $guild_id,
        \OpenAPI\Client\Model\WelcomeScreenPatchRequestPartial $welcome_screen_patch_request_partial,
        string $contentType = self::contentTypes['updateGuildWelcomeScreen'][0]
    ): array
    {
        $request = $this->updateGuildWelcomeScreenRequest($guild_id, $welcome_screen_patch_request_partial, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GuildWelcomeScreenResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GuildWelcomeScreenResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GuildWelcomeScreenResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\GuildWelcomeScreenResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GuildWelcomeScreenResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation updateGuildWelcomeScreenAsync
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\WelcomeScreenPatchRequestPartial $welcome_screen_patch_request_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildWelcomeScreen'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateGuildWelcomeScreenAsync(
        string $guild_id,
        \OpenAPI\Client\Model\WelcomeScreenPatchRequestPartial $welcome_screen_patch_request_partial,
        string $contentType = self::contentTypes['updateGuildWelcomeScreen'][0]
    ): PromiseInterface
    {
        return $this->updateGuildWelcomeScreenAsyncWithHttpInfo($guild_id, $welcome_screen_patch_request_partial, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateGuildWelcomeScreenAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\WelcomeScreenPatchRequestPartial $welcome_screen_patch_request_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildWelcomeScreen'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateGuildWelcomeScreenAsyncWithHttpInfo(
        $guild_id,
        $welcome_screen_patch_request_partial,
        string $contentType = self::contentTypes['updateGuildWelcomeScreen'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\GuildWelcomeScreenResponse';
        $request = $this->updateGuildWelcomeScreenRequest($guild_id, $welcome_screen_patch_request_partial, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateGuildWelcomeScreen'
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\WelcomeScreenPatchRequestPartial $welcome_screen_patch_request_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildWelcomeScreen'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateGuildWelcomeScreenRequest(
        $guild_id,
        $welcome_screen_patch_request_partial,
        string $contentType = self::contentTypes['updateGuildWelcomeScreen'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling updateGuildWelcomeScreen'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.updateGuildWelcomeScreen, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'welcome_screen_patch_request_partial' is set
        if ($welcome_screen_patch_request_partial === null || (is_array($welcome_screen_patch_request_partial) && count($welcome_screen_patch_request_partial) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $welcome_screen_patch_request_partial when calling updateGuildWelcomeScreen'
            );
        }


        $resourcePath = '/guilds/{guild_id}/welcome-screen';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($welcome_screen_patch_request_partial)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($welcome_screen_patch_request_partial));
            } else {
                $httpBody = $welcome_screen_patch_request_partial;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateGuildWidgetSettings
     *
     * @param  string $guild_id guild_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildWidgetSettingsRequest $update_guild_widget_settings_request update_guild_widget_settings_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildWidgetSettings'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\WidgetSettingsResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function updateGuildWidgetSettings(
        string $guild_id,
        \OpenAPI\Client\Model\UpdateGuildWidgetSettingsRequest $update_guild_widget_settings_request,
        string $contentType = self::contentTypes['updateGuildWidgetSettings'][0]
    ): \OpenAPI\Client\Model\WidgetSettingsResponse
    {
        list($response) = $this->updateGuildWidgetSettingsWithHttpInfo($guild_id, $update_guild_widget_settings_request, $contentType);
        return $response;
    }

    /**
     * Operation updateGuildWidgetSettingsWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildWidgetSettingsRequest $update_guild_widget_settings_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildWidgetSettings'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WidgetSettingsResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateGuildWidgetSettingsWithHttpInfo(
        string $guild_id,
        \OpenAPI\Client\Model\UpdateGuildWidgetSettingsRequest $update_guild_widget_settings_request,
        string $contentType = self::contentTypes['updateGuildWidgetSettings'][0]
    ): array
    {
        $request = $this->updateGuildWidgetSettingsRequest($guild_id, $update_guild_widget_settings_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\WidgetSettingsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\WidgetSettingsResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\WidgetSettingsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\WidgetSettingsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WidgetSettingsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation updateGuildWidgetSettingsAsync
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildWidgetSettingsRequest $update_guild_widget_settings_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildWidgetSettings'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateGuildWidgetSettingsAsync(
        string $guild_id,
        \OpenAPI\Client\Model\UpdateGuildWidgetSettingsRequest $update_guild_widget_settings_request,
        string $contentType = self::contentTypes['updateGuildWidgetSettings'][0]
    ): PromiseInterface
    {
        return $this->updateGuildWidgetSettingsAsyncWithHttpInfo($guild_id, $update_guild_widget_settings_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateGuildWidgetSettingsAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildWidgetSettingsRequest $update_guild_widget_settings_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildWidgetSettings'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateGuildWidgetSettingsAsyncWithHttpInfo(
        $guild_id,
        $update_guild_widget_settings_request,
        string $contentType = self::contentTypes['updateGuildWidgetSettings'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\WidgetSettingsResponse';
        $request = $this->updateGuildWidgetSettingsRequest($guild_id, $update_guild_widget_settings_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateGuildWidgetSettings'
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\UpdateGuildWidgetSettingsRequest $update_guild_widget_settings_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateGuildWidgetSettings'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateGuildWidgetSettingsRequest(
        $guild_id,
        $update_guild_widget_settings_request,
        string $contentType = self::contentTypes['updateGuildWidgetSettings'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling updateGuildWidgetSettings'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.updateGuildWidgetSettings, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'update_guild_widget_settings_request' is set
        if ($update_guild_widget_settings_request === null || (is_array($update_guild_widget_settings_request) && count($update_guild_widget_settings_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $update_guild_widget_settings_request when calling updateGuildWidgetSettings'
            );
        }


        $resourcePath = '/guilds/{guild_id}/widget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_guild_widget_settings_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_guild_widget_settings_request));
            } else {
                $httpBody = $update_guild_widget_settings_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateMessage
     *
     * @param  string $channel_id channel_id (required)
     * @param  string $message_id message_id (required)
     * @param  \OpenAPI\Client\Model\MessageEditRequestPartial $message_edit_request_partial message_edit_request_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMessage'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\MessageResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function updateMessage(
        string $channel_id,
        string $message_id,
        \OpenAPI\Client\Model\MessageEditRequestPartial $message_edit_request_partial,
        string $contentType = self::contentTypes['updateMessage'][0]
    ): \OpenAPI\Client\Model\MessageResponse
    {
        list($response) = $this->updateMessageWithHttpInfo($channel_id, $message_id, $message_edit_request_partial, $contentType);
        return $response;
    }

    /**
     * Operation updateMessageWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  \OpenAPI\Client\Model\MessageEditRequestPartial $message_edit_request_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMessage'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MessageResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateMessageWithHttpInfo(
        string $channel_id,
        string $message_id,
        \OpenAPI\Client\Model\MessageEditRequestPartial $message_edit_request_partial,
        string $contentType = self::contentTypes['updateMessage'][0]
    ): array
    {
        $request = $this->updateMessageRequest($channel_id, $message_id, $message_edit_request_partial, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\MessageResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\MessageResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MessageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\MessageResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MessageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation updateMessageAsync
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  \OpenAPI\Client\Model\MessageEditRequestPartial $message_edit_request_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateMessageAsync(
        string $channel_id,
        string $message_id,
        \OpenAPI\Client\Model\MessageEditRequestPartial $message_edit_request_partial,
        string $contentType = self::contentTypes['updateMessage'][0]
    ): PromiseInterface
    {
        return $this->updateMessageAsyncWithHttpInfo($channel_id, $message_id, $message_edit_request_partial, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateMessageAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  \OpenAPI\Client\Model\MessageEditRequestPartial $message_edit_request_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateMessageAsyncWithHttpInfo(
        $channel_id,
        $message_id,
        $message_edit_request_partial,
        string $contentType = self::contentTypes['updateMessage'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\MessageResponse';
        $request = $this->updateMessageRequest($channel_id, $message_id, $message_edit_request_partial, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateMessage'
     *
     * @param  string $channel_id (required)
     * @param  string $message_id (required)
     * @param  \OpenAPI\Client\Model\MessageEditRequestPartial $message_edit_request_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateMessageRequest(
        $channel_id,
        $message_id,
        $message_edit_request_partial,
        string $contentType = self::contentTypes['updateMessage'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling updateMessage'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.updateMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $message_id when calling updateMessage'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $message_id)) {
            throw new InvalidArgumentException("invalid value for \"message_id\" when calling DefaultAPI.updateMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'message_edit_request_partial' is set
        if ($message_edit_request_partial === null || (is_array($message_edit_request_partial) && count($message_edit_request_partial) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $message_edit_request_partial when calling updateMessage'
            );
        }


        $resourcePath = '/channels/{channel_id}/messages/{message_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'message_id' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($message_edit_request_partial)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($message_edit_request_partial));
            } else {
                $httpBody = $message_edit_request_partial;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateMyApplication
     *
     * @param  \OpenAPI\Client\Model\ApplicationFormPartial $application_form_partial application_form_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMyApplication'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\PrivateApplicationResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function updateMyApplication(
        \OpenAPI\Client\Model\ApplicationFormPartial $application_form_partial,
        string $contentType = self::contentTypes['updateMyApplication'][0]
    ): \OpenAPI\Client\Model\PrivateApplicationResponse
    {
        list($response) = $this->updateMyApplicationWithHttpInfo($application_form_partial, $contentType);
        return $response;
    }

    /**
     * Operation updateMyApplicationWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ApplicationFormPartial $application_form_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMyApplication'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PrivateApplicationResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateMyApplicationWithHttpInfo(
        \OpenAPI\Client\Model\ApplicationFormPartial $application_form_partial,
        string $contentType = self::contentTypes['updateMyApplication'][0]
    ): array
    {
        $request = $this->updateMyApplicationRequest($application_form_partial, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PrivateApplicationResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PrivateApplicationResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PrivateApplicationResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\PrivateApplicationResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PrivateApplicationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation updateMyApplicationAsync
     *
     * @param  \OpenAPI\Client\Model\ApplicationFormPartial $application_form_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMyApplication'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateMyApplicationAsync(
        \OpenAPI\Client\Model\ApplicationFormPartial $application_form_partial,
        string $contentType = self::contentTypes['updateMyApplication'][0]
    ): PromiseInterface
    {
        return $this->updateMyApplicationAsyncWithHttpInfo($application_form_partial, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateMyApplicationAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\ApplicationFormPartial $application_form_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMyApplication'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateMyApplicationAsyncWithHttpInfo(
        $application_form_partial,
        string $contentType = self::contentTypes['updateMyApplication'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\PrivateApplicationResponse';
        $request = $this->updateMyApplicationRequest($application_form_partial, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateMyApplication'
     *
     * @param  \OpenAPI\Client\Model\ApplicationFormPartial $application_form_partial (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMyApplication'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateMyApplicationRequest(
        $application_form_partial,
        string $contentType = self::contentTypes['updateMyApplication'][0]
    ): Request
    {

        // verify the required parameter 'application_form_partial' is set
        if ($application_form_partial === null || (is_array($application_form_partial) && count($application_form_partial) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $application_form_partial when calling updateMyApplication'
            );
        }


        $resourcePath = '/applications/@me';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($application_form_partial)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($application_form_partial));
            } else {
                $httpBody = $application_form_partial;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateMyGuildMember
     *
     * @param  string $guild_id guild_id (required)
     * @param  \OpenAPI\Client\Model\UpdateMyGuildMemberRequest $update_my_guild_member_request update_my_guild_member_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMyGuildMember'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\PrivateGuildMemberResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function updateMyGuildMember(
        string $guild_id,
        \OpenAPI\Client\Model\UpdateMyGuildMemberRequest $update_my_guild_member_request,
        string $contentType = self::contentTypes['updateMyGuildMember'][0]
    ): \OpenAPI\Client\Model\PrivateGuildMemberResponse
    {
        list($response) = $this->updateMyGuildMemberWithHttpInfo($guild_id, $update_my_guild_member_request, $contentType);
        return $response;
    }

    /**
     * Operation updateMyGuildMemberWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\UpdateMyGuildMemberRequest $update_my_guild_member_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMyGuildMember'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PrivateGuildMemberResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateMyGuildMemberWithHttpInfo(
        string $guild_id,
        \OpenAPI\Client\Model\UpdateMyGuildMemberRequest $update_my_guild_member_request,
        string $contentType = self::contentTypes['updateMyGuildMember'][0]
    ): array
    {
        $request = $this->updateMyGuildMemberRequest($guild_id, $update_my_guild_member_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PrivateGuildMemberResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PrivateGuildMemberResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PrivateGuildMemberResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\PrivateGuildMemberResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PrivateGuildMemberResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation updateMyGuildMemberAsync
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\UpdateMyGuildMemberRequest $update_my_guild_member_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMyGuildMember'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateMyGuildMemberAsync(
        string $guild_id,
        \OpenAPI\Client\Model\UpdateMyGuildMemberRequest $update_my_guild_member_request,
        string $contentType = self::contentTypes['updateMyGuildMember'][0]
    ): PromiseInterface
    {
        return $this->updateMyGuildMemberAsyncWithHttpInfo($guild_id, $update_my_guild_member_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateMyGuildMemberAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\UpdateMyGuildMemberRequest $update_my_guild_member_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMyGuildMember'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateMyGuildMemberAsyncWithHttpInfo(
        $guild_id,
        $update_my_guild_member_request,
        string $contentType = self::contentTypes['updateMyGuildMember'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\PrivateGuildMemberResponse';
        $request = $this->updateMyGuildMemberRequest($guild_id, $update_my_guild_member_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateMyGuildMember'
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\UpdateMyGuildMemberRequest $update_my_guild_member_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMyGuildMember'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateMyGuildMemberRequest(
        $guild_id,
        $update_my_guild_member_request,
        string $contentType = self::contentTypes['updateMyGuildMember'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling updateMyGuildMember'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.updateMyGuildMember, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'update_my_guild_member_request' is set
        if ($update_my_guild_member_request === null || (is_array($update_my_guild_member_request) && count($update_my_guild_member_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $update_my_guild_member_request when calling updateMyGuildMember'
            );
        }


        $resourcePath = '/guilds/{guild_id}/members/@me';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_my_guild_member_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_my_guild_member_request));
            } else {
                $httpBody = $update_my_guild_member_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateMyUser
     *
     * @param  \OpenAPI\Client\Model\BotAccountPatchRequest $bot_account_patch_request bot_account_patch_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMyUser'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\UserPIIResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function updateMyUser(
        \OpenAPI\Client\Model\BotAccountPatchRequest $bot_account_patch_request,
        string $contentType = self::contentTypes['updateMyUser'][0]
    ): \OpenAPI\Client\Model\UserPIIResponse
    {
        list($response) = $this->updateMyUserWithHttpInfo($bot_account_patch_request, $contentType);
        return $response;
    }

    /**
     * Operation updateMyUserWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\BotAccountPatchRequest $bot_account_patch_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMyUser'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\UserPIIResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateMyUserWithHttpInfo(
        \OpenAPI\Client\Model\BotAccountPatchRequest $bot_account_patch_request,
        string $contentType = self::contentTypes['updateMyUser'][0]
    ): array
    {
        $request = $this->updateMyUserRequest($bot_account_patch_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\UserPIIResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\UserPIIResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\UserPIIResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\UserPIIResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\UserPIIResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation updateMyUserAsync
     *
     * @param  \OpenAPI\Client\Model\BotAccountPatchRequest $bot_account_patch_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMyUser'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateMyUserAsync(
        \OpenAPI\Client\Model\BotAccountPatchRequest $bot_account_patch_request,
        string $contentType = self::contentTypes['updateMyUser'][0]
    ): PromiseInterface
    {
        return $this->updateMyUserAsyncWithHttpInfo($bot_account_patch_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateMyUserAsyncWithHttpInfo
     *
     * @param  \OpenAPI\Client\Model\BotAccountPatchRequest $bot_account_patch_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMyUser'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateMyUserAsyncWithHttpInfo(
        $bot_account_patch_request,
        string $contentType = self::contentTypes['updateMyUser'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\UserPIIResponse';
        $request = $this->updateMyUserRequest($bot_account_patch_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateMyUser'
     *
     * @param  \OpenAPI\Client\Model\BotAccountPatchRequest $bot_account_patch_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMyUser'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateMyUserRequest(
        $bot_account_patch_request,
        string $contentType = self::contentTypes['updateMyUser'][0]
    ): Request
    {

        // verify the required parameter 'bot_account_patch_request' is set
        if ($bot_account_patch_request === null || (is_array($bot_account_patch_request) && count($bot_account_patch_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $bot_account_patch_request when calling updateMyUser'
            );
        }


        $resourcePath = '/users/@me';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($bot_account_patch_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($bot_account_patch_request));
            } else {
                $httpBody = $bot_account_patch_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateOriginalWebhookMessage
     *
     * @param  string $webhook_id webhook_id (required)
     * @param  string $webhook_token webhook_token (required)
     * @param  \OpenAPI\Client\Model\IncomingWebhookUpdateRequestPartial $incoming_webhook_update_request_partial incoming_webhook_update_request_partial (required)
     * @param  string|null $thread_id thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOriginalWebhookMessage'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\MessageResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function updateOriginalWebhookMessage(
        string $webhook_id,
        string $webhook_token,
        \OpenAPI\Client\Model\IncomingWebhookUpdateRequestPartial $incoming_webhook_update_request_partial,
        ?string $thread_id = null,
        string $contentType = self::contentTypes['updateOriginalWebhookMessage'][0]
    ): \OpenAPI\Client\Model\MessageResponse
    {
        list($response) = $this->updateOriginalWebhookMessageWithHttpInfo($webhook_id, $webhook_token, $incoming_webhook_update_request_partial, $thread_id, $contentType);
        return $response;
    }

    /**
     * Operation updateOriginalWebhookMessageWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  string $webhook_token (required)
     * @param  \OpenAPI\Client\Model\IncomingWebhookUpdateRequestPartial $incoming_webhook_update_request_partial (required)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOriginalWebhookMessage'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MessageResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateOriginalWebhookMessageWithHttpInfo(
        string $webhook_id,
        string $webhook_token,
        \OpenAPI\Client\Model\IncomingWebhookUpdateRequestPartial $incoming_webhook_update_request_partial,
        ?string $thread_id = null,
        string $contentType = self::contentTypes['updateOriginalWebhookMessage'][0]
    ): array
    {
        $request = $this->updateOriginalWebhookMessageRequest($webhook_id, $webhook_token, $incoming_webhook_update_request_partial, $thread_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\MessageResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\MessageResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MessageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\MessageResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MessageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation updateOriginalWebhookMessageAsync
     *
     * @param  string $webhook_id (required)
     * @param  string $webhook_token (required)
     * @param  \OpenAPI\Client\Model\IncomingWebhookUpdateRequestPartial $incoming_webhook_update_request_partial (required)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOriginalWebhookMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateOriginalWebhookMessageAsync(
        string $webhook_id,
        string $webhook_token,
        \OpenAPI\Client\Model\IncomingWebhookUpdateRequestPartial $incoming_webhook_update_request_partial,
        ?string $thread_id = null,
        string $contentType = self::contentTypes['updateOriginalWebhookMessage'][0]
    ): PromiseInterface
    {
        return $this->updateOriginalWebhookMessageAsyncWithHttpInfo($webhook_id, $webhook_token, $incoming_webhook_update_request_partial, $thread_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateOriginalWebhookMessageAsyncWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  string $webhook_token (required)
     * @param  \OpenAPI\Client\Model\IncomingWebhookUpdateRequestPartial $incoming_webhook_update_request_partial (required)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOriginalWebhookMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateOriginalWebhookMessageAsyncWithHttpInfo(
        $webhook_id,
        $webhook_token,
        $incoming_webhook_update_request_partial,
        $thread_id = null,
        string $contentType = self::contentTypes['updateOriginalWebhookMessage'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\MessageResponse';
        $request = $this->updateOriginalWebhookMessageRequest($webhook_id, $webhook_token, $incoming_webhook_update_request_partial, $thread_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateOriginalWebhookMessage'
     *
     * @param  string $webhook_id (required)
     * @param  string $webhook_token (required)
     * @param  \OpenAPI\Client\Model\IncomingWebhookUpdateRequestPartial $incoming_webhook_update_request_partial (required)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateOriginalWebhookMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateOriginalWebhookMessageRequest(
        $webhook_id,
        $webhook_token,
        $incoming_webhook_update_request_partial,
        $thread_id = null,
        string $contentType = self::contentTypes['updateOriginalWebhookMessage'][0]
    ): Request
    {

        // verify the required parameter 'webhook_id' is set
        if ($webhook_id === null || (is_array($webhook_id) && count($webhook_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webhook_id when calling updateOriginalWebhookMessage'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $webhook_id)) {
            throw new InvalidArgumentException("invalid value for \"webhook_id\" when calling DefaultAPI.updateOriginalWebhookMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'webhook_token' is set
        if ($webhook_token === null || (is_array($webhook_token) && count($webhook_token) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webhook_token when calling updateOriginalWebhookMessage'
            );
        }
        if (strlen($webhook_token) > 152133) {
            throw new InvalidArgumentException('invalid length for "$webhook_token" when calling DefaultAPI.updateOriginalWebhookMessage, must be smaller than or equal to 152133.');
        }
        
        // verify the required parameter 'incoming_webhook_update_request_partial' is set
        if ($incoming_webhook_update_request_partial === null || (is_array($incoming_webhook_update_request_partial) && count($incoming_webhook_update_request_partial) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $incoming_webhook_update_request_partial when calling updateOriginalWebhookMessage'
            );
        }

        if ($thread_id !== null && !preg_match("/^(0|[1-9][0-9]*)$/", $thread_id)) {
            throw new InvalidArgumentException("invalid value for \"thread_id\" when calling DefaultAPI.updateOriginalWebhookMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/webhooks/{webhook_id}/{webhook_token}/messages/@original';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $thread_id,
            'thread_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($webhook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_id' . '}',
                ObjectSerializer::toPathValue($webhook_id),
                $resourcePath
            );
        }
        // path params
        if ($webhook_token !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_token' . '}',
                ObjectSerializer::toPathValue($webhook_token),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($incoming_webhook_update_request_partial)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($incoming_webhook_update_request_partial));
            } else {
                $httpBody = $incoming_webhook_update_request_partial;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateSelfVoiceState
     *
     * @param  string $guild_id guild_id (required)
     * @param  \OpenAPI\Client\Model\UpdateSelfVoiceStateRequest $update_self_voice_state_request update_self_voice_state_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSelfVoiceState'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function updateSelfVoiceState(
        string $guild_id,
        \OpenAPI\Client\Model\UpdateSelfVoiceStateRequest $update_self_voice_state_request,
        string $contentType = self::contentTypes['updateSelfVoiceState'][0]
    ): void
    {
        $this->updateSelfVoiceStateWithHttpInfo($guild_id, $update_self_voice_state_request, $contentType);
    }

    /**
     * Operation updateSelfVoiceStateWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\UpdateSelfVoiceStateRequest $update_self_voice_state_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSelfVoiceState'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateSelfVoiceStateWithHttpInfo(
        string $guild_id,
        \OpenAPI\Client\Model\UpdateSelfVoiceStateRequest $update_self_voice_state_request,
        string $contentType = self::contentTypes['updateSelfVoiceState'][0]
    ): array
    {
        $request = $this->updateSelfVoiceStateRequest($guild_id, $update_self_voice_state_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation updateSelfVoiceStateAsync
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\UpdateSelfVoiceStateRequest $update_self_voice_state_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSelfVoiceState'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateSelfVoiceStateAsync(
        string $guild_id,
        \OpenAPI\Client\Model\UpdateSelfVoiceStateRequest $update_self_voice_state_request,
        string $contentType = self::contentTypes['updateSelfVoiceState'][0]
    ): PromiseInterface
    {
        return $this->updateSelfVoiceStateAsyncWithHttpInfo($guild_id, $update_self_voice_state_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateSelfVoiceStateAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\UpdateSelfVoiceStateRequest $update_self_voice_state_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSelfVoiceState'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateSelfVoiceStateAsyncWithHttpInfo(
        $guild_id,
        $update_self_voice_state_request,
        string $contentType = self::contentTypes['updateSelfVoiceState'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->updateSelfVoiceStateRequest($guild_id, $update_self_voice_state_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateSelfVoiceState'
     *
     * @param  string $guild_id (required)
     * @param  \OpenAPI\Client\Model\UpdateSelfVoiceStateRequest $update_self_voice_state_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateSelfVoiceState'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateSelfVoiceStateRequest(
        $guild_id,
        $update_self_voice_state_request,
        string $contentType = self::contentTypes['updateSelfVoiceState'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling updateSelfVoiceState'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.updateSelfVoiceState, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'update_self_voice_state_request' is set
        if ($update_self_voice_state_request === null || (is_array($update_self_voice_state_request) && count($update_self_voice_state_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $update_self_voice_state_request when calling updateSelfVoiceState'
            );
        }


        $resourcePath = '/guilds/{guild_id}/voice-states/@me';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_self_voice_state_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_self_voice_state_request));
            } else {
                $httpBody = $update_self_voice_state_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateStageInstance
     *
     * @param  string $channel_id channel_id (required)
     * @param  \OpenAPI\Client\Model\UpdateStageInstanceRequest $update_stage_instance_request update_stage_instance_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateStageInstance'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\StageInstanceResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function updateStageInstance(
        string $channel_id,
        \OpenAPI\Client\Model\UpdateStageInstanceRequest $update_stage_instance_request,
        string $contentType = self::contentTypes['updateStageInstance'][0]
    ): \OpenAPI\Client\Model\StageInstanceResponse
    {
        list($response) = $this->updateStageInstanceWithHttpInfo($channel_id, $update_stage_instance_request, $contentType);
        return $response;
    }

    /**
     * Operation updateStageInstanceWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\UpdateStageInstanceRequest $update_stage_instance_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateStageInstance'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\StageInstanceResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateStageInstanceWithHttpInfo(
        string $channel_id,
        \OpenAPI\Client\Model\UpdateStageInstanceRequest $update_stage_instance_request,
        string $contentType = self::contentTypes['updateStageInstance'][0]
    ): array
    {
        $request = $this->updateStageInstanceRequest($channel_id, $update_stage_instance_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\StageInstanceResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\StageInstanceResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\StageInstanceResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\StageInstanceResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StageInstanceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation updateStageInstanceAsync
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\UpdateStageInstanceRequest $update_stage_instance_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateStageInstance'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateStageInstanceAsync(
        string $channel_id,
        \OpenAPI\Client\Model\UpdateStageInstanceRequest $update_stage_instance_request,
        string $contentType = self::contentTypes['updateStageInstance'][0]
    ): PromiseInterface
    {
        return $this->updateStageInstanceAsyncWithHttpInfo($channel_id, $update_stage_instance_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateStageInstanceAsyncWithHttpInfo
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\UpdateStageInstanceRequest $update_stage_instance_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateStageInstance'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateStageInstanceAsyncWithHttpInfo(
        $channel_id,
        $update_stage_instance_request,
        string $contentType = self::contentTypes['updateStageInstance'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\StageInstanceResponse';
        $request = $this->updateStageInstanceRequest($channel_id, $update_stage_instance_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateStageInstance'
     *
     * @param  string $channel_id (required)
     * @param  \OpenAPI\Client\Model\UpdateStageInstanceRequest $update_stage_instance_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateStageInstance'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateStageInstanceRequest(
        $channel_id,
        $update_stage_instance_request,
        string $contentType = self::contentTypes['updateStageInstance'][0]
    ): Request
    {

        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $channel_id when calling updateStageInstance'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $channel_id)) {
            throw new InvalidArgumentException("invalid value for \"channel_id\" when calling DefaultAPI.updateStageInstance, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'update_stage_instance_request' is set
        if ($update_stage_instance_request === null || (is_array($update_stage_instance_request) && count($update_stage_instance_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $update_stage_instance_request when calling updateStageInstance'
            );
        }


        $resourcePath = '/stage-instances/{channel_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channel_id' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_stage_instance_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_stage_instance_request));
            } else {
                $httpBody = $update_stage_instance_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateVoiceState
     *
     * @param  string $guild_id guild_id (required)
     * @param  string $user_id user_id (required)
     * @param  \OpenAPI\Client\Model\UpdateVoiceStateRequest $update_voice_state_request update_voice_state_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateVoiceState'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function updateVoiceState(
        string $guild_id,
        string $user_id,
        \OpenAPI\Client\Model\UpdateVoiceStateRequest $update_voice_state_request,
        string $contentType = self::contentTypes['updateVoiceState'][0]
    ): void
    {
        $this->updateVoiceStateWithHttpInfo($guild_id, $user_id, $update_voice_state_request, $contentType);
    }

    /**
     * Operation updateVoiceStateWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  \OpenAPI\Client\Model\UpdateVoiceStateRequest $update_voice_state_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateVoiceState'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateVoiceStateWithHttpInfo(
        string $guild_id,
        string $user_id,
        \OpenAPI\Client\Model\UpdateVoiceStateRequest $update_voice_state_request,
        string $contentType = self::contentTypes['updateVoiceState'][0]
    ): array
    {
        $request = $this->updateVoiceStateRequest($guild_id, $user_id, $update_voice_state_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                
            }
            throw $e;
        }
    }

    /**
     * Operation updateVoiceStateAsync
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  \OpenAPI\Client\Model\UpdateVoiceStateRequest $update_voice_state_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateVoiceState'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateVoiceStateAsync(
        string $guild_id,
        string $user_id,
        \OpenAPI\Client\Model\UpdateVoiceStateRequest $update_voice_state_request,
        string $contentType = self::contentTypes['updateVoiceState'][0]
    ): PromiseInterface
    {
        return $this->updateVoiceStateAsyncWithHttpInfo($guild_id, $user_id, $update_voice_state_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateVoiceStateAsyncWithHttpInfo
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  \OpenAPI\Client\Model\UpdateVoiceStateRequest $update_voice_state_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateVoiceState'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateVoiceStateAsyncWithHttpInfo(
        $guild_id,
        $user_id,
        $update_voice_state_request,
        string $contentType = self::contentTypes['updateVoiceState'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->updateVoiceStateRequest($guild_id, $user_id, $update_voice_state_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateVoiceState'
     *
     * @param  string $guild_id (required)
     * @param  string $user_id (required)
     * @param  \OpenAPI\Client\Model\UpdateVoiceStateRequest $update_voice_state_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateVoiceState'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateVoiceStateRequest(
        $guild_id,
        $user_id,
        $update_voice_state_request,
        string $contentType = self::contentTypes['updateVoiceState'][0]
    ): Request
    {

        // verify the required parameter 'guild_id' is set
        if ($guild_id === null || (is_array($guild_id) && count($guild_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $guild_id when calling updateVoiceState'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $guild_id)) {
            throw new InvalidArgumentException("invalid value for \"guild_id\" when calling DefaultAPI.updateVoiceState, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'user_id' is set
        if ($user_id === null || (is_array($user_id) && count($user_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $user_id when calling updateVoiceState'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $user_id)) {
            throw new InvalidArgumentException("invalid value for \"user_id\" when calling DefaultAPI.updateVoiceState, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'update_voice_state_request' is set
        if ($update_voice_state_request === null || (is_array($update_voice_state_request) && count($update_voice_state_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $update_voice_state_request when calling updateVoiceState'
            );
        }


        $resourcePath = '/guilds/{guild_id}/voice-states/{user_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($guild_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guild_id' . '}',
                ObjectSerializer::toPathValue($guild_id),
                $resourcePath
            );
        }
        // path params
        if ($user_id !== null) {
            $resourcePath = str_replace(
                '{' . 'user_id' . '}',
                ObjectSerializer::toPathValue($user_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_voice_state_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_voice_state_request));
            } else {
                $httpBody = $update_voice_state_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateWebhook
     *
     * @param  string $webhook_id webhook_id (required)
     * @param  \OpenAPI\Client\Model\UpdateWebhookRequest $update_webhook_request update_webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhook'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner|\OpenAPI\Client\Model\ErrorResponse
     */
    public function updateWebhook(
        string $webhook_id,
        \OpenAPI\Client\Model\UpdateWebhookRequest $update_webhook_request,
        string $contentType = self::contentTypes['updateWebhook'][0]
    ): \OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner
    {
        list($response) = $this->updateWebhookWithHttpInfo($webhook_id, $update_webhook_request, $contentType);
        return $response;
    }

    /**
     * Operation updateWebhookWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  \OpenAPI\Client\Model\UpdateWebhookRequest $update_webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhook'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateWebhookWithHttpInfo(
        string $webhook_id,
        \OpenAPI\Client\Model\UpdateWebhookRequest $update_webhook_request,
        string $contentType = self::contentTypes['updateWebhook'][0]
    ): array
    {
        $request = $this->updateWebhookRequest($webhook_id, $update_webhook_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation updateWebhookAsync
     *
     * @param  string $webhook_id (required)
     * @param  \OpenAPI\Client\Model\UpdateWebhookRequest $update_webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhook'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateWebhookAsync(
        string $webhook_id,
        \OpenAPI\Client\Model\UpdateWebhookRequest $update_webhook_request,
        string $contentType = self::contentTypes['updateWebhook'][0]
    ): PromiseInterface
    {
        return $this->updateWebhookAsyncWithHttpInfo($webhook_id, $update_webhook_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateWebhookAsyncWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  \OpenAPI\Client\Model\UpdateWebhookRequest $update_webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhook'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateWebhookAsyncWithHttpInfo(
        $webhook_id,
        $update_webhook_request,
        string $contentType = self::contentTypes['updateWebhook'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner';
        $request = $this->updateWebhookRequest($webhook_id, $update_webhook_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateWebhook'
     *
     * @param  string $webhook_id (required)
     * @param  \OpenAPI\Client\Model\UpdateWebhookRequest $update_webhook_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhook'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateWebhookRequest(
        $webhook_id,
        $update_webhook_request,
        string $contentType = self::contentTypes['updateWebhook'][0]
    ): Request
    {

        // verify the required parameter 'webhook_id' is set
        if ($webhook_id === null || (is_array($webhook_id) && count($webhook_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webhook_id when calling updateWebhook'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $webhook_id)) {
            throw new InvalidArgumentException("invalid value for \"webhook_id\" when calling DefaultAPI.updateWebhook, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'update_webhook_request' is set
        if ($update_webhook_request === null || (is_array($update_webhook_request) && count($update_webhook_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $update_webhook_request when calling updateWebhook'
            );
        }


        $resourcePath = '/webhooks/{webhook_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webhook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_id' . '}',
                ObjectSerializer::toPathValue($webhook_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_webhook_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_webhook_request));
            } else {
                $httpBody = $update_webhook_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateWebhookByToken
     *
     * @param  string $webhook_id webhook_id (required)
     * @param  mixed $webhook_token webhook_token (required)
     * @param  \OpenAPI\Client\Model\UpdateWebhookByTokenRequest $update_webhook_by_token_request update_webhook_by_token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhookByToken'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner|\OpenAPI\Client\Model\ErrorResponse
     */
    public function updateWebhookByToken(
        string $webhook_id,
        mixed $webhook_token,
        \OpenAPI\Client\Model\UpdateWebhookByTokenRequest $update_webhook_by_token_request,
        string $contentType = self::contentTypes['updateWebhookByToken'][0]
    ): \OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner
    {
        list($response) = $this->updateWebhookByTokenWithHttpInfo($webhook_id, $webhook_token, $update_webhook_by_token_request, $contentType);
        return $response;
    }

    /**
     * Operation updateWebhookByTokenWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  \OpenAPI\Client\Model\UpdateWebhookByTokenRequest $update_webhook_by_token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhookByToken'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateWebhookByTokenWithHttpInfo(
        string $webhook_id,
        mixed $webhook_token,
        \OpenAPI\Client\Model\UpdateWebhookByTokenRequest $update_webhook_by_token_request,
        string $contentType = self::contentTypes['updateWebhookByToken'][0]
    ): array
    {
        $request = $this->updateWebhookByTokenRequest($webhook_id, $webhook_token, $update_webhook_by_token_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation updateWebhookByTokenAsync
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  \OpenAPI\Client\Model\UpdateWebhookByTokenRequest $update_webhook_by_token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhookByToken'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateWebhookByTokenAsync(
        string $webhook_id,
        mixed $webhook_token,
        \OpenAPI\Client\Model\UpdateWebhookByTokenRequest $update_webhook_by_token_request,
        string $contentType = self::contentTypes['updateWebhookByToken'][0]
    ): PromiseInterface
    {
        return $this->updateWebhookByTokenAsyncWithHttpInfo($webhook_id, $webhook_token, $update_webhook_by_token_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateWebhookByTokenAsyncWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  \OpenAPI\Client\Model\UpdateWebhookByTokenRequest $update_webhook_by_token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhookByToken'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateWebhookByTokenAsyncWithHttpInfo(
        $webhook_id,
        $webhook_token,
        $update_webhook_by_token_request,
        string $contentType = self::contentTypes['updateWebhookByToken'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\ListChannelWebhooks200ResponseInner';
        $request = $this->updateWebhookByTokenRequest($webhook_id, $webhook_token, $update_webhook_by_token_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateWebhookByToken'
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  \OpenAPI\Client\Model\UpdateWebhookByTokenRequest $update_webhook_by_token_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhookByToken'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateWebhookByTokenRequest(
        $webhook_id,
        $webhook_token,
        $update_webhook_by_token_request,
        string $contentType = self::contentTypes['updateWebhookByToken'][0]
    ): Request
    {

        // verify the required parameter 'webhook_id' is set
        if ($webhook_id === null || (is_array($webhook_id) && count($webhook_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webhook_id when calling updateWebhookByToken'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $webhook_id)) {
            throw new InvalidArgumentException("invalid value for \"webhook_id\" when calling DefaultAPI.updateWebhookByToken, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'webhook_token' is set
        if ($webhook_token === null || (is_array($webhook_token) && count($webhook_token) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webhook_token when calling updateWebhookByToken'
            );
        }
        if (strlen($webhook_token) > 152133) {
            throw new InvalidArgumentException('invalid length for "$webhook_token" when calling DefaultAPI.updateWebhookByToken, must be smaller than or equal to 152133.');
        }
        
        // verify the required parameter 'update_webhook_by_token_request' is set
        if ($update_webhook_by_token_request === null || (is_array($update_webhook_by_token_request) && count($update_webhook_by_token_request) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $update_webhook_by_token_request when calling updateWebhookByToken'
            );
        }


        $resourcePath = '/webhooks/{webhook_id}/{webhook_token}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webhook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_id' . '}',
                ObjectSerializer::toPathValue($webhook_id),
                $resourcePath
            );
        }
        // path params
        if ($webhook_token !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_token' . '}',
                ObjectSerializer::toPathValue($webhook_token),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_webhook_by_token_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_webhook_by_token_request));
            } else {
                $httpBody = $update_webhook_by_token_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateWebhookMessage
     *
     * @param  string $webhook_id webhook_id (required)
     * @param  mixed $webhook_token webhook_token (required)
     * @param  string $message_id message_id (required)
     * @param  \OpenAPI\Client\Model\IncomingWebhookUpdateRequestPartial $incoming_webhook_update_request_partial incoming_webhook_update_request_partial (required)
     * @param  string|null $thread_id thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhookMessage'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \OpenAPI\Client\Model\MessageResponse|\OpenAPI\Client\Model\ErrorResponse
     */
    public function updateWebhookMessage(
        string $webhook_id,
        mixed $webhook_token,
        string $message_id,
        \OpenAPI\Client\Model\IncomingWebhookUpdateRequestPartial $incoming_webhook_update_request_partial,
        ?string $thread_id = null,
        string $contentType = self::contentTypes['updateWebhookMessage'][0]
    ): \OpenAPI\Client\Model\MessageResponse
    {
        list($response) = $this->updateWebhookMessageWithHttpInfo($webhook_id, $webhook_token, $message_id, $incoming_webhook_update_request_partial, $thread_id, $contentType);
        return $response;
    }

    /**
     * Operation updateWebhookMessageWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  string $message_id (required)
     * @param  \OpenAPI\Client\Model\IncomingWebhookUpdateRequestPartial $incoming_webhook_update_request_partial (required)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhookMessage'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MessageResponse|\OpenAPI\Client\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateWebhookMessageWithHttpInfo(
        string $webhook_id,
        mixed $webhook_token,
        string $message_id,
        \OpenAPI\Client\Model\IncomingWebhookUpdateRequestPartial $incoming_webhook_update_request_partial,
        ?string $thread_id = null,
        string $contentType = self::contentTypes['updateWebhookMessage'][0]
    ): array
    {
        $request = $this->updateWebhookMessageRequest($webhook_id, $webhook_token, $message_id, $incoming_webhook_update_request_partial, $thread_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\MessageResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\MessageResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\MessageResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                
            }

            $returnType = '\OpenAPI\Client\Model\MessageResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                         );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MessageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                
            }
            throw $e;
        }
    }

    /**
     * Operation updateWebhookMessageAsync
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  string $message_id (required)
     * @param  \OpenAPI\Client\Model\IncomingWebhookUpdateRequestPartial $incoming_webhook_update_request_partial (required)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhookMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateWebhookMessageAsync(
        string $webhook_id,
        mixed $webhook_token,
        string $message_id,
        \OpenAPI\Client\Model\IncomingWebhookUpdateRequestPartial $incoming_webhook_update_request_partial,
        ?string $thread_id = null,
        string $contentType = self::contentTypes['updateWebhookMessage'][0]
    ): PromiseInterface
    {
        return $this->updateWebhookMessageAsyncWithHttpInfo($webhook_id, $webhook_token, $message_id, $incoming_webhook_update_request_partial, $thread_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateWebhookMessageAsyncWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  string $message_id (required)
     * @param  \OpenAPI\Client\Model\IncomingWebhookUpdateRequestPartial $incoming_webhook_update_request_partial (required)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhookMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateWebhookMessageAsyncWithHttpInfo(
        $webhook_id,
        $webhook_token,
        $message_id,
        $incoming_webhook_update_request_partial,
        $thread_id = null,
        string $contentType = self::contentTypes['updateWebhookMessage'][0]
    ): PromiseInterface
    {
        $returnType = '\OpenAPI\Client\Model\MessageResponse';
        $request = $this->updateWebhookMessageRequest($webhook_id, $webhook_token, $message_id, $incoming_webhook_update_request_partial, $thread_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateWebhookMessage'
     *
     * @param  string $webhook_id (required)
     * @param  mixed $webhook_token (required)
     * @param  string $message_id (required)
     * @param  \OpenAPI\Client\Model\IncomingWebhookUpdateRequestPartial $incoming_webhook_update_request_partial (required)
     * @param  string|null $thread_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhookMessage'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateWebhookMessageRequest(
        $webhook_id,
        $webhook_token,
        $message_id,
        $incoming_webhook_update_request_partial,
        $thread_id = null,
        string $contentType = self::contentTypes['updateWebhookMessage'][0]
    ): Request
    {

        // verify the required parameter 'webhook_id' is set
        if ($webhook_id === null || (is_array($webhook_id) && count($webhook_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webhook_id when calling updateWebhookMessage'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $webhook_id)) {
            throw new InvalidArgumentException("invalid value for \"webhook_id\" when calling DefaultAPI.updateWebhookMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'webhook_token' is set
        if ($webhook_token === null || (is_array($webhook_token) && count($webhook_token) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $webhook_token when calling updateWebhookMessage'
            );
        }
        if (strlen($webhook_token) > 152133) {
            throw new InvalidArgumentException('invalid length for "$webhook_token" when calling DefaultAPI.updateWebhookMessage, must be smaller than or equal to 152133.');
        }
        
        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $message_id when calling updateWebhookMessage'
            );
        }
        if (!preg_match("/^(0|[1-9][0-9]*)$/", $message_id)) {
            throw new InvalidArgumentException("invalid value for \"message_id\" when calling DefaultAPI.updateWebhookMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        
        // verify the required parameter 'incoming_webhook_update_request_partial' is set
        if ($incoming_webhook_update_request_partial === null || (is_array($incoming_webhook_update_request_partial) && count($incoming_webhook_update_request_partial) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $incoming_webhook_update_request_partial when calling updateWebhookMessage'
            );
        }

        if ($thread_id !== null && !preg_match("/^(0|[1-9][0-9]*)$/", $thread_id)) {
            throw new InvalidArgumentException("invalid value for \"thread_id\" when calling DefaultAPI.updateWebhookMessage, must conform to the pattern /^(0|[1-9][0-9]*)$/.");
        }
        

        $resourcePath = '/webhooks/{webhook_id}/{webhook_token}/messages/{message_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $thread_id,
            'thread_id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($webhook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_id' . '}',
                ObjectSerializer::toPathValue($webhook_id),
                $resourcePath
            );
        }
        // path params
        if ($webhook_token !== null) {
            $resourcePath = str_replace(
                '{' . 'webhook_token' . '}',
                ObjectSerializer::toPathValue($webhook_token),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'message_id' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($incoming_webhook_update_request_partial)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($incoming_webhook_update_request_partial));
            } else {
                $httpBody = $incoming_webhook_update_request_partial;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption(): array
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
